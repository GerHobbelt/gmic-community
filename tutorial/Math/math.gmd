# Mathematical Expressions
%% m scripts/nr.gmic x "mkdir -p img" ({u([255,255,255])}^{u([255,255,255])}^{u([255,255,255])}^200,220,240) -permute cyzx 1200,1200,1,2 nrframe[-1] [-2],{25.3027+u(-0.005,0.005)},{0.998034+u(-0.0005,0.0005)},0.27,200,20 -rm.. r. 25%,25%,100%,100%,5 n. 0,255 o. img/nrfront.png rm %%
|![newtonrhapson](img/nrfront.png)|G'MIC pipeline commands function on the "image indivisible." Consider ''-blur'': it operates on its selected images; soft-edged, lower-variance versions appear in their steads. During its course ''-blur'' admits no interventions. How it goes about blurring is beyond the scripter's ken, save through adjusting command line arguments.\n\nMost times, such opacity is welcome; people have concerns other than with the devils in details. But should the details matter, then there are G'MIC's [Mathematical Expressions](https://gmic.eu/reference/mathematical_expressions.html#top), which operate from _within_ images — on the very bitmaps comprising those images. They cannot be invoked except within certain pipeline settings, yet when invoked they put forward a complete programming language that operates in an environment where rasters of any number of images may be directly accessed along with aspects of the environment itself.\n\n( [Download Newton-Raphson Generator](scripts/nr.gmic) )

There are three pipeline settings in which mathematical expressions can appear:

| 1.  |__Logic Flags:__ Mathematical expressions furnish logical flags for flow control commands. The return value is taken to be a boolean. See [Example One](#examone).
| 2.  |__Raster Processing:__ Mathematial expressions implement [pel or pixel processors](https://gmic.eu/tutorial/fill.html#math_expressions). The return value is taken to be a per-pel scalar or per-pixel vector; specifics depend on the last statement's composition. Vector return values imply pixel processors; scalar return values imply pel processors. Return values update pels or pixels as iterations proceed. See [Example Two](#examtwo).
| 3.  |__Image Feature Substitutions:__ As the bodies of _image feature substitution expressions_, mathematical expressions initialize pipeline variables or set command arguments. The return value completes a pipeline variable key-value pair or furnishes a value for an argument. See [Example Three](#examthree).

Within these settings, mathematical expressions are built up from sequences of _statements_ separated by semicolons; the trailing semi-colon may be omitted; the aggregate constitutes the expression. The last statement connects the mathematical expression with its pipeline setting. The computed value of that last statement becomes the expression's return value. A non-computing final statement returns a _<nan>_ ("not-a-number"), a floating point library metavalue. The subsequent fate of such returns follows from the math expression's pipeline processing setting.

Except in a few corner cases, such as an empty image stack, mathematical expressions operate with respect to _reference images_. These establish much of the environment in which mathematical expressions operate, including a host of predefined variables conveying image metrics such as `iv` (variance) or `ia` (median value).
| 1.  |The last item on the image list is the reference for logical expressions.
| 2.  |The currently processing image is the reference for raster processors.
| 3.  |In image feature substitutions, `{` _<index>,<expression>_ `}`, A prefix integer, comma-separated from the math expression, selects the reference image via its list index. Without a prefix, the reference image defaults to the last image on the list. [Name](https://gmic.eu/tutorial/name.html) labels may appear instead of image indices, but the allied named collection should contain only one image: a multi-image collection raises errors, as it is not clear which in the collection is the reference.

= examone
__Example One:__
You want to produce an output conditioned on an image feature:

|-%% 256,256,1,3 noise. 32,0 n. 0,255 do b. 1,1 while iv>4  %%|`reducevariance: -skip ${1=256},${2=5},${3=5}`\n   `sz,nlevel,cutoff=${1-3}`\n   `-input $sz,$sz,1,3`\n   `-name noisy`\n   `-noise[noisy] $nlevel,0`\n   `-normalize[noisy] 0,255`\n   `-do`\n      `-blur[noisy] 1,1`\n   `-while iv>$cutoff`\n   `-echo "Image\ Variance:\ "{iv}`
|    |*Mostly invariant variance*

| 1.  |A mathematical expression, `iv>$cutoff`, operating as a logical flag, asserts a ''-do'' … ''-while'' exit condition. Iterative blurring ceases when the current image's variance, the predefined math expression variable `iv`, is no longer greater than a supplied `$cutoff` level.
| 2.  |G'MIC's pipeline interpreter dereferences such keys as `$cutoff` before pre-processing mathematical expressions. Here, the pipeline iterpreter first dereferences the key `$cutoff` and substitutes its value within the math expression, then turns the expression over to the mathematical expression parser. That parser does not "see" the string `iv>$cutoff`, but instead `iv>0.8125`, presuming a user-supplied third argument of `0.8125.` G'MIC always dereferences pipeline variables, substituting keys for values, before evaluating math expressions. By this, one may write pipeline variables in math expressions; after key-value substitutions, the mathematical expression parser consumes the value, typically as a "constant numeric", and not the key. See [Substitution Cheats](https://gmic.eu/tutorial/subs_cheat.html) for background.

= examtwo
__Example Two:__
You want to produce an image reflecting the averaged, absolute differences of luminance between pixels and their immediate ±x-axis neighbors.
~~~
xdiff: 
    -luminance
    -fill. (abs((j(-1,0)-i))+abs(i-j(1,0)))/2
    -normalize. 0,255
~~~
===
|%% images/forestflowers.png r. 45%,45%,100%,100% %% | %% images/forestflowers.png r. 45%,45%,100%,100% -luminance. -f. (abs((j(-1,0)-i))+abs(i-j(1,0)))/2 n. 0,255 %%
| *Forest* | *Differed Forest*
===
———
~~~
$ gmic xdiff.gmic -input forest.png -verbose + +xdiff. -output. differed_forest.png
[gmic]-0./ Start G'MIC interpreter.
[gmic]-0./ Input custom command file 'xdiff.gmic' (1 new, total: 4572).
[gmic]-0./ Input file 'forest.png' at position 0 (1 image 768x768x1x3).
[gmic]-1./ Increment verbosity level (set to 2).
[gmic]-1./xdiff/ Compute luminance of image [0].
[gmic]-1./xdiff/ Fill image [0] with expression '(abs((j(-1,0)-i))+abs(i-j(1,0)))/2'.
[gmic]-1./xdiff/ Normalize image [0] in range [0,255], with constant-case ratio 0.
[gmic]-2./ Output image [1] as png file 'img/differed_forestflowers.png'.
[gmic]-2./ End G'MIC interpreter.
~~~
| 1.  |Commands ''-input'', ''-fill'' and ''-eval'' each may take [pel or pixel processor](https://gmic.eu/tutorial/fill.html#math_expressions) arguments, these to define, change or evaluate images procedurally.
|      a.  |If given, ''-input'' repeatedly applies its fifth argument — a math expression — to each pel or pixel, part-and-parcel with image initialization.
|      b.  |Similarly, ''-fill'' alters bitmaps in accordance with its math expression argument, also applied to every pixel or pel.
|      c.  |Like ''-fill'', ''-eval'' also takes a math expression argument and iterates over the raster, but the last statement in the expresion does not automatically alter the bitmap. Such expressions operate for their side-effects instead.
| 2.  |The heart of `xdiff` is the ''-fill'' command and its _[pel processor](https://gmic.eu/tutorial/array_cheat.html#pixelaccess)_ argument: `(abs((j(-1,0)-i))+abs(i-j(1,0)))/2`. Those new to math expressions may be forgiven if the expression's Delphic composition seems enigmatic: Oh Pythia! What do you mean? _Are the Persians coming or not?_ (She just smiles).
|   a.  |Pel processors iterate over the channel rasters themselves, one picture element (pel) at a time: a scalar. With the present example, the processor takes the average of the absolute values of two differences, these of center pels and their x-axis predecessors and successors. Such computations exhibits edge sensitivity.
|   b.  |When, along the x-axis, the center pel is more-or-less equal to its predecessor and sucessor, the two differences are small; so follows the average of their absolutes. the image locality exhibits shallow gradients; the results exhibits only low luminance.
|   c.  |On the other hand, differences vary greatly in localities of steep gradients; the results exhibit high luminance because the differences and their absolute averages are large.

Even in this pel processor précis, it is worth emphasizing that the mathematical expression implementing it executes once for every channel value (a.k.a. _pel_). A 768×768 image with red, green and blue channels will induce 768×768×3=1,769,472 separate expression operations. As an aside, fashioning a vector final result is typically faster, as the return value updates all channels at each `x`, `y` pixel location; only 768×768=589,824 operations are needed.

In concert with the command line, common mathematical expression functions tend to terse, single-letter names. `i()` and `j()`, the so-called [pixel access operators](https://gmic.eu/tutorial/array_cheat.html#pixel_access_operators), are almost universally present in math expressions. They assume, respectively, the thirty-two bit float value of the "current center pel" in the iteration (read: `i`), or those thirty-two bit float values of the immediate ± x-axis neighbors (read: `j`). At the iteration's conclusion, the pel processor has "filled" the selected image with these computed absolute difference averages, overwriting whatever pel data may have been constituting the raster before.

= examthree
__Example Three:__
You want to compute a value to initialize a pipeline variable and command arguments, these based on certain characteristics of the default image. For that, use mathematical expression image features: [Substitution Expressions](https://gmic.eu/tutorial/subs_cheat.html#subexpressions).
~~~
 1 vdiffmedian:
 2   -name. original
 3   oave={$original,_ia}
 4   +text_outline. "Average:\ "$oave,3%,82%,7.5%,1,1,255,240,200
 5   -name. {0,n}"_0"
 6   -repeat 5
 7     trial={$>+1}
 8     mset={5*$trial}
 9     +median[original] $mset,$oave
10     vdiff={_iv#$original-iv}
11     -text_outline. "#\ "$trial"\ Med:\ "$mset,3%,82%,7.5%,1,1,255,240,200
12     -text_outline. "dvar:\ "$vdiff,3%,90%,7.5%,1,1,255,240,200
13     -name. {0,n}"_"$trial
14   -done
15   -display[^0]
~~~
%% images/forestflowers.png r2dx 22% =>. orig oave={$orig,_ia} +text_outline. "Average:\ "$oave,3%,82%,7.5%,1,1,255,240,200 o. img/med_0.jpg,65 repeat 5 trial={$>+1} mset={5*$trial} +median[orig] $mset,$oave vdiff={_iv#$orig-iv} -text_outline. "#\ "$trial"\ Med:\ "$mset,3%,82%,7.5%,1,1,255,240,200 text_outline. "dvar:\ "$vdiff,3%,90%,7.5%,1,1,255,240,200 o. img/med_{$trial}.jpg,65 done rm %%
===
|-![med_0](img/med_0.jpg)|![med_1](img/med_1.jpg)|![med_2](img/med_2.jpg)
|![med_3](img/med_3.jpg)|![med_4](img/med_4.jpg)|![med_5](img/med_5.jpg)
===
`vdiffmedian` is one of a class of finger exercises one might write to better apprise the effect of pipeline commands and their arguments. Here, ''-median'' is on the examination table; its selective blurring can be dream-like. There are a number of image feature substitution expressions in play with this finger exercise: <todo>
