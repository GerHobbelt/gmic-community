# check (+)
%% x "mkdir -p img" %%
%% m scripts/roses.gmic roses 4096,1,0,-11,1,0,-7,1,0,5 expand_xy[canvas] 16 -dilate_circ[canvas] 16 *[canvas] -1 label[canvas] *[canvas] {255/iM} -map[canvas] hocuspocus r2dx[canvas] 300,5 o. img/arabesque.png rm %%
|![frontimage](img/arabesque.png)|''-check'' throws exceptions if the given test expression arguments resolve to false, otherwise it takes no action. It is the command of choice for sanity-checking argument lists.\nIf any command on the calling chain is a ''-local'' … ''-endlocal'' block with an ''-onfail'' section, the exception is caught and further processing resumes. Otherwise G'MIC prints the test expression in the shell log and ceases operation.\nIf the test expression is not a math expression, `-check` tests if the expression is a filename and resolves to True if the file exists, and false otherwise.\nConsider using ''-error'' if some control over the error message is desired. `-error` unconditionally throws exceptions, so it is combined with conditional commands to emulate `-check,` but in a less compact way.
= examples
## Examples
= arabesques
## Drawing arabesques
In the realm of change two representations hold sway: variations in the frequency domain and those of time. The latter has a more visceral hold on us — we live through time — but the former encompasses transience. And so, in our school days, we forced marched through [Fourier transforms](https://en.wikipedia.org/wiki/Fourier_transform) without stopping to admire the scenery. A pity. Some of it is quite nice and nearly all is thoroughly intriguing. Ponder wheels-within-wheels.

Not too many years ago, animations of [wheels-within-wheels](https://www.youtube.com/watch?v=-qgreAUpPwM) erupted on venues like YouTube and similar — fantastic constructions of gyrating circles doing etch-a-sketch things: drawing birds, flowers, even portraits of Jean-Baptiste Joseph Fourier, the French mathematician who devised these eponymous transforms. [3blue1brown](https://www.youtube.com/watch?v=s_L-fp8gDzY) entered the expository fray with [But what is the Fourier Transform? A visual introduction.](https://www.youtube.com/watch?v=spUNpyF58BY) favoring illustrative animations over notational expository. Just a few wheels occasion arabesques, our jumping off point.

Let us build an arabesque drawing script, one that takes any number of spinning circles as arguments and draws the ensuing path. Argument sanity checking furnishes an ample exercise for using `-check.`
= arguments
### Arguments and check tests
With each circle we may:
1. rotate clockwise or counterclockwise.
2. choose a rate of rotation.
3. pick a starting orientation.
4. change diameter.
5. attach another circle to the rim. Do that any number of times, _or_
6. attach a pen to the rim of a terminal circle. Do that once.

Actions 1 through 4 encode a frequency sample: a circle of a particular size spinning clockwise or counterclockwise at a particular rate and starting from a specific orientation. Action 5 admits samples in multitude. Action 6 connects frequency samples to time-varying phenomena. From aggregates of frequency-encoding circles emerges a time-signal: the path that the pen draws. This may seem like silly fun — and it is — but that last action is key: it connects the frequency and time domains through a chain of spinning circles.

To make best use of ''-check'', aim to be as exacting about argument specifications as possible; then sanity checks practically write themselves.

1. Let the initial argument specify the size of a square drawing field: an image of the complex plane, origin centered. This is expressed in an integer count of pixels greater than zero.
2. Let the remaining arguments – as many as we wish – form triplets:
   a. A relative circle diameter, taken from the closed interval \[0…1]
   b. An orientation, or _phase_ angle, taken from the closed interval \[0…360]
   c. A discrete angular velocity, expressed as a relative number of integral revolutions per an unspecified period. It matters not a whit to us whether millenia or microseconds pass in a single revolution; it is the outcome, not the drawing time, that interests us. The argument is an integer taken from the interval \[-∞…+∞] — but see [Angular Velocity](#angularvelocity) for practical limitations.
= angularvelocity
### Angular Velocity
We've may code counter- versus clockwise rotation in the angular velocity's sign. Let positive angular velocities represent counterclockwise rotations, negative clockwise. This reflects a preference of the right hand rule; we may easily have preferred left-handedness with a sign change. We also express angular velocity in fixed, whole revolutions per period steps, a consequence of using the discrete form of the Fourier transform. G'MIC implements these with built-in commands, simplifying the implementation greatly.

We are not quite yet shut of angular velocity; there is the [Nyquist frequency](https://en.wikipedia.org/wiki/Nyquist_frequency). Consider the mapping of one cycle to a pair of contrasting pixels. This two-pixel "wavelength", relative to the image's smallest dimension, establishes the image's Nyquist frequency – the ultimate rate-of-change cap on transience from one contrast to another. A 4,000 pixel square image has a Nyquist frequency of 2,000 cycles. higher frequency variations instead appear as aliasing artifacts. Think of the distant picket fence image projecting onto evenly spaced camera sensing elements: a slowly varying sinusoidal pattern, the beat frequency between fence pickets and sensors, alias for fence pickets instead. However, there is a "practical" upper frequency limit that is less — perhaps _much_ less — than the Nyquist frequency.

How much less? Much depends on artifact tolerance. In any case, we might consider `-check` tests keyed to limiting the discrete angular velocity to some fraction of the size of the drawing image. We'll put that in our kit of possible improvements and take up the implementation of the arabesque script itself.
= roses
### Roses
The name has whimsical origins; many arabesques look like roses. You may alias this as you like, however. The full script, uninterrupted by commentary, concludes the last section. The impatient may scroll down and swipe `roses.gmic` into their personal `.gmic` or        `user.gmic` files.
===
~~~
roses:
   # Fetch an arbitrarily long argument list to $a0, $a1, … $an
   $=a

   # Two row vectors for real and imaginary frequency domain samples. Size from first
   # argument
   sw={$a1/2}
   -input $sw,1,1,1
   -name. real
   -input $sw,1,1,1
   -name. imag

~~~
===
The line beginning with `roses: ` commences a [custom command definition](https://gmic.eu/tutorial/bouncing_balls_tutorial.html). The code following `:` up to the end of the file or a the commencement of a follow-on custom command definition, to wit: the label, colon and follow-on code, constitutes `roses's` implementation. Custom commands are the easiest way to [cheat the shell](https://gmic.eu/tutorial/custom_cheat.html), minimizing its interference in interpreting special charcters. See [Adding Custom Commands](https://gmic.eu/reference/adding_custom_commands.html#top)

Here, we introduce the `roses` custom command; what follows is its implementation. Somewhat over half of the implementation concerns reading what could be an arbitrarily long argument list furnishing any number of frequency domain samples. Recall that the _argument list pattern_ we have settled upon is first: the size, in pixels, of the neighborhood surrounding the origin of the complex plane. Following: any number of triplets, to wit: a relative radial length, zero to one inclusive, an initial orientation, in degrees  

= arabesques
### Arabesques
Let us feed the script some triplets

= forwardtransform
### The Forward Transform
Let us feed some triplits to roses that we got somewhere:

??? roses.gmic
~~~
roses :
   # Fetch an arbitrarily long argument list to $a0, $a1, … $an
   $=a

   # Two row vectors for real and imaginary frequency domain samples. Size from first
   # argument
   sw={$a1/2}
   -input $sw,1,1,1
   -name. real
   -input $sw,1,1,1
   -name. imag

   # Fetch and check diameter, phase angle and angular velocity parameters
   -repeat $#-1,j
      -if   $j%3==0 # get radius
         rad=${a{2+$j}}
         -check isnum($rad)" && "$rad>=0" && "$rad<=1
      -elif $j%3==1 # get angle, degrees
         ang=${a{2+$j}}
         -check isnum($ang)" && "$ang>=0" && "$ang<=360
      -else         # get ω and set spectral coefficient
         sf=${a{2+$j}}
         -check isnum($sf)" && "$sf%1==0" && "abs($sf)<=0.1*$sw
         -if $sf<0
            sf={$sf+$sw}
         -fi
         rr={$rad*cos(deg2rad($ang))}
         ir={$rad*sin(deg2rad($ang))}
         -set[real] $rr,$sf,0,0,0
         -set[imag] $ir,$sf,0,0,0
      -fi
   -done

   # Frequency domain → time domain
   -ifft[imag,real]
   -append[-2,-1] c
   -name. temporal
   -normalize[temporal] 0,{2*$sw-16}
   -add[temporal] 8
   -input {2*$sw},{2*$sw},1,1
   -name. canvas

   # Plot arabesque
   -permute[temporal] cyzx
   -eval[canvas] ">begin(PV=crop(#0);polygon(#-1,-s#0,PV,1,0xffffffff,255))"
   -keep[canvas]
~~~
???

# Command reference

===
"""
gmic -h check
"""
===
"""
date -u
"""
