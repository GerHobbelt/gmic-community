# check (+)
%% x "mkdir -p img" %%
%% m mic scripts/roses.gmic roses 4096,0.6,0,-1,0.75,0,-5,0.1875,0,7,0.45,0,-19 expand_xy[canvas] 16 -dilate_circ[canvas] 16 -mul[canvas] -1 label[canvas] -mul[canvas] {255/iM} -map[canvas] hocuspocus r2dx[canvas] 300,5 o. img/arabesque.png rm %%
|![frontimage](img/arabesque.png)|''-check'' throws exceptions if the given expression argument resolve to False, otherwise it takes no action. Commonly, the argument is a string math expression so composed to embody a series of tests, often on required features that command arguments are to have. As such, it is the command of choice for sanity-checking argument lists.\nIf any calling scope encompasses a ''-local'' … ''-endlocal'' block with an ''-onfail'' section, the exception is caught and further processing resumes in the `-onfail` section. Otherwise G'MIC prints its argument as an exception message in the shell and ceases operation.\nIf the argument is not a math expression, `-check` tests if the string represents a file system object; such resolves to True if it exists and False otherwise.\nConsider using ''-error'' if some control over the error message is desired. `-error` unconditionally throws exceptions, so it is combined with conditional commands to emulate `-check,` but in a less compact way.
= examples
## Examples
===
~~~
$ gmic check 0 echo 'Done!'
[gmic]-0./ Start G'MIC interpreter.
[gmic]-0./ *** Error *** Command 'check': Expression '0' evaluated to false.

$ gmic check 1 echo 'Fooooo!'
[gmic]-0./ Start G'MIC interpreter.
[gmic]-0./ Fooooo!
[gmic]-0./ End G'MIC interpreter.
~~~
===
`-check` throws an exception immediately if its argument is false; G'MIC does not operate on the remainder of the pipeline. Instead, the exception message echoes the expression argument given to `-check.`
===
~~~
display_graph : check "${1=0}>=0 && ${2=0}>=0" …
dg : check "${1=0}>=0 && ${2=0}>=0" skip ${3=1},${4=0},${5=0},${6=0},${7=0},${8=0},"${9=x-axis}","${10=y-axis}"…
~~~
===
Very frequently, `-check` constitutes the first line in [custom command definitions](https://gmic.eu/reference/adding_custom_commands.html#top), its argument a sanity-checking math expression. These test arguments for properties that are in keeping with the custom command. In these examples, `-check` takes one argument, a string, which G'MIC processes as a [math expression](https://gmic.eu/reference/mathematical_expressions.html#top), substituting the results for the string. `-check` interprets non-zero results as True; G'MIC proceeds with the rest of the pipeline. Zero-results are False and `-check` throws an exception, using its argument string as the exception message.
Use ''-skip'' with ''-check'' to set a custom command argument item to a default value, but exclude it from `-check` processing. Effectively, this creates an optional argument that has a default value.
= arabesques
## Drawing arabesques
%% -m scripts/wheelie_anim.gmic wheelie_anim 300,0.6,0,1,0.5,0,5,0.125,0,-7,0.3,0,-14 o img/arabesque.mp4,{30000/1001},H264 rm %%
|![Arabesque](img/arabesque.mp4)\n*"Four wheelies on a lark"*|"Follow your nose" is a disparaging slant, uttered by the chattering classes when consumed over a certain lack of finesse in some poor sod's code. "Follow your nose" entails taking what is more-or-less in front of one's nose and coding a design — functional, straightforward and unimaginative. Denigrations aside, much straightfoward and unimaginative work has found its way into The Making of Things, a yeoman effort, useful if not exceptional, built along obvious, if not optimal, lines. Eventually, somebody comes along with an arch, but until then, post-and-lintel serves all the exigencies that doors may have.\n\nSo consider [wheelies](https://www.youtube.com/watch?v=-qgreAUpPwM): fantastic constructions of gyrating arrows, erupting on YouTube and the like, that do etch-a-sketch things: drawing birds, flowers, even portraits of Jean-Baptiste Joseph Fourier. Follow your nose and find just line segments — _wheelies_ — each with one rooted and one free endpoint. If making arabesques is your order, then look no further than a chains of wheelies to draw them.\n\nLet's do that.|
= wheelie
### Wheelies
With a wheelie, one could:
1. rotate clockwise or counterclockwise.
2. choose a rate of rotation.
3. pick a starting orientation.
4. set a length.
5. root the first wheelie at the origin.
6. root other wheelies at free end points. Do that any number of times, _or_
7. attach a pen to the rim of a terminal wheelie. Do that once.
A wheelie chain-building script, each link differing in length, initial orientation and rotation rate, furnishes ample settings for `-check` exercises. To make best use of `-check`, be as exacting about arguments as patience allows. With dillegence, G'MIC sanity checks then practically write themselves.
1. __An image to draw in__: let the initial argument specify the size of a canvas, origin centered. This argument looks like an integer count greater than zero.
2. Let the remaining arguments – as many as desired – form triplets; each specifies one wheelie in the chain. Its elements are:
   a. __length__: taken from the closed interval \[0…1]
   b. __orientation__: taken from the closed interval \[0…360]
   c. __rotational velocity__: a relative integer multiplier of one revolution. That revolution may take microseconds or millenia, but — being in a relative frame of mind — one doesn't care. It is the drawing, not the duration of drawing, that interests. Rotational velocity comes from the interval \[-∞…+∞], but not reasonably so. Image resolution will certainly impose a narrower range. Counter- versus clockwise rotation may be nicely coded in the angular velocity's sign. Let positive angular velocities represent clockwise rotations, negative counterclockwise, reflecting a left hand rule bias — the author's native handedness. Those preferring otherwise may drop a sign somewhere. Mind your feet. Signs can be heavy.
??? wheelie.gmic
~~~
wheelie :
   # wheelie: a circle of a particular (1) radius, (2) phase angle
   # (orientation) and (3) discrete angular velocity - a relative
   # integral number of revolutions per however long one revolution
   # takes. Wheelies chain together, the center of one situated at 0°
   # on the rim of its predecessor. The first wheelie of the chain
   # centers at the origin and the last has, instead of another
   # wheelie, an attached marking pen. Thus, the entire ensemble draws an
   # "arabesque" as the individual wheelies rotate at their respective
   # angular velocities from their initial orientations. This script
   # animates such.

   # Fetch an arbitrarily long argument list to $a0, $a1, …, $an

   $=a

   # Expect data triplets: radius, phase angle, angular velocity.

   -check "isint($a1) && !(($#-1)%3)"

   # Initial argument: side width (sw)

   sw={$a1/2}

   # Argument image: For each wheelie, compose radius and phase
   # arguments into a homogeneous transform. In the generation loop, we
   # compose this with the angle resulting from one angular velocity
   # step.

   ccnt={round(($#-1)/3,1,-1)}
   -input $ccnt,1,1,12
   -name  args

   # Iterate over argument vector. For each triplet – representing a
   # wheelie – Fetch radius (rad), phase angle (ang) and angular
   # velocity (sf) parameters.

   -repeat $#-1,j
      -if   $j%3==0 # get radius
         rad=${a{2+$j}}
         -check isnum($rad)" && "$rad>=0" && "$rad<=1
         -set[args] $rad,{round($j/3,1,-1)},0,0,0
      -elif $j%3==1 # get angle, degrees
         ang=${a{2+$j}}
         -check isnum($ang)" && "$ang>=0" && "$ang<=360
         -set[args] $ang,{round($j/3,1,-1)},0,0,1
      -else         # get ω and set spectral coefficient
         sf=${a{2+$j}}
         -check isnum($sf)" && "$sf%1==0" && "abs($sf)<=0.1*$sw
         -set[args] $sf,{round($j/3,1,-1)},0,0,2
      -fi
   -done

   # Iterate over argument image, each 12 channel pixel representing
   # one wheelie. The first three channels contain wheelie radius,
   # phase angle and radial velocity. Compose a homogeneous matrix
   # transforming the origin to the tip of the wheelie, a radial
   # translation and phase rotation. Populate the nine remaining
   # channels with this matrix.

   -fill[args] ">
                  CPX=I;
                  orot=rot([0,0,1],deg2rad(CPX[1])); # phase rotation
                  xlat=eye(3);
                  xlat[2]=CPX[0];                    # translation origin-to-rim
                  FIN=[CPX[0,3,1],mul(orot,xlat,3)]; # args+"RADX" i.e. 'rotation & xlation'
                  FIN                                # store above in 12-channel pixel
               "
   -permute[args] cyzx
   -store[args] circles

   # Screenspace transform.
   ssxfrm={specw=get('sw',1,0);id=eye(3);id[0]=0;id[1]=specw[0]/2;id[2]=specw[0];id[3]=-specw[0]/2;id[4]=0;id[5]=specw[0];id}

   # Draw arabesques on this image
   -input {2*$sw},{2*$sw},1,1
   -name. canvas

   atk=0
   lastpt={vector3([0,0,1])}
   firstpt={vector3([0,0,1])}
   -repeat 3*$sw,k
       # For each wheelie:
       #    increment by angular velocity
       #    find corresponding homogeneous rotation matrix
       #    compose with radial argument image, compose with screenspace transform and plot
       # via polygon()

       -eval ">
                ccnt="$ccnt";
                fpt=get('firstpt',3,0);
                ik=get('k',1,0);
                lpt=get('lastpt',3,0);
                omega=get('atk',1,0);
                specw=get('sw',1,0);
                pp=vector"{3*($ccnt+1)}"([0,0,1]);
                circs=get('circles',"{12*$ccnt}",0);
                repeat(
                         ccnt,k,
                         idx=ccnt-k-1;
                         rbradx=mul(
                                     rot([0,0,1],circs[12*idx+2]*omega[0]),
                                     circs[12*idx+3,9,1],
                                     3
                                   );
                         repeat(
                                 k+1,j,
                                 px=rbradx*pp[3*(k-j),3];
                                 pp[3*(k-j)]=px[0];
                                 pp[3*(k-j)+1]=px[1];
                                 pp[3*(k-j)+2]=px[2];
                               )
                      );
               ssx=get('ssxfrm',9,0);
               plt=ssx*pp[0,3];
               ik[0]>0?
                   polygon(#-1,-2,[plt[0,2],lpt[0,2]],1,0xffffffff,255):
                   store(plt,'firstpt',3,1,1,1);
               store(plt,'lastpt',3,1,1,1);
               ik[0]==(3*specw[0]-1)?
                  polygon(#-1,-2,[fpt[0,2],plt[0,2]],1,0xffffffff,255)
              "
       atk={2*pi*($k/(3*$sw-1))}
   -done
~~~
???

= walkthroughs
### Walkthroughs
===
~~~
wheelie:
   # Fetch an arbitrarily long argument list to $a0, $a1, … $an
   $=a
~~~
===
| 1.  |The line beginning with `wheelie: ` commences a [custom command definition](https://gmic.eu/tutorial/bouncing_balls_tutorial.html) of the form _<custom_command_name>_ : _<definition…>,_ with the commands after `:` constituting the implementation; see and [Use Custom Commands to Bypass the Shell](https://gmic.eu/tutorial/custom_cheat.html) and [Adding Custom Commands](https://gmic.eu/reference/adding_custom_commands.html#top).
| 2.  |The construct `$=a`, a kind of meta-assignment, belongs to a set of `$-expressions` available inside command definitions, and, in conjunction two other `$-expressions,` `$*` and `$#,` furnish information about the argument list.
|   a.  |G'MIC substitutes occurences of `$*` with the argument list as detected in the [parent scope](https://gmic.eu/tutorial/debug_cheat.html#debuggery). `$*` duplicates the argument list _exactly_ as it appears following `wheelie` itself.
|   b.  |The other two `$-expressions` furnish additional parsing of the argument list. G'MIC substitutes `$#` with the count of argument list items. These items arise from splitting the argument list on its comma separators, excluding those that might appear in properly escaped string arguments.
|   c.  |`$=` _<nametemplate>_ is a meta-assignment which G'MIC expands into a sequence of actual assignments, one for each item in the blocked-out argument list, plus command name itself. The variable names consist of the `nametemplate,` here `a`, appended with the position numeral. Thus, for the pipeline `wheelie 2048,0.875,31.75,5` G'MIC expands `$=a` into `a0=wheelie a1=2048 a2=0.875 a3=31.75 a4=5`. This preliminary argument list processing saves some work for us and permits open-ended, variable-length argument lists. For our purposes, we have no use for `$a0`, though other scripts could perform conditional processing based on the command name. `$a1` identifies the length of one side of the drawing field. The remaining arguments, taken three at a time, specify wheelies.
===
~~~
   # Expect data triplets: radius, phase angle, angular velocity.

   -check "isint($a1) && !(($#-1)%3)"

   # Initial argument: side width (sw)

   sw={$a1/2}

   # Argument image: For each wheelie, compose radius and phase
   # arguments into a homogeneous transform. In the generator loop, we
   # compose this with the angle resulting from one angular velocity
   # step.

   ccnt={round(($#-1)/3,1,-1)}
   -input $ccnt,1,1,12
   -name  args
~~~
===
| 1.  |Here, we subject the argument list to two broad tests. We wish the first argument, `$a1` is to be an positive integer, as this argument conveys a discrete length of pixels and there is a provision against fractional pixels. We wish the count of remaining arguments however many that may be, to be divisible by three — because wheelie parameters come in groups of three and _some_ remainder indicates omitted or excess arguments. Here, G'MIC substitutes `$#-1` for the number of items in the argument list, less one, to account for the initial canvas size argument.\n\nWe could check more. In fact, we could check _everything_, right _here_, in an all-inclusive logic string; it is not uncommon to find such in the start-up of custom commands. It may be a matter of style, but a case can be made for distributive checking, to wit: check just what is needed to be checked, and no more, at various parts of the script. Recall that `-check` includes its entire argument string in a thrown exception. Should that argument string encapsulate dozens of tests, then it may not be clear in which part of the script that the failure occurs. Contrast this with a small number of tests originating from a `-check` that concerns itself with just the matters of an immediate locale. Quite likely, that check may be quite a bit more clear on what the difficulty may be, as the `-check` string embodies just a few tests on variables in a certain locality.
| 2.  |`$sw` — "side width." Half the width, or height of the arabesque image. This is a significant metric to the rest of the script as it establishes working resolution and how to scale the arabesque image.
| 3.  |We assess `$#-1` once again, this time to determine the number of wheelies defined by the command line: divide `$#-1` by three to get the number of triplets or "circle counts", taking "circle" to be an alias for "wheelie".\n\nThe curly braces around the computation signals the G'MIC command line parser to run the math expression processor on the string. The math expression parser doesn't _exactly_ see this string as written: command line variables like `$#` undergo `$-expression` substitutions before the math expression parser sees the string. Following the substitution, the math expression parser just processes the substituted `$#` _value_, whatever that may be, and not the literal string `$#` — which it never "sees". It is worthwhile to note that _successive_ substitutions take place here. After the command line processor performs the various `$-expression` substitutions, it passes the transformed string to the math expression processor. That processor compiles the string into bytecode, using a "Just-in-time (JIT)" compiler, and then executes that bytecode. Barring a throw of an exception, the math expression parser returns a numeric string reflecting the value produced by the last computation encoded in the math expression — for math expressions can be multi-line, these marked by `;` separators, for multi-stage computation. Examples of such follow in the arabesque plotter, further down in the script.     
| 4.  |The twelve channel G'MIC image _args_ is not harnessed to display anything; rather, it is destined for use as an argument table for follow-on math expressions. The layout of one twelve channel pixel consists of the wheelie length, phase angle and angular velocity. The remaining channels contain a nine element homogeneous transformation matrix that, when composed, carries a point centered at the base of the wheelie to its tip. Finding this matrix is a pre-composition exercise. The long game entails computing matrices that carry points from the image origin to wheelie tips so as to plot tip paths under rotation; the matrix pre-composed here is just the transform from a wheelie's root to its tip.    
===
~~~
   # Iterate over argument vector. For each triplet – representing a
   # wheelie – Fetch radius (rad), phase angle (ang) and angular
   # velocity (sf) parameters.

   -repeat $#-1,j
      -if   $j%3==0 # get radius
         rad=${a{2+$j}}
         -check isnum($rad)" && "$rad>=0" && "$rad<=1
         -set[args] $rad,{round($j/3,1,-1)},0,0,0
      -elif $j%3==1 # get angle, degrees
         ang=${a{2+$j}}
         -check isnum($ang)" && "$ang>=0" && "$ang<=360
         -set[args] $ang,{round($j/3,1,-1)},0,0,1
      -else         # get ω and set spectral coefficient
         sf=${a{2+$j}}
         -check isnum($sf)" && "$sf%1==0" && "abs($sf)<=0.1*$sw
         -set[args] $sf,{round($j/3,1,-1)},0,0,2
      -fi
   -done

   # Iterate over argument image, each 12 channel pixel representing
   # one wheelie. The first three channels contain wheelie radius,
   # phase angle and radial velocity. Compose a homogeneous matrix
   # transforming the origin to the tip of the wheelie, a radial
   # translation and phase rotation. Populate the nine remaining
   # channels with this matrix.

   -fill[args] ">
                  CPX=I;
                  orot=rot([0,0,1],deg2rad(CPX[1])); # phase rotation
                  xlat=eye(3);
                  xlat[2]=CPX[0];                    # translation origin-to-rim
                  FIN=[CPX[0,3,1],mul(orot,xlat,3)]; # args+"RADX" i.e. 'rotation & xlation'
                  FIN                                # store above in 12-channel pixel
               "
~~~
===
= tripletiteration
| 1.  |The `-repeat…done` loop iterates over the portion of the argument list following the image size specification; an `-if…-elif…-else…-fi` "argument sieve" occupies the body of this iterator. Each section of the sieve checks, respectively, an argument of the triplet, wheelie length when the argument index modulo 3 is zero, phase angle when modulo 3 is one and angular of the  hosts three `-check 
| 2.  |
| 3.  |
= forwardtransform
### The Forward Transform
Let us feed some triplits to roses that we got somewhere:

[3blue1brown](https://www.youtube.com/watch?v=s_L-fp8gDzY) entered the expository fray with [But what is the Fourier Transform? A visual introduction.](https://www.youtube.com/watch?v=spUNpyF58BY) favoring illustrative animations over notational expository. Just a few wheels occasion arabesques, our jumping off point.





# Command reference

===
"""
gmic -h check
"""
===
"""
date -u
"""
