# check (+)
%% x "mkdir -p img" %%
%% m mic scripts/roses.gmic roses 4096,0.6,0,-1,0.75,0,-5,0.1875,0,7,0.45,0,-19 expand_xy[canvas] 16 -dilate_circ[canvas] 16 -mul[canvas] -1 label[canvas] -mul[canvas] {255/iM} -map[canvas] hocuspocus r2dx[canvas] 300,5 o. img/arabesque.png rm %%
|![frontimage](img/arabesque.png)|''-check'' throws exceptions if the given math expression argument resolves to False, otherwise it takes no action. It is the tool of choice for checking command arguments, taking math expressions designed to resolve to True for argument lists posessing must-have features.\nIf any calling scope encompasses a ''-local'' … ''-endlocal'' block with an ''-onfail'' section, the exception is caught and further processing resumes in the `-onfail` section. Otherwise `-check` uses its argument for the exception message and exits G'MIC.\nSince 2.6, `-check` no longer directly tests for file system objects; use math expressions `isfile()` or `isdir()` in the math expression instead.\nConsider using ''-error'' if a custom message is desired. Since `-error` unconditionally throws exceptions, combine it with conditional commands to emulate `-check,` but in a less compact way.
= examples
## Examples
===
~~~
$ gmic check 0 echo 'Done!'
[gmic]-0./ Start G'MIC interpreter.
[gmic]-0./ *** Error *** Command 'check': Expression '0' evaluated to false.

$ gmic check 1 echo 'Fooooo!'
[gmic]-0./ Start G'MIC interpreter.
[gmic]-0./ Fooooo!
[gmic]-0./ End G'MIC interpreter.
~~~
===
`-check` throws an exception immediately if its argument is False; G'MIC does not operate on the remainder of the pipeline. Instead, `-check` commences to exit the scopes in which the pipeline may be embedded. Should any of those scopes reside in an ''-onfail'' section of a ''-local'' … ''-endlocal'' block, then G'MIC resumes processing in that section. Otherwise, `-check` echoes its argument in the shell log and G'MIC quits. `-check` performs no operation if its argument is True.
===
~~~
display_graph : check "${1=0}>=0 && ${2=0}>=0" …
dg : check "${1=0}>=0 && ${2=0}>=0" skip ${3=1},${4=0},${5=0},${6=0},${7=0},${8=0},"${9=x-axis}","${10=y-axis}"…
~~~
===
Very frequently, `-check` constitutes the first line in [custom command definitions](https://gmic.eu/reference/adding_custom_commands.html#top), its argument a sanity-checking math expression. These test arguments for properties upon which the custom command depends. In these examples, `-check` takes one argument, a string, which G'MIC processes as a [math expression](https://gmic.eu/reference/mathematical_expressions.html#top), substituting the results of the expression for the string. `-check` interprets non-zero math expression results as True, and G'MIC proceeds with the rest of the pipeline. Zero-results are False and `-check` throws an exception, using its argument string as the exception message.
Use ''-skip'' with ''-check'' to set custom command arguments to default values, but exclude such from `-check` processing. Effectively, this creates an optional argument that has a default value.
===
__ `onfail.gmic` __
~~~
sameas :
   left=$1
   right=$2
   local
      testit $left,$right
      echo $left" is the same as "$right"."
      onfail
         echo $left" differs from "$right"."
         quit
   endlocal

testit : check "${1}==${2}"

        §§§

$ gmic onfail.gmic sameas 3,3
[gmic]-0./ Start G'MIC interpreter.
[gmic]-0./ Input custom command file 'onfail.gmic' (2 new, total: 4447).
[gmic]-0./sameas/*local/ 3 is the same as 3.
[gmic]-0./ End G'MIC interpreter.

 $ gmic onfail.gmic sameas 4,3
[gmic]-0./ Start G'MIC interpreter.
[gmic]-0./ Input custom command file 'onfail.gmic' (2 new, total: 4447).
[gmic]-0./sameas/*local/ 4 differs from 3.
~~~
===
Wrapping `-check` within an ''-onfail'' section of a ''-local'' … ''-endlocal'' block may lead to more sophisticated handling of thrown exceptions, not the least of which being more purpose-specific error messages or the saving of already-generated images from the effects of an inopportune exception. This approach is not peculiar to `-check` but to any circumstance where an exception is possible.
= arabesques
## Drawing arabesques
%% -m scripts/wheelie_anim.gmic wheelie_anim 300,0.6,0,1,0.5,0,5,0.125,0,-7,0.3,0,-14 o img/arabesque.mp4,{30000/1001},H264 rm %%
|![Arabesque](img/arabesque.mp4)\n                  *"Four wheelies on a lark"*|"Follow your nose" is a disparaging slant, uttered by the chattering classes when consumed over a certain lack of finesse in some poor sod's code. "Follow your nose" entails taking what is more-or-less in front of one's nose and coding a design — functional, straightforward and unimaginative. Denigrations aside, much straightfoward and unimaginative work has found its way into The Making of Things, a yeoman effort, useful if not exceptional, built along obvious, if not optimal, lines. Eventually, somebody comes along with an arch, but until then, post-and-lintel serves all the exigencies that doors may have.\n\nSo consider [wheelies](https://www.youtube.com/watch?v=-qgreAUpPwM): fantastic constructions of gyrating arrows, erupting on YouTube and the like, that do etch-a-sketch things: drawing birds, flowers, even portraits of Jean-Baptiste Joseph Fourier. Follow your nose and find just line segments — _wheelies_ — each with one rooted and one free endpoint. If making arabesques is your order, then look no further than a chain of wheelies.
= wheelie
### Wheelies
With a wheelie, one could:
1. rotate clockwise or counterclockwise around the rooted end.
2. choose a rate of rotation.
3. pick a starting orientation.
4. set a length.
5. root the first wheelie at the origin.
6. root other wheelies at free end points. Do that any number of times, _or_
7. attach a pen to the rim of a terminal wheelie. Do that once.
A wheelie chain-building script, each link possessing a length, initial orientation and rotation rate, furnishes ample settings for `-check` exercises. To make best use of `-check`, be as exacting about arguments as patience allows. With dillegence, G'MIC sanity checks then practically write themselves.
1. __An image to draw in__: let the initial argument specify the size of a drawing surface, origin centered. This argument looks like an integer count of pixels that is greater than zero.
2. Let the remaining arguments – as many as desired – form triplets; each specifies one wheelie in the chain. Its elements are:
   a. __length__: taken from the closed interval \[0…1]
   b. __orientation__: taken from the closed interval \[0…360]
   c. __rotational velocity__: a relative integer multiplier of one revolution. That revolution may take microseconds or millenia, but — being in a relative frame of mind — one doesn't care. It is the drawing, not the duration of drawing, that matters. Rotational velocity theoretically comes from the interval \[-∞…+∞], but not practically so. Image resolution has a hand in this and will certainly impose a narrower range. Counter- versus clockwise rotation may be nicely coded in the angular velocity's sign. Let positive angular velocities represent clockwise rotations, negative counterclockwise, reflecting a left hand rule bias — the author's native handedness. Those preferring otherwise may drop a sign somewhere. Mind your feet. Signs can be heavy.
??? wheelie.gmic
~~~
wheelie :
   # wheelie: a circle of a particular (1) radius, (2) phase angle
   # (orientation) and (3) discrete angular velocity - a relative
   # integral number of revolutions per however long one revolution
   # takes. Wheelies chain together, the center of one situated at 0°
   # on the rim of its predecessor. The first wheelie of the chain
   # centers at the origin and the last has, instead of another
   # wheelie, an attached marking pen. Thus, the entire ensemble draws an
   # "arabesque" as the individual wheelies rotate at their respective
   # angular velocities from their initial orientations. This script
   # animates such.

   # Fetch an arbitrarily long argument list to $a0, $a1, …, $an

   $=a

   # Expect data triplets: radius, phase angle, angular velocity.

   -check "isint($a1) && !(($#-1)%3)"

   # Initial argument: side width (sw)

   sw={$a1/2}

   # Argument image: For each wheelie, compose radius and phase
   # arguments into a transformation matrix. In the generation loop, we
   # compose this with the angle resulting from one angular velocity
   # step.

   ccnt={round(($#-1)/3,1,-1)}
   -input $ccnt,1,1,12
   -name  args

   # Iterate over argument vector. For each triplet – representing a
   # wheelie – Fetch radius (rad), phase angle (ang) and angular
   # velocity (sf) parameters.

   -repeat $#-1,j
      -if   $j%3==0 # get radius
         rad=${a{2+$j}}
         -check isnum($rad)" && "$rad>=0" && "$rad<=1
         -set[args] $rad,{round($j/3,1,-1)},0,0,0
      -elif $j%3==1 # get angle, degrees
         ang=${a{2+$j}}
         -check isnum($ang)" && "$ang>=0" && "$ang<=360
         -set[args] $ang,{round($j/3,1,-1)},0,0,1
      -else         # get ω and set spectral coefficient
         sf=${a{2+$j}}
         -check isint($sf)" && "abs($sf)<=0.1*$sw
         -set[args] $sf,{round($j/3,1,-1)},0,0,2
      -fi
   -done

   # Iterate over argument image, each 12 channel pixel representing
   # one wheelie. The first three channels contain wheelie radius,
   # phase angle and radial velocity. Compose a matrix
   # transforming the origin to the tip of the wheelie, a radial
   # translation and phase rotation. Populate the nine remaining
   # channels with this matrix.

   -fill[args] ">
                  CPX=I;
                  orot=rot([0,0,1],deg2rad(CPX[1])); # phase rotation
                  xlat=eye(3);
                  xlat[2]=CPX[0];                    # translation origin-to-rim
                  FIN=[CPX[0,3,1],mul(orot,xlat,3)]; # args+"RADX" i.e. 'rotation & xlation'
                  FIN                                # store above in 12-channel pixel
               "
   -permute[args] cyzx
   -store[args] circles

   # Screenspace transform.
   ssxfrm={specw=get('sw',1,0);id=eye(3);id[0]=0;id[1]=specw[0]/2;id[2]=specw[0];id[3]=-specw[0]/2;id[4]=0;id[5]=specw[0];id}

   # Draw arabesques on this image
   -input {2*$sw},{2*$sw},1,1
   -name. canvas

   atk=0
   lastpt={vector3([0,0,1])}
   firstpt={vector3([0,0,1])}
   -repeat 3*$sw,k
       # For each wheelie:
       #    increment by angular velocity
       #    find corresponding rotation matrix
       #    compose with radial argument image, compose with screenspace transform and plot
       # via polygon()

       -eval ">
                ccnt="$ccnt";
                fpt=get('firstpt',3,0);
                ik=get('k',1,0);
                lpt=get('lastpt',3,0);
                omega=get('atk',1,0);
                specw=get('sw',1,0);
                pp=vector"{3*($ccnt+1)}"([0,0,1]);
                circs=get('circles',"{12*$ccnt}",0);
                repeat(
                         ccnt,k,
                         idx=ccnt-k-1;
                         rbradx=mul(
                                     rot([0,0,1],circs[12*idx+2]*omega[0]),
                                     circs[12*idx+3,9,1],
                                     3
                                   );
                         repeat(
                                 k+1,j,
                                 px=rbradx*pp[3*(k-j),3];
                                 pp[3*(k-j)]=px[0];
                                 pp[3*(k-j)+1]=px[1];
                                 pp[3*(k-j)+2]=px[2];
                               )
                      );
               ssx=get('ssxfrm',9,0);
               plt=ssx*pp[0,3];
               ik[0]>0?
                   polygon(#-1,-2,[plt[0,2],lpt[0,2]],1,0xffffffff,255):
                   store(plt,'firstpt',3,1,1,1);
               store(plt,'lastpt',3,1,1,1);
               ik[0]==(3*specw[0]-1)?
                  polygon(#-1,-2,[fpt[0,2],plt[0,2]],1,0xffffffff,255)
              "
       atk={2*pi*($k/(3*$sw-1))}
   -done
~~~
???

= walkthroughs
### Walkthroughs
===
~~~
01. wheelie:
02.    # Fetch an arbitrarily long argument list to $a0, $a1, … $an
03.    $=a
~~~
===
 01.  The line beginning with `wheelie: ` commences a [custom command definition](https://gmic.eu/tutorial/bouncing_balls_tutorial.html) of the form _<custom_command_name>_ : _<definition…>,_ with the commands after `:` constituting the implementation; see [Use Custom Commands to Bypass the Shell](https://gmic.eu/tutorial/custom_cheat.html) and [Adding Custom Commands](https://gmic.eu/reference/adding_custom_commands.html#top).
 03.  The construct `$=a`, a kind of meta-assignment, belongs to a set of `$-expressions` available inside command definitions, and, in conjunction two other `$-expressions,` `$*` and `$#,` furnish information about the argument list.
   a.  G'MIC substitutes occurences of `$*` with the argument list as detected in the [parent scope](https://gmic.eu/tutorial/debug_cheat.html#debuggery). `$*` duplicates the argument list _exactly_ as it appears following `wheelie` itself.
   b.  The other two `$-expressions` furnish additional parsing of the argument list. G'MIC substitutes `$#` with the count of argument list items. These items arise from splitting the argument list on its comma separators, excluding those that might appear in properly escaped string arguments.
   c.  `$=` _<nametemplate>_ is a meta-assignment which G'MIC expands into a sequence of actual assignments, one for each item in the blocked-out argument list, plus command name itself. The variable names consist of the `nametemplate,` here `a`, appended with the position numeral. Thus, for the pipeline `wheelie 2048,0.875,31.75,5` G'MIC expands `$=a` into `a0=wheelie a1=2048 a2=0.875 a3=31.75 a4=5`. This preliminary argument list processing saves some work for us and permits open-ended, variable-length argument lists. For our purposes, we have no use for `$a0`, though other scripts could perform conditional processing based on the command name. `$a1` identifies the length of one side of the drawing field. The remaining arguments, taken three at a time, specify wheelies.
===
~~~
04.    # Expect data triplets: radius, phase angle, angular velocity.
05.
06.    -check "isint($a1) && !(($#-1)%3)"
07.
08.    # Initial argument: side width (sw)
09.
10.    sw={$a1/2}
11.
12.    # Argument image: For each wheelie, compose radius and phase
13.    # arguments into a transformation matrix. In the generator loop, we
14.    # compose this with the angle resulting from one angular velocity
15.    # step.
16.
17.    ccnt={round(($#-1)/3,1,-1)}
18.    -input $ccnt,1,1,12
19.    -name  args
~~~
===
 06.  Here, we subject the argument list to two broad tests. We wish the first argument, `$a1` is to be an integer, as this argument conveys a discrete length of pixels and there is a provision against fractional pixels. We wish the count of remaining arguments, however many that may be, to be divisible by three — because wheelie parameters come in groups of three and _some_ remainder indicates omitted or excess arguments. Here, G'MIC substitutes `$#-1` for the number of items in the argument list, less one, to account for the initial canvas size argument.\n\nWe could check more. In fact, we could check _everything_, right _here_, in an all-inclusive logic string; it is not uncommon to find such in the start-up of custom commands. It may be a matter of style, but a case can be made for distributive checking, to wit: check just what is needed to be checked, and no more, at various parts of the script. Recall that `-check` includes its entire argument string in a thrown exception. Should that argument string encapsulate dozens of tests, then it may not be clear in which part of the script that the failure occurs. Contrast this with a small number of tests originating from a `-check` that concerns itself with just the matters of an immediate locale. Quite likely, that check may be quite a bit more clear on what the difficulty may be, as the `-check` string embodies just a few tests on variables in a certain locality.
 10.  `$sw` — "side width." Half the width, or height of the arabesque image. This is a significant metric to the rest of the script as it establishes working resolution and how to scale the arabesque image.
 17.  We assess `$#-1` once again, this time to determine the number of wheelies defined by the command line: divide `$#-1` by three to get the number of triplets or "circle counts", taking "circle" to be an alias for "wheelie".
= curlybraces

??? More on Math Expressions Within Curly Braces:
      The curly braces around the computation signals the G'MIC command line parser to run the math expression processor on the string. The math expression parser doesn't _exactly_ see this string as written: command line variables like `$#` undergo `$-expression` substitutions before the math expression parser sees the string. Following the substitution, the math expression parser just processes the substituted `$#` _value_, whatever that may be, and not the literal string `$#` — which it never "sees". It is worthwhile to note that _successive_ substitutions take place here. After the command line processor performs the various `$-expression` substitutions, it passes the transformed string to the math expression processor. That processor compiles the string into bytecode, using a "Just-in-time (JIT)" compiler, and then executes that bytecode. Barring a throw of an exception, the math expression parser returns a numeric string reflecting the value produced by the last computation encoded in the math expression — for math expressions can be multi-line, these marked by `;` separators, for multi-stage computation. Examples of such follow in the arabesque plotter, further down in the script.

???
 18.  The twelve channel G'MIC image _args_ is not harnessed to display anything; rather, it is destined for use as an argument table for follow-on math expressions. The layout of one twelve channel pixel consists of the wheelie length, phase angle and angular velocity. The remaining channels contain a nine element transformation matrix that, when composed, carries a point centered at the base of the wheelie to its tip. Finding this matrix is a pre-composition exercise. The long game entails computing matrices that carry points from the image origin to wheelie tips so as to plot tip paths under rotation; the matrix pre-composed here is just the transform from a wheelie's root to its tip.
===
~~~
20.   # Iterate over argument vector. For each triplet – representing a
21.   # wheelie – Fetch radius (rad), phase angle (ang) and angular
22.   # velocity (sf) parameters.
23.
24.   -repeat $#-1,j
25.      -if   $j%3==0 # get radius
26.         rad=${a{2+$j}}
27.         -check isnum($rad)" && "$rad>=0" && "$rad<=1
28.         -set[args] $rad,{round($j/3,1,-1)},0,0,0
29.      -elif $j%3==1 # get angle, degrees
30.         ang=${a{2+$j}}
31.         -check isnum($ang)" && "$ang>=0" && "$ang<=360
32.         -set[args] $ang,{round($j/3,1,-1)},0,0,1
33.      -else         # get ω and set spectral coefficient
34.         sf=${a{2+$j}}
35.         -check isint($sf)" && "abs($sf)<=0.1*$sw
36.         -set[args] $sf,{round($j/3,1,-1)},0,0,2
37.      -fi
38.   -done
39.
40.   # Iterate over argument image, each 12 channel pixel representing
41.   # one wheelie. The first three channels contain wheelie radius,
42.   # phase angle and radial velocity. Compose a matrix
43.   # transforming the origin to the tip of the wheelie, a radial
44.   # translation and phase rotation. Populate the nine remaining
45.   # channels with this matrix.
46.
47.   -fill[args] ">
48.                  CPX=I;
49.                  orot=rot([0,0,1],deg2rad(CPX[1])); # phase rotation
50.                  xlat=eye(3);
51.                  xlat[2]=CPX[0];                    # translation origin-to-rim
52.                  FIN=[CPX[0,3,1],mul(orot,xlat,3)]; # args+"RADX" i.e. 'rotation & radial translation'
53.                  FIN                                # store above in 12-channel pixel
54.               "
~~~
===
= tripletiteration
 24.  The `-repeat…done` loop iterates over the portion of the argument list following the image size specification; an `-if…-elif…-else…-fi` "argument sieve" occupies the body of this iterator and the modular checks of each section route arguments to the appropriate checker for length, phase and angular velocity.
 27.  The wheelie length checker; the first element of each triplet, occupying 3 modulo positions of zero, are to be inhabited by radii of lengths from the closed interval \[0…1]. The math expression composed for this check consists of a type check and two inequality checks that together test for inclusion in the range \[0,…,1].
 31.  The wheelie phase checker; sharing the same form as the length checker, differing only in that the test for inclusion in a range is for \[0,…,360] degrees instead.
 35.  The wheelie angular velocity checker has aims differing from the previous two. The first is an integer numerical type check; the sought for properties being that a candidate is both numeric and non-fractional. The second checker may promote a pause to consider; it is a heuristic test disallowing angular velocities greater than one tenth the the side width. Where does _that_ come from? That comes from the tutorial author staring out of a window for roughly thirty seconds, and then deciding: "That\'s about right." The difficulty being addressed here is that arabesques embodying wheelies with faster angular velocities do not render especially well, a difficulty that lessens with larger images stemming from larger side widths. The fraction '1/10' being magically obtained.
 47.  As noted in `18.` an item on the image list, named `args` is not meant for its representation, but has been hijacked for math expression storage. Three observations. __First:__ while a math expression environment does not survive an exit, one may throw "messages in a bottle" destined for other math expression environments, to be summoned in the future by subsequent pipeline commands and to float like a bottle, in the meantime, within the overarching — and persisting! — pipeline processing environment. __Second:__ The persisting data store is an image in every sense of the word; math expression functions [store() and get()](https://gmic.eu/reference/mathematical_expressions.html#specific_functions), respectively, cache erstwhile math environment vectors as images and retrieve from images math expression vectors. The persisting data store (née images) need not occupy positions on the image list, but may persist off to one side. These off-to-one-side images may be placed explicitly on the image list through the ''-input'' command, which can take an image variable as an argument and locate the contents of this variable somewhere on the image list through its selection decorator. See [input](https://gmic.eu/tutorial/input.html#storedimages) and [store](https://gmic.eu/tutorial/store.html) __Third:__ One may initiate such data storage on either the pipeline processing or math expression side. Here, the storage first appeared on the pipeline side when image `args` was declared at `18.,` in anticipation of its use here, where a `-fill` command invokes a math expression [pixel processor](https://gmic.eu/tutorial/fill.html#pel_streams) to compute and store components of a transformation matrix, taken up in more detail in following line comments.
 49.  The gyrations of the terminal wheelie pen in ["Four wheelies on a lark"](#arabesques) might make the faint-of-heart wonder how all the gyrations of the tip might be captured for purposes of plotting. Divide-and-conquer to the rescue. The aggregate motion of the last wheelie's tip can be thought of as a composite of all wheelies stemming from the tip and linking to the origin. This composite arises from the individual motion of each wheelie. The individual motion of each wheelie is a product of its own motion and that of the wheelie attached to its root; the motion of the first wheelie at the root is the product of an identity element, which behaves like one, and the motion of that first wheelie.

There is a second divide-and-conquer exercise, applied to an individual wheelie. The position of a wheelie is the product of static positioning, the wheelie's phase angle and length,  and discrete, dynamic rotations, these arising from the wheelie's angular velocity over a discrete time step. The `-fill` command in the present step takes a pixel processor that pre-composes the static positioning, this element taking the form of a transformation matrix that encodes the phase rotation and length of the wheelie in one composite. This we store in the upper nine channels of the image, the lower three containing the length, phase angle and angular velocity of the wheelie. Taken together, the pixel processor: (a) copies a twelve channel pixel, representing one wheelie, into a working vector `CPX`; (b) computes a pure rotation matrix encoding the wheelie's phase angle: `orot` (orientation rotation); (c) composes a pure translation matrix The matrices harnessed here are notionally three dimensional transforms, finds application in two dimensions in that it can encode surface translation and rotation into one matrix.
 50.  
= forwardtransform
### The Forward Transform
Let us feed some triplits to roses that we got somewhere:

[3blue1brown](https://www.youtube.com/watch?v=s_L-fp8gDzY) entered the expository fray with [But what is the Fourier Transform? A visual introduction.](https://www.youtube.com/watch?v=spUNpyF58BY) favoring illustrative animations over notational expository. Just a few wheels occasion arabesques, our jumping off point.





# Command reference

===
"""
gmic -h check
"""
===
"""
date -u
"""
