= fromarabesques
# From Arabesques, Wheelies
%% x "mkdir -p img" %% %% -m scripts/wheelie_simple.gmic 1024,1024,1,1 gtutor_wheelie 0.375,343,1,0.375,0,-3,0.25,350,-3 dilate_circ 4 r2dx. 300,5 o img/simple_04.png rm %% %% -m scripts/wheelie_simple.gmic 512,512,1,1 gtutor_wheelie 0.375,343,1,0.375,0,-3,0.25,350,-3 dilate. 8 label 3 1,10,1,3,u([255,255,255]) =>. palette map.. [palette] rm. -gtutor_tileit. 0,0.25,1,1,1,0,8,1 o. img/clover.png rm %%

|- ''Wheelies'' | [Interlude](wheelies.html#interlude) | ''Deep Dive'' | ''From Wheelies, Arabesques''
| ''From Arabesques, Wheelies'' | ''Wheelie Animations''

= simple04
|-![simple_04](img/simple_04.png)\n *12. An Unknown Arabesque* |So much for putting things together. Now let's take things apart.\n\n __Figure 12__ is an arabesque about which we know little. We might suppose that some cardinal sum defines it — but that is a supposition. In truth, all that we have are [plot points](images/unknownarabesque.csv). Still, if we allow ourselves to suppose, then what _might_ be the terms of the allied cardinal sum?\n\nThe [law of exponents](https://en.wikipedia.org/wiki/Exponentiation#Identities_and_properties) provides a clue. From this law, the multiplication of two wheelies results in a new product wheelie rotating at the _sum_ of its antecedents' rotational rates and oriented along those antecedents' combined bearings. The ensuing radius is the product of the antecedents' radii; see [Equation 5](#cemult).

= cemult
===
$$
\begin{matrix}
r_{1}e^{i(2 \pi f_{1} t + \theta_{1})} \times r_{2}e^{i(2 \pi f_{2} t + \theta_{2})} \implies r_{1}r_{2}e^{i(2 \pi (f_{1} + f_{2}) t + (\theta_{1} + \theta_{2}))} & \textsf{E. 5}
\end{matrix}
$$
===

Should the two antecedents have equal rotational rates but different handedness (née signs), they compose a _chiral pair_ and "annihilate" each other in useful ways. Under multiplication, their equal-but-opposite rotational rates cancel; their radii and initial orientations form a time-invariant [phasor](https://en.wikipedia.org/wiki/Phasor). [Figure 13](#wheeliemult) illustrates the case:

= wheeliemult
===
|-![wheeliemult](images/wheelmult.mp4)
| *13. Same rate. Opposite handedness. The wheelies collapse into a non-rotating phasor.*
| *Chiral pairs, wheelies having like rotational rates but of different handedness, say, _f₁_ = 5 Hertz and _f₂_ = –5 Hertz, produce under multiplication time-invariant phasors. Under multiplication, the combined rotation rates of the two wheelies cancel; _t_ vanishes; a "residue" phasor ensues. In this example, the phasor's modulus is one, the product of two unit length radii,  and its angular argument is 60°, the sum of the two antecedents' orientations, 23° and 37°.*
===

This vanishing act provides the pith for an "analytical engine", one that picks out the terms of a cardinal sum. Here's the key: the product of two wheelies allows but two outcomes:
| 1.  |__Outcome One – Terms Not a Chiral Pair:__ The product wheelie has the same average position as its antecedents. This is so because the product wheelie rotates at _some_ non-zero rate, even if it is vanishingly small — as small as we dare imagine and smaller! The product wheelies still trace circles over the infinite run: _t ∈ (–∞ … ∞)_ and even if the trace takes millennia to complete, it scribes a circle when complete and that figure's average position lies on the origin, as with its antecedents.
| 2.  |__Outcome Two – Terms Are a Chiral Pair:__ The product is a time-invariant — not rotating! — phasor. For any period _t_, the phasor is "stuck" — its offset displaces the resultant arabesque from the centers of gravity of its antecedents, raising the flag of wheelie anihilation.

We may not know _anything_ about how [Figure 12](#simple04) comes about — but we don't care. We care only about some collection of wheelies that _emulates_ Figure 12. Such a collection serves as a _model_ for the arabesque, and the "analytical engine's" job is to produce that model: a collection of wheelies that form a cardinal sum which we can "suppose" defines the arabesque. For all practical purposes it does — so long as the margin of error between the model we have derived and the plots we have been given is sufficiently small.

So let us suppose, by fiat, that the arabesque's plot points are an outcome of some supposed cardinal sum, one that we aim to model. We begin by multiplying these plot points by trial unit wheelies: _r = 1, θ = 0°_ across a range of rotational rates _f_. We would expect, with each trial, occurrences of either Outcome One or Outcome Two, as if we were making trial multiplications with the supposed cardinal sum itself. That is, the product arabesque arising with each trial:

| 1.  |has the same center of gravity as the antecedent arabesque: Outcome One prevails; the trial unit wheelie does not form a chrial pair with any terms of the supposed cardinal sum.
| 2.  |has an offset center of gravity from the given arabesque. Outcome Two prevails; the trial unit wheelie forms a chiral pair with a term of the supposed cardinal sum.

In the second outcome, the center of gravity offset stems from a residue phasor of "anihilated" chiral pairs. In that case, the rotation rate of the trial unit wheelie is the same as that of a term of the supposed cardinal sum, but of opposite hand. We can suppose that there is only _one_ such term allied with Outcome Two, for if there are others, such could be combined into a single aggregate, all having a common rotation rate.

With Outcome Two, we establish exactly one term of an approximating cardinal sum:
| 1.  |The rate of rotation of the identified term, _f_, is that of the trial wheelie, but of opposite hand.
| 2.  |The orientation of the identified term, _θ_, is the sum of orientations of the identified term and the trial wheelie. Since the trial wheelie has an orientation of zero degrees, the sum of orientations _θ_ is wholly that of the identified term. Its measure is the orientation of the residue phasor.
| 3.  |Similarly, the radial length of the identified term, _r_, is the product of radii of the trial unit wheelie and the identified term. Since the trial unit wheelie has a radius of one, the radial product equals the length of the identified term. The phasor's length, then, is _r_.

And so it goes. We pick off supposed cardinal sum terms by multiplying data sets with trial wheelies drawn from a sufficiently wide frequency band, one somewhat narrower than _f_ ∈ (–∞ … ∞) — which would take awhile to evaluate. Here are the particulars:

= fourieralgol
### The "Analytical Engine"
|__1.__|Choose a [Nyquist Sampling Rate](https://en.wikipedia.org/wiki/Nyquist_rate), _N_, "sufficiently large" to anticipate the fastest expected rotational rate _f_ — an educated guess to prevent the engine from running forever.
|__2.__|Introduce a container of _2N_ complex numbers, _S_ (for "spectrum"), initialized to zero.
|__3.__|Regard the arabesque under analysis, _A_, be the _multiplicand data set_ for a series of trial multiplications with successive unit wheelie _multipliers_, _exp(–i2πft)_ for _f_ ∈ ( _–N,…, N_ ).
|__4.__|For _A_ and for each integer rotational rate _f_:
|__5.__|Evaluate the product _A × exp(–i2πft) ⇒ A'_.
|      |We evaluate the unit wheelie, _exp(–i2πft)_ over _t_ ∈ `[0 … 1]` for as many samples as those comprising _A_. This provides the _multiplier data set_. The pairwise multiplication of the two data sets, multiplicand and multiplier, carries out _A × exp(–i2πft) ⇒ A'_.
|__5a.__|Take the difference of the average position of _A_ and _A'_  ⇒ _S[f]_.
|__5b.__|Case 1. _A'_ has a center of gravity unchanged from the multiplicand, _A_. _S[f]_ = 0i.
|__5b.__|Case 2. _A'_ has a center of gravity differing from the multiplicand, _A_. _S[f]_ ≠ 0i.
|__6.__|If _f_ < _N_, go to __4.__, otherwise go to __7.__
|__7.__|The collection _S_ contains a _frequency domain spectrum_, coefficients approximating the terms of a cardinal sum that we suppose defines arabesque _A_.

= fdomain
===
|-![fdomain](images/spectralspace.svg)
| *14. The frequency domain spectrum has a circular topology. Pixel coordinates correspond to rotational rates — _frequencies_, and clockwise or counterclockwise handedness. Negative and positive coefficients populate pixels to the left (negative, clockwise) and right (positive, counterclockwise) of ω₀ and meet at the Nyquist Sampling Rate frequency, _ωn_. A pixel's complex value at a particular image coordinate encapsulates one term of a cardinal sum. The value itself captures the orientation, _θ_, in the argument of the complex number, and its magnitude, _r_, in the modulus. *

===
So long as the Nyquist Sampling Rate is sufficiently large, the collection _S_ holds the terms of a cardinal sum that approximates _A_. Should _N_ be too small, then the higher frequency terms of the cardinal sum are missing, the results effectively a low-bandpass version of _A_. The solution to that calamity is simple: just pick a higher Nyquist Sampling Rate and re-run the procedure.

Here is the "analytical engine" in operation:

= fmachine
===
|-![sampletester](images/time2freq.mp4)
| *15. Annihilated Wheelies Kick the Center of Gravity*
===
|__Phase Diagram__| Presents successive _A × exp(–i2πft) ⇒ A'_ as _f_ ranges from –12 to 12 Hertz.\n\n The evaluation of _A × exp(–i2πft) ⇒ A'_ pairwise multiplies the unit vectors comprising _exp(–i2πft)_ with their counterparty _A_ plots. This effects angular additions that circular-shift plots of _A'_ from their counterparts _A_ to an amount commensurate with _t_. The effect is to first wind _A'_ counterclockwise around the origin, then clockwise. Observe that the plot associated with _t=0_ does not move.\n\nThis notwithstanding, at a frequency of annihilation, chiral pairs vanish and "residue" complex numbers, an exemplar illustrated in [Figure 13](#wheeliemult), offsets the average position of _A'_ with respect to _A_, as indicated by the red dot. The offset is to a point on the complex plane equal to a partial of arabesque _A_. This offsetting of the product arabesque from the origin signals a chiral pair annihilation and the concomitant detection of a cardinal sum term.\n\nIdeally, the detection of such a term should occur at _precisely_ one frequency. Instead, the red dot motion appears to have a "fuzz factor" in that it moves continuously around a solution, which is at some sort of maximum offset from the origin.\n\nThis small calamity arises because it is not practical to evaluate _f ∈ (–∞ … ∞)_. With the evaluation of necessarily finite frequency ranges, there will be vanishingly small frequencies arising from trials very close to the rotational rates of chiral pairs; these will have periods substantially longer than the one revolution duration of the product arabesque's drawing, and that gives rise to non-zero plot averages. These engender _faux_ solutions that skew _A'_ from the origin just as a true solution would, and their aggregate behavior gives rise to spectral domain notches centered on chiral pairs and admits a "red dot flutter", setting a definite resolution limit on discerning chiral pairs at very nearly identical frequencies. There is little to be done about this resolution limit. _C'est la vie_.
|__Time Domain__|Draws the real and imaginary components of _A'_ in the time domain as _f_ ranges from –12 to 12 Hertz. The dotted vertical lines demark periods, each of duration _1/f_, and indicates the number of times _A'_ wraps around the origin. Notice that the stretching is very small on the left hand side, but large on the right, reflecting "radial stretching".
|__Frequency Domain__|Tracks how _S_ fills with coefficients. The tracking does not portray these as complex numbers; the frequency domain window displays their modulii but not their angular arguments. Limited as this may be, non-zero coefficients pop up at abscissae _f_ ∈ {-5, -2, 1} Hertz. These are the frequency domain coordinates for the coefficients of the supposed cardinal sum that plots [Figure 12](#simple04).

Here is a table of farthest extents from the origin of centers of gravity during the "analytical engine's" run:
===
|– __Rectangular C.O.G.__ | __Radial C.O.G.__ | __Hertz__
|  0.358614 –0.109639j|0.375 ∠ –17°| 1
|  0.358614 –0.109639j|0.375 ∠ –17°|–2
|  0.222752 –0.113498j|0.250 ∠ –27°|–5
===
The radial centers of gravity may be directly transcribed to a cardinal sum:

===
$$
\begin{matrix}
\psi (t) = 0.375 e^{i(2\pi 1 t + \mathtt{radians}(–17^{\circ}))} + 0.375 e^{i(–2\pi 2 t + \mathtt{radians}(–17^{\circ}))} + 0.25 e^{i(–2\pi 5 t + \mathtt{radians}(–27^{\circ}))} & \textsf{E. 6}
\end{matrix}
$$
===
To confirm that this cardinal sum does indeed plot the arabesque in [Figure 12](#simple04), we can modify `cexpsum` of [Threewheelie Redrawn](from_wheelies_arabesques.html#threewheelieredrawn) fame, substituting at line 9 the cardinal sum given by Equation 6:

~~~
 1 cexpsum:
 2   size=255
 3   # complex parameter ramp plotted on the
 4   # imaginary axis.
 5   -input 360,1,1,2,'[0,2*pi*x/(w-1)]'
 6   -name. tau
 7 
 8   # evaluate a wheelie-sum
 9   -fill[tau] "0.375*cexp(I-[0,17°])+
10               0.375*cexp(-(2*I+[0,17°]))+
11               0.250*cexp(-(5*I+[0,27°]))"
12  
13   # transform arabesque plots to a canvas
14   # drawing surface.
15   -fill[tau] "begin(
16                      sw=get('size');
17                      id=eye(3);
18                      id[0]=sw;
19                      id[2]=sw;
20                      id[4]=-sw;
21                      id[5]=sw
22                    );
23               (id*[I(x,y),1])[0,2]
24              "
25    # paint the arabesque plot points on a
26    # canvas: white on black.
27   -permute[tau] cyzx
28   -input {2*$size},{2*$size},1,1
29   -name. canvas
30   -eval "PV=crop(#$tau);
31          polygon(#$canvas,
32                  -int(size(PV)/2),
33                  PV,
34                  1,
35                  0xffffffff,
36                  255
37                 )"
38   -output[canvas] unknownarabseque.png
~~~

`unknownarabesque.png,` you will find, reproduces [Figure 12](#simple04) in glorious, bi-valued black-and-white.

Or, if we want to create a chain of delta wheelies that also draws the arabesque, we may pair-wise difference the terms of Equation 6, say, in just the order of terms presented in that equation:

===
|-_ Term _|_ +r, ±θ _|_ ±f _|_ Δθ, Δf _
|  1.  |0.375 ∠ –17° (343°) |  1 Hertz| _Root_
|  2.  |0.375 ∠   0°           | –3 Hertz|_Δθ=–17°–(–17°)_, _Δf=–2–1_ 
|  3.  |0.250 ∠ –10° (350°) | –3 Hertz|_Δθ=–27°–(–17°)_, _Δf=–5–(–2)_ 
===

and then give it a whirl:

= clover
~~~
randomclover:
   -command scripts/wheelie_simple.gmic
   -input 512,512,1,1                                        
   -name. canvas                                             
   -gtutor_wheelie[canvas] 0.375,-17,1,0.375,0,-3,0.25,-10,-3
   -name. wheelie
   
   # White on black arabesque
   -output[wheelie] plain.png

   # Tiled and randomly colored arabesque
   -dilate[wheelie] 8                                        
   -label[wheelie] 3                                         
   -input 1,10,1,3,'u([255,255,255])'                        
   -name. palette                                            
   -map[wheelie] [palette]                                   
   -remove[palette]                                          
   -gtutor_tileit[wheelie] 0,0.25,1,1,1,0,8,1                
   -name. tiled
   -output[tiled] clover_figure-14.png
~~~

===
|-![randomclover](img/clover.png)
| *16 Arabesque Dressed in [Tiles](https://gmic.eu/tutorial/tiled_art.html)*
===

No doubt, there are some of you out there — in moods admonitory — who would chastise us for our frivolity.

Aye. We could have applied the tilings and baubles and glitz direct to [Figure 12](#simple04), already in hand, instead of fetching one anew by some bonzer [Rube Goldberg apparatus](https://www.youtube.com/watch?v=VpLDfkLBJ0Q) — just the sort of superfluity that one might expect from a New York City civil servant.

But — _Phht!_ — does not any poetic sense — any sense of splendor — grace your jaded souls? Have you _no_ inclinations to set off for nameless vales, cross hither into some hidden hollow, nestled darkly by an uncharted stream, and delight in countless unscored trills of bird song?

There are things tenanting caves deep in yonder hills that fit no recorded taxonomy, and yet — here in the mysteries there are guises that strike some as familiar. This analytic engine, for instance, is not of our authorship. It first turned its trick in 1822, with [Jean-Baptiste Joseph Fourier's](https://en.wikipedia.org/wiki/Joseph_Fourier) _Théorie analytique de la chaleur_ ( "The Analytical Theory of Heat" ). It is the well known — celebrated, even — [Discrete Time Fourier Transform](https://en.wikipedia.org/wiki/Discrete-time_Fourier_transform). The collection _S_, its product (whimsically) comprised of annihilated chiral remnants, is more properly a [Fourier series](https://en.wikipedia.org/wiki/Fourier_series) representation of arabesque _A_:

= fseries

===
$$
\begin{matrix}
S_N(t) = \displaystyle\sum_{f = –N}^{N} c_{f} \cdot e^{i(2\pi f t + \psi_{f})} & t \in [0,\dots ,1] & \textsf{E. 7}
\end{matrix}
$$
===

[Equation 7](#fseries) _almost_ looks like a cardinal sum. The terms' coefficients are complex, not scalar radii. But a notational rearragement can span that gap:

===
$$
{\small
\begin{array}{ l l l p{8cm}}
  \text{1.} & c & \implies  & Recall that complex numbers, \emph{c}, have real and imaginary parts.   \\
  \hline
  \text{2.} & a + ib & \implies & Let \emph{a} represent the real component and \emph{ib} the imaginary component. \\
  \hline
  \text{3.} & \sqrt{a^2 + b^2} \angle \arctan{ \frac{b}{a} } & \implies & Rewrite the complex number in polar form, one with a radial modulus and angular argument. \\
  \hline
  \text{4.} & \sqrt{a^2 + b^2} \cdot e^{i( \arctan{ \frac{b}{a}} )} & \therefore & Polar forms directly translate to phasors. This step depicts \emph{c} as an exponential expression that is constant in \emph{t}. \\
  \hline
  \text{5.} & \sqrt{a^2 + b^2} \cdot e^{i( \arctan{ \frac{b}{a}} )} \cdot e^{i(2 \pi f t + \psi )} & = & The summation's rewritten template is a product of two exponential expressions: \emph{c} rewritten and a wheelie. \\
  \hline
  \text{6.} & r \cdot e^{i(2 \pi f t + \psi + \arctan{ \frac{b}{a}})} & \because & Carrying through the multiplication gives rise to terms of a cardinal sum akin to Equation 6. \\
  \hline
   \text{7.} & \sqrt{a^2 + b^2} = \| c \| = r &  & The emergence of \emph{r} may surprise. It's equivalent to the radical expression in \emph{a} and \emph{b}, also the absolute value of \emph{c} and the radius of the wheelie. \\
  \hline
   \text{8.} & r \cdot e^{i(2 \pi f t + \theta)} & \theta = \psi + \arctan{ \frac{b}{a}}  & No loss of generality occurs by combining the time-independent angles. \\
  \hline
\end{array}
}
$$
===

With this rewritten template, we arrive at the "cardinal sum" representation of [Equation 7](#fseries). 

===
$$
S_N(t) = \displaystyle\sum_{f = –N}^{N} r_{f} \cdot e^{i(2 \pi f t + \theta_{f} )}
$$
===

On the whole, G'MIC embodies ''From Arabesques, Wheelies'' in its ''-fft'' command. The [Analytical Engine's](#fourieralgol) reduction of arabesques to elemental wheelies parallels that of a Fourier Series reduction of periodic signals to so many sinusoids. `-fft` is the "analyzer" that fractionates the whole into parts. Given the arabesque, it lays bare the constituent wheelies.

Conversely, ''-ifft'' encompasses ''From Wheelies, Arabesques''. It regards a collection of wheelies as so many "spectral basis functions" from which we synthesize spatial signals. Indeed, `-ifft` is the "synthesizer" that composes collections _S_, complex _r ∠ θ_ in a frequency domain spectrum, into analogous time series.

Armed with these spectral/spatial analytical and synthesizing functions, let's rewrite [gtutor_wheelie](wheelielist) with the following aims:
| 1.  |Make a spectral implementation based on the complementary operations ''-fft'' and ''-ifft.'' Arabesques are spatial analogs of a spectral sampling.
| 2.  |Separate concerns: split the implementation into interpretive and rendering commands. Make a wrapper to emulate the original `gtutor_wheelie.`
| 3.  |Optimize our use of `polygon();` give it all plot points in one swell foop.

Such ambitions gives rise to a revised `wheelie_simple.gmic`, called `spectralarabesque.gmic`:

( [Download spectralarabesque.gmic](scripts/spectralarabesque.gmic) ):

??? spectralarabesque.gmic
~~~
  1 #@cli gtutor_fwheelie : radius₀,orientation₀,angular_velocity₀…
  2 #@cli: Compose an arabesque from a chain of delta wheelies, a
  3 #@cli: series of triplets, each consisting of a radial
  4 #@cli: (+float), orientation (±degrees, float) and rotational
  5 #@cli: rate (±integer) data. Draw the corresponding arabesque
  6 #@cli: on the selected images.
  7 #@cli: $
  8 gtutor_fwheelie : -check "!(($#)%3)"
  9 
 10    -foreach {
 11       specw={int(min(w,h)/2)}
 12       -gtutor_mkspectral $specw,$*
 13       -gtutor_specplot[0] [-1]
 14       -remove[-1] 
 15    }
 16 
 17 #@cli gtutor_mkspectral : spec_w,rad₀,orient₀,ang_velocity₀…
 18 #@cli: Generate a two channel discrete frequency domain image
 19 #@cli: corresponding to the supplied delta wheelie parameters:
 20 #@cli: +r, ±θ and ±f on the command line, one triplet for each
 21 #@cli: delta wheelie. Image suitable as a gtutor_specplot
 22 #@cli: selection, which draws the arabesque.
 23 #@cli: $
 24 gtutor_mkspectral: -check "isint(${1}) && ${1}>0 && !(($#-1)%3)"
 25 
 26    # Expect spectral width followed by data triplets $a1,$a2,$a3…
 27    dwheelcnt={($#-1)/3}
 28    specw=$1
 29    -input 3,1,1,$dwheelcnt,${2--1}
 30    -name[-1] args
 31    -store[args] deltawheelies
 32 
 33    #coeffcient image: 'carray'
 34    -input $specw,1,1,2
 35    -name[-1] carray
 36    -store[carray] coefficientarray
 37 
 38    # Find canonical sum by aggregating delta wheelies.
 39    # Insert terms into spectral image using rotation
 40    # rate as spectral coordinates.
 41    # Σf -> $accsf; Σθ → $acca
 42    -eval "const wc=$dwheelcnt;
 43           const sw=$specw;
 44           dw=get('deltawheelies',wc*3);
 45           ca=get('coefficientarray',sw*2);
 46           acca=0;
 47           accsf=0;
 48           repeat(wc,k,
 49                  r=dw[3*k];
 50                  acca+=deg2rad(dw[3*k+1]);
 51                  accsf+=dw[3*k+2];
 52                  aidx=accsf%sw;
 53                  ca[aidx]+=r*cos(acca);
 54                  ca[sw+aidx]+=r*sin(acca);
 55                 );
 56           store('coefficientarray',ca,sw,1,1,2)"
 57 
 58    # carray: frequency domain image generated
 59    # from the given delta wheelie chain.
 60    -input $coefficientarray
 61    -name. carray
 62    
 63    # Scale freq. domain by domain length.
 64    -mul[carray] $specw
 65 
 66 #@cli gtutor_specplot : [spectrum]
 67 #@cli: Generate an arabesque on selected images from
 68 #@cli: the given argument: a frequency domain spectrum image.
 69 #@cli: $
 70 gtutor_specplot : -is_image_arg $1 gotimg=${} -check "$#==1 && $gotimg"
 71     
 72    -pass$1 0 
 73    -name[-1] carray
 74    # Frequency domain → time domain
 75    -split[-1] c
 76    -ifft[-2,-1]
 77    -append[-2,-1] c
 78    -name. temporal
 79    -foreach[^temporal] {
 80       -pass[temporal] 0
 81       sw={min(w#-2,h#-2)}
 82 
 83       # Screenspace transform.
 84       -fill[temporal] ">
 85                          begin(
 86                                 specw=$sw/2;
 87                                 id=eye(3);
 88                                 id[0]=specw;
 89                                 id[2]=specw;
 90                                 id[4]=-specw;
 91                                 id[5]=specw;
 92                               );
 93                          (id*[I(x,y),1])[0,2];
 94                        "
 95       -permute[temporal] cyzx
 96       -eval "PV=crop(#$temporal);
 97              polygon(#-2,
 98                       -int(size(PV)/2),
 99                       PV,
100                       1,
101                       0xffffffff,
102                       255
103                     )
104               "
105       -keep[-2]
106    } #foreach[^temporal]
107    -remove[temporal]
~~~
???

= spectralannotations
### Spectral Annotations

??? Weeds, for those close to the ground.

|  |With a separation of concerns, `gtutor_fwheelie` reduces to a command that does little on its own; it is a wrapper that calls others to do what the old `gtutor_wheelie` did monolithically. Kudos to monolithia, perhaps, it's the one thing to do it all.\n\nBut then, there's this: The old `gtutor_wheelie` renders a four delta wheelie chain on a 4096 × 4096 pixel image in about 2.3 ~ 2.5 seconds, its spectrally enhanced successor, `gtutor_fwheelie`, does the same throw in just 0.7 ~ 0.8 seconds — both times on a Xeon E5-2630, running at 2.2 GHz.\n\nSo, performance has improved — we like performance! — but there's a Separation of Concerns benefit in the offing too.\n\nThe monolithic `gtutor_wheelie` couldn't be picked apart. That sealed two useful functions within: **(1)** _Determining the cardinal sum from delta wheelies,_ and **(2)** _Rendering a cardinal sum's affiliated arabesque._ \n\nWith a dash or two of Separation of Concerns, these two functions emerge as distinct G'MIC commands. Now, with `gtutor_mkspectral` we can produce the spectral image itself without it being automagically turned into an arabesque — perhaps we have some further frequency domain manipulations in mind. And, with `gtutor_specplot`, we may obtain spectral images from other sources — not just wheelie chains — and render those as arabesques.
|  __Line__  |  __Remark__  
|  **8-15** | __Wrapper:__ `gtutor_fwheelie` is a wrapper around `gtutor_mkspectral`, which finds the cardinal sum affiliated with a given chain of delta wheelies, and `gtutor_specplot`, which, given a spectral image argument, renders the affiliated arabesque. The remit charged to just `gtutor_fwheelie` is small: iterate over the selected images, if any, and for each, (a) determine its "spectral width," (b) generate a cardinal sum via `gtutor_mkspectral` and (c) render it via `gtutor_specplot`.\n\nThe "cardinal sum" which `gtutor_mkspectral` generates takes the form of a frequency domain spectral image, a _1 × 2N_, two-channel (real and imaginary), depiction of the discrete (integral) frequecy domain; see [Figure 14](from_arabesques_wheelies.html#fdomain).\n\nNote how `gtutor_mkspectral's` arguments have been formed. Command line variables naturally concatenate: `$specw`, `,` and `$*` together form one string, a comma-separated argument list. The latter, `$*`, is an [ $-expression ](https://gmic.eu/reference/adding_custom_commands.html#top) for the argument list in the current scope. Essentially, `gtutor_fwheelie` is passing the arguments it has been given (these in `$*`) to `gtutor_mkspectral`, which will actually make use of them. This is in conjuction with the "spectral width" variable `$specw`, which `gtutor_fwheelie` assays from the current image. Once `gtutor_specplot` draws the arabesque, `gtutor_fwheelie` discards the cardinal sum, leaving only the image of the affiliated arabesque on the image list.
|  **24-65** | __Cardinal Sum Tool:__ `gtutor_mkspectral` interprets the second and subsequent items of its argument list as delta wheelie triplets (_+r, ±θ, ±2πf_) and computes the terms of its affiliated cardinal sum, leaving this in the form of a spectral image on the image list. The command `gtutor_mkspectral` follows the algorithm accompanying [Figure 9](from_wheelies_arabesques.html#wheeliechainmap). It sizes the length of the spectral image per `$specw`, aka the `spectral width`, in pixels. See **64-68** __The Spectral Image:__ for more on this sizing operation.
|  **29-30** | __Fast Database:__ Compare lines **29-30** here, with the `gtutor_wheelie` [functional counterpart](wheelies_i.html#wheelielist). The aim in both places is to create a "delta wheelie database" from a command line sequence of arguments. The approach taken with `gtutor_wheelie` entails walking down the pixels of a "wheelie database image", one pixel for each delta wheelie. For a particular pixel, aka a "delta wheelie", the approach takes a block of three successive command line arguments, these _r_, _θ_, and _2πf_ delta wheelie constituents, and explicitly ''-set''-ing the pixel channels with these: _r_ ⇒ channel R, _θ_ ⇒ channel G and _2πf_ ⇒ channel B.\n\nIt is, on the whole, a thirteen line exercise in pixel twiddling, but it does a yeoman job of transferring command line items to the "wheelie database." We won't be getting any Turing Awards with this but we got what we wanted.\n\nThat said, line **29** performs the same set-up in just one line. We just flow pixels into the image in one atomic action. Recall that ''-input'' operates with character streams as well as image files; the argument list `${2--1}` is such an [character stream](https://gmic.eu/tutorial/input#prescribed). With this technique, G'MIC maps images to linear memory in [row-major order](https://en.wikipedia.org/wiki/Row-_and_column-major_order); it is such that a fill of contiguous memory bytes runs first along the image's _x_ axis and, only as rows fills, along the _y_. Further, an image's first _x × y_ plane, channel 0 ( _`R`_ ), fills before channel 1 ( _`G`_ ). Finally all channels of an image's first slice, _x × y × c_, fills before the second slice.\n\nSo, in this setting, we regard the argument list `${2--1}` as an "character stream," which incorporates the argument list into the wheelie database in one fell swoop. No pixel twiddling needed.
|  **31-36** | __Passing Data to Math Expressions:__ The heart of `gtutor_mkspectral` is an implementation of the [cardinal sum algorithm](from_wheelies_arabesques.html#cardsumalgol), a G'MIC math expression given as an argument to ''-eval'' and spanning lines **42-56**. The procedure takes a chain of delta wheelies that we have composed into a "delta wheelie database," ordered from the chain's root to the tip. To make this data available to the math expression, we place it in a named command line variable, `deltawheelies` via the ''-store'' command, **44**. Similarly, we create a `coefficientarray` [spectral image](from_arabesques_wheelies.html#fdomain), **45**, that the same math expression populates with spectral image data. These exemplify exchanging data sets with one or more G'MIC math expressions.
|  **38-58** | __Delta Wheelies to Cardinal Sums__: The plain language procedure to find the cardinal sum from an affiliated chain of delta wheelies accompanies [Figure 9](from_wheelies_arabesques.html#cardsumalgol) in ''From Wheelies, Arabesques''. It is realized here in this math expression argument of an ''-eval'' command: accumulators Σf → `$accsf`; Σθ → `$acca` keep running totals of rotation rates and orientations. With each step of the walk along the chain, the running totals absorb another delta wheelie; the new accumulations provide another term of the cardinal sum. As these terms of the cardinal sum are bought forth they are plotted in the coefficient array. the accumulated rotation rate, modulo the spectral width, furnishes an index into the coefficient array. Note that the coefficient array, `ca`, lays the channels of the spectral image end-to-end, akin to a channel ''-split'', such that the trigonometric `cosine` and `sine` components are offset in `ca` by the spectral width stride, `sw`. With the iteration over the given delta wheelies complete, `ca` becomes suitable input to ''-ifft,'' once converted from a math expression vector and back into an image. Such takes place through ''-store'', see **56,**  and ''-input'', see **60**.
|  **60-64** | __The Spectral Image:__ `gtutor_mkspectral` completes its construction of the spectral image by retrieving it from `$coefficientarray` and scaling it by the given spectral width.\n\nWhat is "spectral_width"? And why scale by it?\n\n `gtutor_mkspectral` emulates the behavior of of ''-fft'' operating on a one dimensional set of spatially ordered plot samples. The number of samples — here, the "spectral width" — constitutes an abstract distance, the period length of the sample set on an infinitely long spatial axis. When it generates the spectral image, `-fft` scales the data in this sample set by the spectral width, encoding it in the set.\n\nBut in carrying out this `-fft` emulation, `gtutor_mkspectral` has no idea what the spectral width is, so it must be told. The first argument given to `gtutor_mkspectral` is such a fiat declaration of spectral width. Strictly speaking, such a declaration is divorced from any particular reality; it becomes a convenient scaling factor, which can be harnessed in the interest of Art.
|  **66-107** | __Spectral Plotting:__ In the revised scheme of `gtutor_wheelie` → `gtutor_fwheelie`, the spectral image plotter, `gtutor_specplot` changes in two ways: (a) it acquires a command line interface, and (b) it plots an entire arabesque data set of plot points in one throw; gone is the tedium of maintaining a _Δt_ "plotting window," through which single line segments are fed to `polygon()` a pair-of-points at a time.\n\nThe basis of this efficiency is the spectral → spatial transform performed by ''-ifft'' which serves up the entire arabesque plotting data set in one transform. This is the pay-off from (a) first taking a [Deep Dive](deep_dive.html), (b) establishing the relationship between [delta wheelies and cardinal sums](from_wheelies_arabesques.html#phasesum), and (c) uncovering the [essential relationship](from_arabesques_wheelies.html#fourieralgol) between arabesques and cardinal sums: they are two sides of the discrete Fourier transform, and ''-fft'' and ''-ifft'' transforms our data to and from these spectral and spatial realms.
|  **72-80** | __Passing Images Through Scopes:__ `gtutor_specplot` takes an image argument and draws arabesques on its selection set, however many images there may be in that set. It takes the spectral image as an _image argument_; ''-pass'' facilitates the reading of image arguments from the command line. In the wild, `-pass` is almost always concatenated with a command line argument, here `$1`. which _should_ resolve to an <open-square-bracket><image selection><close-square-bracket> string. The command ''-is_image_arg'' checks that the argument accommodates that form. As G'MIC transforms its raw command line item list into a meaningful set of commands, and then enters the processing scope of that command, notation like `pass$1` transforms to something like `pass[1]`. A built-in command, `-pass` then copies the selected images in the _called context_ to the current, `gtutor_specplot`, context, incorporating the now-passed-images into the current scope's image list. This passing of images is necessary because, on the whole, the context of called G'MIC commands are more-or-less isolated from calling contexts. And while context passage commonly takes place with command invocation, it can also happen with loop iteration commands like ''-foreach'', which maintains its own, private image list, and which defaults to holding only the current image in the iteration for processing. A second use of the ''-pass'' command appears at **84** to copy the `temporal` image into the private `foreach` image list.
|  **72-80** | __Spectral to Spatial:__ With the spectral image in hand, it becomes a temporal data set via ''-ifft''; see **80.** That is, the discrete Inverse Fourier transform brings the spectral image, populated with cardinal sum coefficients, into a time series — positions varying as functions of time. When plotted on an _x × y_ plane, this time series looks like the arabesque. There remains mundane matters of scaling the series to the particular dimensions of selected images, each of which will have the same arabesque plotted on it, and scaled to the image at hand. We generate the temporal data set but once, and, within the ''-foreach'' loop, rescale as needed.
|  **83-112** | __`foreach`: Drawing the Arabesque:__ Drawing the arabesque borrows from the approach first advanced in [rendering a cardinal sum](from_wheelies_arabesques.html#threewheelieredrawn). The `foreach{…}` iteration is an arabesque stamping machine. For however many images there are in the `gtutor_specplot` selection, this iterator sizes and stamps the arabesque on each member image in the selection. To achieve that, the iterator derives an affine transform matrix to project the arabesque onto the image, scaling it to fit in a square sized to the smallest dimension of the image, the minimum of either the image's width or height. See **85**.\n\nWith each iteration, the ''-pass'' command furnishes a local copy of the arabesque plot points, these held in the image named "temporal." A math expression embodied in a ''-fill'' command iterates over the plot points and scales each by the affine transform. Within the math expression, a `begin(…)` statement sets up that affine transform: `id`; **89-96**. Recall that `begin(…)` statement blocks establish a set of commands that run once prior to the ''-fill'' command's iteration loop.\n\nThe remaining step, performed outside the `begin(…)` block, replaces each pixel with a transformed plot point, this through a pair of Pixel Accessors. See the [Pixel Accessors](wheelies_i.html#annotations) article. The inner accessor retrieves the untransformed plot point. Once retrieved, the _x_ and _y_ plot points are recomposed into a homogeneous form with a third "pseudo" _z = 1_, coordinate so that it may be operated on by affine transforms. We scale and translate this homogeneous plot point by the affine transform `id`. Finally, we apply an "outer" accessor to the transformed three-vector homogeneous plot point, this for retrieving just the first two transformed coordinates, _x'_ and _y'_; **97**. The outcome of the second pixel accessor is the transformed two-vector plot point. Since this two-vector constitutes the last statement in the math expression, an implicit vector → pixel conversion and assignment takes place; the transformed coordinates now occupy what had been, heretofore, the original plot point.\n\n**99**: We permute the plot points to align _x'_ and _y'_ along the spectral (channel) axis, a reorganization prompted by `polygon()`.\n\n**99-109** We graph all arabesque plot points in one `polygon()` call. These plot points reside in image `temporal`; the math expression function `crop()` introduces images into math expression environments, producing a vector from pixel data. Without dimensional arguments, `crop(…)` converts the entire image into a vector and assigns it to the left hand side element. Here, `PV` receives the vectorized plot points from `crop(…)`. In turn, `polygon(…)` projects these onto the drawing image,  the second from the end of the image list (`#-2`). The second argument represents a count of line segments: `-int(size(PV)/2)`. The negative sign has been overloaded for this argument: signalling here: "plot the shape outline"; its absence signals "fill the shape". The third argument specifies the source of plotting data; the fourth parameter, `1` sets the opacity of the plotted image, here, fully opaque, zero signalling full transparency and fractional values _k ∈ (0…1)_ some degree of partial transparency. A 32 bit hexadecimal, the fifth argument, specifies whether thirty two plot point sequences, starting at the beginning of the plotting pattern, are to be turned on or off, this for emulating line dot-and-dash patterns. Finally, the sixth and last parameter is a color vector; its length must match the channel depth of the image serving as a canvas. 

???

===
|-Previous:| ''From Wheelies, Arabesques'' | Next:| ''Wheelie Animations''
===
