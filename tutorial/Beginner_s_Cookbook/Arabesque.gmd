# Arabesques
%% x "mkdir -p img" %% %% -m scripts/wheelie_anim.gmic input 1024,1024,1,3,lerp([219,214,233],[219,187,91],y/(h-1)) durga. 1,90,1,0.125,0,7,0.5,0,-3,0.5,0,5 [-1]x60 erode_circ 3 -resize 29.3%,29.3%,1,3,5 o img/arabesque.mp4,24,H264 rm %% %% -m scripts/wheelie_simple.gmic wheelie 300,0.375,90,1,0.375,0,2 o. img/simple_01.png rm %% %% -m scripts/wheelie_simple.gmic wheelie 1024,0.375,90,1,0.3125,0,2,0.25,0,5 dilate_circ 4 r2dx. 300,5 o img/simple_02.png rm %% %% -m scripts/wheelie_simple.gmic wheelie 1024,0.375,90,1,0.3125,0,2,0.25,0,5,0.0625,57,-6,0.03125,85,-11 dilate_circ 4 label. -apply_curve. 1,0,255,127,0,255,255 map. aurora r2dx. 300,5 o img/simple_03.png rm %% %% -m scripts/wheelie_anim.gmic i 600,600,1,3,lerp([220,220,233,255],[180,180,200,255],y/(h-1)) nm. background -i[-2] (0.92^0.92^0.92^0.995) nm.. multiplier -i[-3] [background],[background],[background],4 -nm... arabesque wheelie_anim[arabesque,multiplier,background] 120,1.125,{1/3},0,0,{1/3},0,0,{1/3},0,1 erode_circ 2 rm. r 50%,50%,1,3,5 o img/simple.mp4,24,H264 rm %% %% -m scripts/wheelie_anim.gmic i 600,600,1,3,lerp([220,220,233,255],[180,180,200,255],y/(h-1)) nm. background -i[-2] (0.92^0.92^0.92^0.995) nm.. multiplier -i[-3] [background],[background],[background],4 -nm... arabesque wheelie_anim[arabesque,multiplier,background] 120,1.125,{1/3},0,0,{1/3},0,1,{1/3},0,2 erode_circ 2 rm. r 50%,50%,1,3,5 o img/simpletoo.mp4,24,H264 rm %%

|- [Wheelies](#wheelie)| [Demons Arise](#demonsarise)| [To There And Back Again](#totherebackagain)| [Wheelie Animations](#wheelieanimations)| [PostScript](#postscript)

|![Arabesque](img/arabesque.mp4)\n               *"Durga's idle arabesques"*|During brief interludes, when tranquility prevails and the peoples of the world are in complete accord, Durga might take ease from her duties and find serenity through simple pursuits.\n\nIt is a small pleasure to swing a compass marker around its anchor leg, and if hands might quave arcs still run true — not that palsy ever troubles Durga, master as she is of the _chakra_ and _trishul_. And so it is hardly burdensome for her to take up compass after compass, anchor to marker, twirling each at spins and spreads picked through whimsy.\n\nSuch a flurry of hands and arms might astonish mortals, but for the slayer of the abominable Mahishasura it is just so many twirlings. With each added compass, the culminating marker traces ways ever more sublime, awarding Durga escalating delights. And so it goes — until demons arise. Durga must then put away her compasses and take up her arrows and bow.
= wheelie
### Wheelies
Deficient as we are in arms, we seek computerized compensations. Accordingly, let _wheelies_ model compass pairs: one end of a segment is a hinge that sticks to whatever it has been attached and the other end swings free. Chains of these emulate Durga's compass-upon-compass pile-ons.

Roughly, we'd like to have some command, 'wheelie' — which we don't know how to write yet — but lives in a place called 'scripts/wheelie_simple.gmic'.  It can draw simple arabesques:

===
|-![simple_01](img/simple_01.png)|![simple_02](img/simple_02.png)|![simple_03](img/simple_03.png)
| 'simple' | 'threewheelie' | 'colorwheelie'
===

This produces a two-wheelie arabesque:
~~~
simple:
    -command scripts/wheelie_simple.gmic
    -wheelie 300,0.375,90,1,0.375,0,2
    -output. simple.png
~~~

`0.375,90,1` specifies a wheelie length of `0.375`, an initial orientation of `90°` and a rotational rate of one revolution per period — a "period" can be as long or short as desired. The first parameter, `300` sets an image size.

Or maybe you want a more fancy three-wheelie arabesque:

~~~
threewheelie:
    -command scripts/wheelie_simple.gmic
    -wheelie 1024,0.375,90,1,0.3125,0,2,0.25,0,5
    -dilate_circ 4
    -r2dx. 300,5
    -output. threewheelie.png
~~~

So maybe you find the white-on-black output a little plain. But that scheme lends itself to further embroidery. Such is done with this five-wheelie:

~~~
colorwheelie :
   -command scripts/wheelie_simple.gmic
   -wheelie 1024,0.375,90,1,0.3125,0,2,0.25,0,5,0.0625,57,-6,0.03125,85,-11
   -dilate_circ 4
   -label.
   -apply_curve. 1,0,255,127,0,255,255
   -map. aurora
   -r2dx. 300,5
   -output. colorwheelie.png
~~~

So let's set about to writing this '-wheelie' thing.

= firstplay
With each wheelie we may:

|      1.  |set a particular radius:|      _r_
|      2.  |pick a starting orientation:|      _θ_
|      3.  |choose a signed, clockwise or counterclockwise, rotational rate:|     _±ω_

The game is to place wheelies, end-to-end, at their starting orientations and take a picture. Account for _ωt_ in all wheelie orientations and take another picture, and so on, until the accumulated change in orientation reaches some preset — perhaps that of one revolution.

Here is the play ( [Figure 1](#figone) ):

|      1.  |Root the first wheelie at the origin.
|      2.  |Hinge additional wheelies at successive free end points, perhaps setting their orientation differently or aligning them all. Do that any number of times, _or_
|      3.  |attach a marker to the rim of a terminal wheelie and take its picture.
|      4.  |Adjust the orientations to account for _ωt_ and plot again … and again until the accumulated adjustment equals the preset. What remains is the traversal path in all of its charm.

Plot by plot, a wheelie's circular motion fathoms easily. But add a few more — complexity strikes us dumb. The remedy for that are patterns. These, in recurrence, divide and conquer.

= figone
===
![wheeliediagram](images/wheeliewalk.svg)
*1. Walking from marker tip to the origin*
===

Paired wheelies, _antecedent_ and _successor_, provide the template. First, characterize relative motion in the locality of a wheelie pair. Then aggregate motions of pairs into larger localities — ultimately that of the whole.

Start with the penultimate and final pair. Establish a local coordinate system. Orient the antecedent to zero degrees, anchor at the local origin and tip aligned with the local _x_ axis. Now bring in the successor. It's sticky end hinges to the antecedent's tip while its own swings free.

The factors accounting for the successor's local motion are its length, _r_, and its orientation _θ + ωt_. Here, _ωt_ is the time-varying part of its orientation, the product of its rotational rate and accumulated ticks: _t = (Δt₀ + Δt₁ + … )_.

These factors bring about an [affine matrix](https://gmic.eu/tutorial/tiled_art.html#affinetransform). Such a matrix takes a point in the neighborhood of the successor's origin (_née_ antecedent's tip) through a translation by _r_ and a rotation by _θ + ωt_:
= figtwo
===

$$
\begin{bmatrix} m_x \\ m_y \\ 1 \end{bmatrix} =
\begin{bmatrix}
\-cos (\theta + \omega t) & -\-sin (\theta + \omega t) & r_x \\
\-sin (\theta + \omega t) & \-cos (\theta + \omega t) & r_y \\
0 & 0 & 1
\end{bmatrix}
\begin{bmatrix} o_x \\ o_y \\ 1 \end{bmatrix}
$$
*2. A Wheelie transform taking a point at _o_ (origin) to _m_ (tip)*
===

This matrix characterizes motion in the locality of this wheelie pair. As _Δt_ ticks off, changing _ωt_, the tip animates a circle of radius _r_; not very interesting but readily grasped.
= figthree
===
![Simple](img/simple.mp4)
*3. The locality of one wheelie pair*
===
Shift toward the root. Write a second matrix. This relates the root-ward wheelie tip to _its_ antecedent: a second circular plot. Multiply the two matrices from right to left to aggregate the motion of both.
= figfour
===
![SimpleToo](img/simpletoo.mp4)
*4. Localities of the second and third, and first and second wheelie pairs compounded together*
===
And so we go, compounding individual circular motions into wider localities. Eventually we obtain the overall motion of the terminal tip relative to the initial root. The pairwise writing of matrices and their aggregation is our divide-and-conquer play. The arabesque of the whole arises from the actions of the parts.

We mark one plot and tick _Δt_. That changes the orientation of all wheelies, of course, so we re-walk the walk, compound the adjusted matrices and plot the second mark. And again. And again … until the preset has been reached.

After all that — we're done. We know how to write this '-wheelie' thing. The implementation looks something like 'wheelie_simple.gmic'. Unroll it for details. See [Annotations](#annotations) for the weeds. 

= wheelielist
??? wheelie_simple.gmic
~~~
  1 wheelie :
  2   # wheelie: a circle of a particular (1) radius, (2) phase angle
  3   # (orientation) and (3) discrete angular velocity - a relative
  4   # integral number of revolutions per however long one revolution
  5   # takes. Wheelies chain together, the center of one situated at 0°
  6   # on the rim of its predecessor. The first wheelie of the chain
  7   # centers at the origin and the last has, instead of another
  8   # wheelie, an attached marking pen. Thus, the entire ensemble
  9   # draws an "arabesque" as the individual wheelies rotate at their
 10   # respective angular velocities from their initial orientations.
 11
 12   # Fetch an arbitrarily long argument list to $a0, $a1, …, $an
 13
 14   $=a
 15
 16   # Expect data triplets: radius, phase angle, angular velocity.
 17
 18   -check "isint($a1) && !(($#-1)%3)"
 19
 20   # Initial argument: side width (sw)
 21
 22   sw={$a1/2}
 23
 24   # Argument image: For each wheelie, compose radius and phase
 25   # arguments into a transformation matrix. In the generation
 26   # loop, we compose this with the angle resulting from one
 27   # angular velocity step.
 28
 29   wcnt={int(($#-1)/3)}
 30   -input $wcnt,1,1,12
 31   -name.  args
 32
 33   # Iterate over argument vector. For each triplet – representing a
 34   # wheelie – Fetch radius (rad), phase angle (ang) and angular
 35   # velocity (sf) parameters.
 36
 37   -repeat $#-1 j=$>
 38      -if   $j%3==0 # get radius
 39         rad=${a{2+$j}}
 40         -check isnum($rad)" && "$rad>=0
 41         -set[args] $rad,{round($j/3,1,-1)},0,0,0
 42      -elif $j%3==1 # get angle, degrees
 43         ang=${a{2+$j}}
 44         -check isnum($ang)" && "$ang>=0" && "$ang<=360
 45         -set[args] $ang,{round($j/3,1,-1)},0,0,1
 46      -else         # get ω and set spectral coefficient
 47         sf=${a{2+$j}}
 48         -set[args] $sf,{round($j/3,1,-1)},0,0,2
 49      -fi
 50   -done
 51
 52   # Iterate over argument image, each 12 channel pixel representing
 53   # one wheelie. The first three channels contain wheelie radius,
 54   # phase angle and radial velocity. Compose a matrix transforming
 55   # the origin to the tip of the wheelie, a radial translation and
 56   # phase rotation. Populate the nine remaining channels with this
 57   # matrix.
 58
 59   -fill[args] ">
 60           CPX=I;
 61           orot=rot([0,0,1],deg2rad(CPX[1])); # phase rotation
 62           xlat=eye(3);
 63           xlat[2]=CPX[0];                    # translation origin
 64           [CPX[0,3,1],mul(orot,xlat,3)];     # -to-rim, i.e.
 65               "                              # 'rotation & xlation'
 66                                              # store above in
 67                                              # 12-channel pixel
 68   -permute[args] cyzx
 69   -store[args] circles
 70
 71   # Screenspace transform.
 72   ssxfrm={"
 73            specw=get('sw',0,0);
 74            id=eye(3);
 75            id[0]=specw;
 76            id[2]=specw;
 77            id[4]=-specw;
 78            id[5]=specw;
 79            id
 80           "}
 81
 82   # Draw arabesques on this image
 83   -input {2*$sw},{2*$sw},1,1
 84   -name. canvas
 85
 86   atk=0
 87   lastpt={vector3([0,0,1])}
 88   firstpt={vector3([0,0,1])}
 89   -repeat 3*$sw k=$>
 90       # For each wheelie:
 91       # increment by angular velocity
 92       # find corresponding rotation matrix
 93       # compose with radial argument image, compose
 94       # with screenspace transform and plot via polygon().
 95
 96       -eval ">
 97           const cc=$wcnt;
 98           fpt=get('firstpt',3,0);
 99           ik=get('k',0,0);
100           lpt=get('lastpt',3,0);
101           omega=get('atk',0,0);
102           specw=get('sw',0,0);
103           circs=get('circles',12*cc,0);
104           pp=vector3([0,0,1]);
105           imat=eye(3);
106           repeat(
107                 cc,k,
108                 idx=cc-k-1;
109                 imat=mul(
110                         mul(
111                            rot([0,0,1],circs[12*idx+2]*omega),
112                            circs[12*idx+3,9,1],
113                            3
114                            ),
115                         imat,
116                         3
117                         );
118                 );
119           ssx=get('ssxfrm',9,0);
120           plt=ssx*(imat*pp);
121           ik>0?
122           polygon(#$canvas,-2,[plt[0,2],lpt[0,2]],1,0xffffffff,255):
123           store(plt,'firstpt',3,1,1,1);
124           store(plt,'lastpt',3,1,1,1);
125           ik==(3*specw-1)?
126           polygon(#$canvas,-2,[fpt[0,2],plt[0,2]],1,0xffffffff,255)
127              "
128       atk={2*pi*($k/(3*$sw-1))}
129   -done
~~~
???

= annotations
### Annotations

??? Weeds, for those wishing to delve into them.
|  __Line__  |  __Remark__  
|  **14** | '$=a' A pseudo assignment. G'MIC transforms this into a series of actual assignments. This _'$-expression'_ generates an assignment sequence with the base name 'a' for however many elements on the command line there may be. '$a0' identifies the name of the script, so one could alter script behavior based on the script name. '$a1…' onward are the arguments. See [Adding Custom Commands](https://gmic.eu/reference/adding_custom_commands.html#top). There is nothing special about the base name 'a'. It could be anything: '$=fruitloops' initializes command line variables '$fruitloops0, …, $fruitloops<n>'.
|  **16-29** |We sanity-check the arguments. 'wheelie' expects '$a1' to specify the length of one side of a square drawing canvas, so anticipates that the first argument is an integer. '$#' is another _'$-expression'_; this one resolves to the number of comma-separated arguments given to 'wheelie'. Wheelie specifications occur in groups of three, _r_, _θ_ and _±ω_ so '!(($#-1)%3)' enforces arguments in triplets; it is _False_ if the number of arguments, less the first, is not evenly divisable by three. Thus, the user specifies the image size with the first argument and employs triplets of successive arguments to specify wheelies, one triplet for each.
|  **22,29** |Curly brace pairs indicate a number of possible substitutions, see [Substitution Rules](https://gmic.eu/reference/substitution_rules.html#top), and if the contents of curly braces cannot be attributed to requests for some image feature, it is taken to be a math evaluator expression. For those new to such, the encounter is a bit like falling into a rabbit hole, left-and-right curly braces ideographic of the impending cavity. Take a deep breath, grasp something solid, and remember that it is just another language, not a difficult one once one is past the notation. Much the same may be said for other languages. Above all, the construct flags that some kind of substitution is going on, and the source information shall be the results of the math computation. In the present cases, the right hand sides of assignment operators initialize pipeline variables with the results of computations. [Mathematical Expressions](https://gmic.eu/reference/mathematical_expressions.html#top) furnishes a complete, if terse, set of objects that compose mathematical expressions. Of the present cases, the first sets a resolution metric. '$sw' associates one unit of distance in the computation space of wheelies to a particular number of pixels, thus anchoring our relative lengths to something definite: the screen space of pixels. This resolution metric figures in a number of sizing tasks, such as scaling the number of plots necessary to draw an arabesque. Not so many for small pixel dimensions; a lot otherwise. The second derives 'circle count' – aka, the number of wheelies specified in the argument list. This is just the number of arguments dedicated to wheelie specifications, '$#-1', divided by three, because each wheelie consists of three arguments.
|  **29-50** |The 'args' image is not for display; it is an argument database. Each pixel in this "argument image" specifies aspects of one wheelie. Channels 0-2 hold _r_, _θ_ and _±ω_ and this first 'repeat…done' loop saves them for future reference; channels 3-11 are reserved for the wheelie-specific affine transforms. To reduce computations in the animation loop between **89-129**, we break computation into "stage 1" and "stage 2" phases. "Stage 1" precomputes matrices with only _r_ and _θ_ elements, which are time-independent. "Stage 2" occurs at every _Δt_ tick, but only needs to composite a pure rotation into the "stage 1" matrix, reflecting the time-dependent rotation angle _ωt_.
|  **59-65** |'fill' iterates over the 'args' image, computing the "stage 1" affine transformations for each wheelie. Storage for each wheelie occupies a twelve channel pixel of the image; In each step of the fill, the current pixel, 'I', represents all that is known about one wheelie.
|  **60** | Assigning 'I' to 'CPX' is not a (redundant) assignment of one vector to another, rather it is the creation of a vector from a pixel — not the same operation! The right hand side, 'I' is a _pixel assessor function;_ lacking the decorator '[ … ]', '[0]' is implied, the current pixel offset. The remit of a pixel assessor is to fetch the current pixel — or, with an explicit decorator, a pixel at some specified offset _k_ for decorator '[k]' — and then generate a vector for the left hand side. _The assessor function itself is not a vector!!!_ regardless of notational similarities. For example, armed with a relatively recent 'gmic', (3.0.1 or better), one may temporarily insert a diagnostic line '…print(I[1]);print(CPX[1]);…' following the assignment on line **60**. When a 3.0.1 or better math evaluator compiles such a 'print' expression, it first provides the structure of the object that would be printed during the later expression execution. For the diagnostic: 'print(I[1])' the report 'I[1] = (uninitialized) (compiled as vector12, memslot = x )' obtains, with _x_ a numeric memory slot identifier. For the diagnostic 'print(CPX[1])' the report 'CPX[1] = (uninitialized) (compiled as scalar, memslot = y )' obtains. 'vector12' and 'scalar' are not identical structures! Inadvertently conflating vector and pixel assessors is seed for subsequent bugs. The 'vector12' which _pixel_ assessor function 'I[1]' retrieves is the pixel _after_ 'I[0]', the current pixel. The 'scalar' which _vector_ assessor function 'CPX[1]' retrieves is the second element in the 'vector12' object 'CPX', which is a scalar. The takeaway is this: the assessor operator '·[ _<offset>_ ]' behaves like a pixel-to-vector converter when '·' is a pixel; it is a vector element assessor when '·' is a vector. Dispair at ever keeping such straight may be relieved by diagnostic 'print( … )' expressions. Use whenever siezed by doubts. In the present case, we sought the vector assessor behavior of 'CPX[ … ]', not the pixel assessor behavior of 'I[ … ]', hence the line **60** assignment. See **64,65** annotations for more vector assessor syntax sugar.
|  **61** | 'rot()' generates pure rotational matrices: 2 × 2 for two dimensional work and 3 × 3 for three dimensional. In the latter form, one provides the axis of rotation to complete the specification: '[0,0,1]' identifies the three-space _+z_ unit axis.\n\nThat we are operating in three dimensions may give one reason to pause. Recall our preference for working with [homogeneous points](https://gmic.eu/tutorial/tiled_art.html#affinetransform), inhabitants of a three dimensional projective space, so that we can encapsulate both rotation and translation in one transform — as well as diambiguate points from vectors. In this case, the axis of choice is the _+z_ axis, perpendicular to the canvas, so that when we rotate points in the canvas plane, they stay in the canvas plane. The first use of this function gives us 'orot', _origin rotation_ derived from _θ_, the second element of the wheelie vector. 'deg2rad()' conveniently converts this element from degrees to radians. So does the ° operator — the degree symbol. Thus 45.739° in a G'MIC math expression quietly transforms itself into ≈ 0.798296 radians. Consult your operating system manual on how to obtain off-keyboard characters if you cannot find the ° sign on it.
|  **62,63** |We generate the translation matrix, 'xlat' by starting with the 3 × 3 identity matrix, as furnished by 'eye()'. In an affine transform, elements two and five embody spatial displacement. We set only an _x_ displacement, this the length of the wheelie; what of _y_? Recall from the main discussion that we view individual wheelies in a relative way, so it suits us to build up the local wheelie transform where the wheelie itself is in a standard orientation: zero degrees orientation with the wheelie aligned to the _+x_ axis. Thus, in this most local of spaces, there is no displacement in _y_.
|  **64,65** |At the outset, 'CPX' just holds  _r_, _θ_ and _±ω_; we assemble a new version that also contains the time-independent "stage 1" wheelie transform; see [Figure 2](#figtwo). Overall, we re-compose this new version from a 12 element vector composed of two fields. The first field, elements 0 - 2, is a copy of the initial three fields of 'CPX' and contains _r_, _θ_ and _±ω_, obtained during command line processing; see **29-50**. The second field, elements 3 – 11, becomes populated by the math evaluator operating on 'mul(orot,xlat,3)'; the expansion of that matrix multiplication produces a 'vector9', the 3 × 3 "stage 1" wheelie transform.\n\nTo make the first field, A _vector assssor function_ copies _r_, _θ_ and _±ω_ from 'CPX' to the re-composed vector; the three argument form of this function's decorator, a pair of open-and-close square brackets, may take as many as three arguments: '[ <starting index>, <subvector length>, <stride> ]'; the vector accessor function extracts subvectors from source vectors. The first argument marks the index in the source vector where the subvector starts. It is the only required argument and, used in isolation, simply extracts a single element from the source vector. The second argument, if present, sets the length of the subvector. Thus 'V=[0,1,2,3,4,5,6,7,8,9]'; 'SV=V[5,3]' sets 'SV' to '[5,6,7]', the three element subvector beginning at index = '5'. The third argument, if present, sets the _stride_, and defaults to increments of one element. Thus 'V=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];V[0,4,4]' retrieves the subvector '[0,4,8,12]', the four element subvector starting at index '0' in the source and consisting of every fourth element. Extracting a subvector through the vector accessor function is read-only; one cannot use it on the left hand side of an assignment and expect to set the values of a left hand subvector. For that, consider 'copy()', which can transcribe a subvector from a source to a destination vector.\n\nThe second field composing the wheelie vector harnesses 'mul()' to compose the two matrices: 'orot', the rotation component generated from  _θ_, and 'xlat' the translation component generated from _r_. The right-to-left multiplication, or _composition_, of the translation and rotation matrices produces the _wheelie matrix_. This matrix transforms a point at the origin of the wheelie to its tip and reflects the combined operation of displacing the point along the _+x_ axis by a distance equal to the length of the wheelie (_r_) then rotating this position vector by _θ_.\n\nCare must be taken with the matrix multiplier, 'mul()', for the right-to-left composition of a translation and a rotation matrix is not the same as a left-to-right composition. With the latter, the resulting matrix reflects the combined operation of first rotating the point at the origin, and _then_ translating it. Alas! The rotation of a zero-length position vector — a point — is of no consequence as a point rotating around itself remains unchanged. That leaves just a translation, a less-than-full characteration of the transform. That is why the composition starts with 'xlat', generating a positive length displacement vector aligned along _+x_, to which we compose 'orot', rotating that displacement vector around the local origin. The non-communicative quality of matrix algebra is a source of many an interesting bug — amusing after the fact, exasperating in the moment.
|  **64** |As the last statement in the math expression argument to ''-fill'', the re-composed 'vector12', '[CPX[0,3,1],mul(orot,xlat,3)]', undergoes an implicit vector-to-pixel conversion, updating the current "wheelie entry" in the database image 'args'.
|  **68-69** |When done filling the image-based "wheelie database", we harness [store](https://gmic.eu/tutorial/store.html) to make the wheelie data accessible to the math evaluator; it may do so through the 'circles' _image storage variable_. The permutation prior to 'store' is for convenience. The reorganizing of the 'args' image through this permutation leaves wheelie components arrayed along the 'arg' image 'x' axis instead of along its spectral axis. The wheelie vectors contiguous along the 'x' axis make for more straightforward access in the arabesque drawing loop.
|  **82-129** |The arabesque drawing loop draws one mark of the arabesque per iteration. **89:** '-repeat 3*$sw k=$> … -done' establishes the number of plots; 'k' grows with larger images. The multiplier, '3', stems from artistic whimsy; lower this multiplier for faster, sparser plotting. The loop operates once for each _Δt_.\n\nThe wheelie walk discussed in the main article is realized from **106:** '-repeat cc,k, … ' through **118.** Among other chores, it retrieves the stage 1 time-independent transform from 'circs', the wheelie database, and composites it with a rotation matrix derived from _ωt_. The inner 'mul()' **110,** expression performs this composition. The rotation matrix derived from _ωt_ is the first term of 'mul()': 'circs[12*idx+2]' retrieves the wheelie-specific angular velocity, _ω_, from the wheelie database; 'omega' holds accumulated "time". 'Omega' is a proxy for '$atk'. See **128** and **101**, which brings the command line variable '$atk' into the math expression environment. Rotation around the _+z_ projection space axis produces a matrix reflecting _ωt_. The second term of 'mul()', 'circs[12*idx+3,9,1]', retrieves the stage 1, time-independent transform, a composition of _r_ and _θ_ — another use of the vector accessor function. The composition of these two terms produces the dynamic version of the wheelie matrix.\n\nThe outer 'mul()' expression spanning **109-117**,accumulates the local, dynamic wheelie matrices into 'imat' — this, the realization of the tip-to-origin walk. Dropping out of the 'repeat' loop spanning **106-119** delivers 'imat'. This grande finale matrix embodies the entire transform of a point at the origin of the wheelie chain up to the tip of the final wheelie.
|  **119-126** |The bottom of the arabesque drawing loop concerns itself with plotting arabesque marks: line segments between adjacent _Δt_ plots and drawn by 'polygon()'. The drawing loop maintains a two-plot window, realized by storage variables 'firstpt' and 'lastpt' These points are in display space, so the matrix responsible for that transform is summoned from storage variable 'ssxform'. Recall **72-80**. Referring to **120**, 'imat*pp' carries a apoint from the origin to the wheelie tip and is subsequently transformed by 'ssx' into a display space plot.\n\nTo create a two point plotting window, the drawing loop retains the plot of the previous iteration in 'lastpt' and draws from that to the current plot; before the iteration finishes, the current plot becomes the next inhabitant of 'lastpt', to serve in a similar capacity in the next iteration. That accounts for most drawing activity, excepting the initial and final boundary cases. Nothing is plotted in the first iteration. Instead, the initial plot is stashed to both 'firstpt' and 'lastpt'. Through all remaining iterations, up to the last, 'firstpt' is undisturbed. When the last iteration is realized and plotting has taken place, there remains a gap between 'firstpt' and 'lastpt.' These become plot points for an extra, final call to 'polygon()', which closes the gap between the initial and final plots, finishing the arabesque.

???

= demonsarise
## Demons Arise
To our settled way of thinking come demons…

Drawing arabesques with wheelies exemplifies following one's nose. We more-or-less design from what we see. See a compass; imagine a wheelie. Post-and-lintel, to be sure, but post-and-lintel works just fine — thank you! — in all that doors require for letting people get around.

===
|- ![stonehenge](images/Stonehenge.jpg)
| *5. Post-and-Lintel Stonehenge — Clive Perrin*
===
But along come arches — a subtler approach. Though it seems improbable, disjoint stone can span greater distances than contiguous lintels, which, when their spans are too long, break under load. Yes — post-and-lintel provides all that doors require, but this improbability intrigues. One cannot go on being curious but leave such peculiarities behind. 
===
|- ![doublearch](images/Ponte_dei_Salti.jpg)
| *6. Stone Double Arch Bridge, Valle Verzasca - Ponte dei Salti — qwesy qwesy*
===

= spiral
| ![spiral](images/spiral.svg) *7. The Looping Spiral: Travelling along its path conjures a time domain signal.* |Now for wheelies: they rotate. Rotation brings in the frequency domain.\n\nAnd _that_ brings in the discrete — forward and inverse — [Fourier transforms](https://en.wikipedia.org/wiki/Discrete_Fourier_transform), coupling the _frequency_ and _time domains._\n\nAnd with those, comes another divide-and-conquer scheme: this one aimed at "rotational complexity."\n\nConsider: A pen drawing an arabesque certainly progresses through time and gives rise to varying positions, yet any such convolution — any such _signal_ — may be sundered into a _Fourier series_ of _[sinusoids](https://en.wikipedia.org/wiki/Sine_wave)_, these originating from the eponymous trigonometric sine functions. They promise to cleave apart rotational complexities into simple pieces.\n\nSinusoids have no overtones. Their magnitudes are entirely vested in one fundamental frequency. This property, unique to sinusoids, marks them as an elemental for more intricate fashionings. They are _basis functions_ for slicing-and-dicing overtone-ladened signals. The discrete forward Fourier transform performs the slicing-and-dicing. Its inverse resynthesizes.

= phaseplot
| ![phaseplot](images/phase.mp4)\n*8. Phase plotting: The reals (blue) drives horizonal movement; the imaginaries (red) the vertical.*|Here's a shiv that cuts: sinusoids are cognates with rotating wheelies. Redraw a sinusoid on a _phase diagram_. It looks like a wheelie. A wheelie's tip travels a circular pathway on a phase diagram: it separates out into vertical- and horizontal-motion, a complex sinusoid. It is trivial to link vertical and horizontal motions to the imaginary and real components of complex numbers, opening up a toolkit for wheelie rotations.\n\nSo there is a game afoot: harness slice-and-dice to unpack and repack arabesques. Play it out with wheelies, cousins and cognates of the sinusoids.

Durga has never entirely vanquished demons. They disrupt, but that routs us out of the stupor of settled thinking, Now the game's afoot; we're dispatched to finesse a better way.
= time0
===
|- ![time_0](images/time_0.svg)
| *9. The Looping Spiral as a time domain oscillation*
===

We start by traveling backwards from the arabesque. Imagine a bead traveling along an arabesque drawn on a phase diagram ( [Figure 7](#spiral) ). Its travel generates time domain signals for both vertical and horizontal axes ( [Figure 9](#time0) ).

= freq0
===
|- ![freq_0](images/freq_0.svg)
| *10. The Looping Spiral as a frequency domain chord*
===

The forward Fourier transform deconstructs these time domain signals into a sinusoidal Fourier series. Such maps to a frequency domain "image" of the arabesque ( [Figure 10](#freq0) ).

Here's how the mapping goes. Having no overtones, each sinusoid in the series goes to but one _ordinal_ position. This sinusoidal distribution is akin to a chord being played on an infinitely long piano keyboard. Press a key at a particular ordinal and but one, pure sinusoid oscillates in time — a fundamental, no overtones, at a pitch equal to the key's ordinal position. The value at that ordinal, a complex number representing one sinusoid of the series, encodes its  magnitude and phase shift. The value's _modulus_ sets the signal's magnitude; its _argument angle_ sets the signal's phase. The entire frequency domain image compares to a chord which the inverse transform "plays" as a fundamental and its overtones.

While a pretty thought in principle, an infinite keyboard is hard to use in practice. This limitation gives rise to finite keyboards, and with these aliasing artifacts. Should a sinusoid exceed a specified [Nyquist Sampling Rate](https://en.wikipedia.org/wiki/Nyquist_rate), ( [Figure 11](#figeleven) ), essentially falling off the keyboard, then the difference between the sinusoid's excess frequency and the Nyquist Rate sets up a _beat frequency_: the elided high frequencies aliasing to low-frequency artifacts, such as [moiré patterns](https://en.wikipedia.org/wiki/Moir%C3%A9_pattern). So long as the keyboard is long enough to incorporate a maximum anticipated rotation, then Fourier transform between time and frequency domain remain free of artifacts.

= figeleven
===
![spectralspace](images/spectralspace.svg)
*11. Plotting _kth_ wheelie sum in a one dimensional, discrete, circular and finite frequency domain.*
===
Fallout from finiteness calls for a model of the frequency domain that incorporates the Nyquist Rate as a fundamental limit. That, and the need to incorporate wheelie properties of radius (magnitude) _r_, orientation (phase) _θ_, and rotation rate (frequency) _±ω_ in both a positive (counterclockwise) and negative (clockwise) sense, rouses the need for a more detailed frequency domain map:

|      1.  |This domain is a discrete, one dimensional and circular space populated by complex values at integral ordinals.
|      2.  |Its origin corresponds to a rotation rate of zero. Discrete frequencies, _ω_, changing only by fixed, integral steps, the ordinals, mark off the abscissa. These ordinals are commensurate with wheelies' rotational rates and increase with distance from the origin. Being a finite, circular space, that increase can only go on for so long.
|      3.  |The abscissa wraps around. Clockwise and counterclockwise rotational rates, analogous to the negative and positive directions of other spaces, extend from the origin's left and right, respectively, meeting at the Nyquist Sampling Rate (_n_) of the space. Not only does this set the space's extent at _2·n_, it establishes the most rapid rotational rate that can directly transform without generating aliasing artifacts.
|      3a.  |Excepting the Nyquist Sampling Rate and origin, a particular rotational rate, _ψ_, corresponds with _two_ frequency ordinals, _+ψ_, on the counterclockwise side of the origin, and _-ψ_, on the clockwise side. In the corresponding sinusoid, a _+ψ_ rotational rate gives rise to an imaginary sine wave trailing its real counterpart, while a _-ψ_ rotational rate gives rise to an imaginary sine wave leading its real counterpart. This distinction leads to counterclockwise and clockwise rotations, respectively.
|      3b.  |Two ordinals of the same absolute value, but differing in sign, constitute _chiral pairs_. How two values differ in a chiral pair controls the signal's polarization at the designated frequency. Should one or the other be zero, the vector rotation is circular in an phase diagram and exhibits circular polarization. If they are complex conjugates, the "rotation" proceeds back-and-forth either along the orientation angle or at right angles to it — linear polarization. Otherwise, if they differ in an arbitrary way, the rotation is elliptical, with the semi-major axis either aligned with the orientation angle or athwart it.
|      4.  |As a consequence of this folding, addition and subtraction are [modular](https://en.wikipedia.org/wiki/Modular_arithmetic) — forming a clock arithmetic.

In [Wheelies](#wheelies) we used wheelie chains to draw arabesques; matrix multiplications of elemental rotation-and-displacement matrices tell us how the travels of a wheelie chain tip goes in relation to the origin: it draws an arabesque. Our present ruminations let us sunder arabesques into a Fourier series of sinusoids, these scribing a frequency domain image of complex-number "pixels," each encoding a wheelie.

`Tis a facile thing to take these wheelies to be the links of the chain that draws the arabesque, but that is not so. Literally translating the ordinal values into sinusoids, thence to wheelies, give rise to a collection of wheelies that draws an arabesque — just not the same arabesque orginially sundered. The demons are in the details. Insight about what these demons have wrought comes with a consideration of the tip wheelie. it's bearing and gyrations are not entirely its own, but is the angular sum of all its antecedents. And that is so of its antecedent as well, but to one term less. There are progressive wheelie sums to account for along the wheelie length. The following mapping algorithm accounts for this detail: 

= mapwheelies
### Mapping Wheelies to the Frequency Domain
|      1.  |Finding the frequency domain ordinal that corresponds to a wheelie consists of getting the wheelie's _projections_ on the real and imaginary axes; see [Figure 12](#figtwelve). These projections follow from the wheelie's bearing on the complex plane. Taking this angle's sine and cosine and applying them to the wheelie's length, _r_, obtains these projections, which, in the frequency domain, become the real and imaginary components of the corresponding value.
|      2.  |A wheelie's bearing is more than just its deflection from its antecedent, _θ_, but a sum of all it's antecedents: _Σθ_. That dictate stems from chaining: A wheelie reflects both its own and the orientations of its antecedents. Similarly, the ordinal stems from the sum of wheelie rotational rates all along the chain: _Σω_. Let _wheelie sums_ denote these two angular sums.
|      3.  |Starting from the root wheelie, initialize aggregate sums for orientation, _Σθ_, and rotational rate, _Σω_, with the orientation of the root, _θ₀ → Σθ_, and the root's rotational rate, _±ω₀ → Σω_.
|      3a.  |If _Σω_ < 0, add twice the Nyquist rate: _Σω + 2·n → Σω_ in accordance with modular arithmetic.
|      4.  |With the current wheelie, decompose its radius, _r_, into complex components: _r_ → _r·cos(Σθ) + i·r·sin(Σθ)_.
|      5.  |Add this decomposed complex radius to the value at ordinals _Σω_.
|      6.  |If there are no further wheelies in the chain, branch to 8. Otherwise:
|      7.  |Proceed to the next wheelie in the chain from the root. Add its orientation, _θ_, and rotational rate, _ω_, to aggregate sums:  _θ + Σθ → Σθ_, and _ω + Σω → Σω_.
|      7a.  |If _Σω_ < 0, then add the Nyquist rate: _Σω + 2·n → Σω_ in accordance to modular arithmetic. Branch to 4.
|      8.  |We've finished plotting. The inverse discrete Fourier transform generates the arabesque; we exit.
= figtwelve
===
| ![wheeliespatial](images/wheeliespatial.svg)
|*12. Accumulated orientations and rotationl rates of wheelies determine plotting values (_r·cos(Σθ) + i·r·sin(Σθ)_) and frequency domain ordinals ( Σω )*
===

For a concrete example, consider these wheelies ( also shown in [Figure 6](#figsix) ):
= tabwn
|- wheelie | radius (_r_)| orientation (_θ_)| spin (_±ω_)|_Σθ_|_Σω_|_r·cos(Σθ)_|_i·r·sin(Σθ)_
| *   1* | *   2* | *  3* | *  4* | *  5* | *  6* | *     7* | *     8*
|W₀|0.50000|30°|+1|30°|+1|0.43301|0.25000
|W₁|0.12500|45°|2n-5|75°|2n-4|0.03235|0.12074
|W₂|0.25000|15°|+3|90°|2n-1|0.00000|0.25000
|W₃|0.50000|315° (-45°)|+4|45°|+3|0.35355|0.35355

The plotting scheme is similar to the wheelie walk of yore; we loop over the wheelies and, for each, sum orientation and spin with antecedents, compute the resultant orientation angle, separate the radius into real and imaginary parts (columns 7 and 8) and add these to the value at ordinal _Σω_ (column 6). This itself is a sum, as _Σω_ is a modular result and subject to wrapping around; there could be many sums that plot to particular ordinals.

= figthirteen
===
| ![wheeliespectral](images/wheeliespectral.svg)
|*13. Accumulated orientations and rotational rates establish ordinals (_r·cos(Σθ) + i·r·sin(Σθ)_) and abscissa coordinates ( Σω )*
===

What obtains could be termed the "frequency domain image" of the arabesque and is commensurate with it. When we transform the frequency domain image to the temporal domain we "play the chord" and obtain periodic oscillatory complex ordinals on the interval _0, …, 2·π (0°, …, 360°)_.
= figfourteen
===
| ![wheelietemporal](images/wheelietemporal.svg)
|*14. Temporal counterpart of the frequency domain: wheelie plots*
===

The arabesque itself appears by copying the oscillatory ordinals out of the temporal domain and replotting them on an phase diagram of the complex plane.
= figfifteen
===
| ![wheelieplot](images/wheelieplot.svg)
|*15. Arabesque of wheelies W₀, W₁, W₂ and W₃ in an phase diagram*
===

Spectralarabesque.gmic realizes this scheme:
??? spectralarabesque.gmic
~~~
  1 #@cli fwheelie : spectral_width,radius_0,angle_0,angular_velocity_0…
  2 #@cli : Plot a two channel image of the discrete frequency domain
  3 #@cli : that generates the arabesque corresponding to the supplied
  4 #@cli : wheelie parameters, r, θ and ±ω triplet(s) on the command
  5 #@cli : line. (1) width and height of the phase diagram portraying
  6 #@cli : the wheelie (2...) r, θ, ±ω triplets, length, degrees
  7 #@cli : orientation and revolutions +ω (counterclockwise) or -ω
  8 #@cli : (clockwise); one triplet for each wheelie. Fwheelie leaves a
  9 #@cli : ½(spectral_width+spectral_width%2?0:1),1,1,2 image on the
 10 #@cli : list with plotted wheelie sums as complex frequency domain
 11 #@cli : ordinals; channel 0 real and channel 1 imaginary. Image
 12 #@cli : suitable as a specplot selection, which generates the phase
 13 #@cli : plot.
 14
 15 fwheelie :
 16    # Pseudo assignment expands to command line arguments
 17    $=a
 18
 19    # Expect data triplets $a1,$a2,$a3…
 20
 21    -check {!(($#-1)%3)}
 22
 23    # phase diagram is 2*$sw × 2*$sw for mapping to
 24    # [-1…1] on a side in the complex plane; force $sw odd.
 25
 26    sw={$a1/2}
 27    -if $sw%2==0
 28       sw+=1
 29    -fi
 30
 31    # carray: Two row vectors for real and imaginary
 32    # frequency domain ordinals. Size from first argument.
 33
 34    -input $sw,1,1,2
 35    -name. carray
 36
 37    # Fetch and check diameter, phase angle and angular
 38    # velocity parameters. Aggregate Σω -> $accsf; Σθ → $acca
 39
 40    accsf=0
 41    acca=0
 42
 43    # Iterate over arguments; populate carray and aggregate.
 44
 45    -repeat $#-1 j=$>
 46       -if   $j%3==0 # get radius r
 47          rad=${a{2+$j}}
 48          -check isnum($rad)" && "$rad>=0
 49       -elif $j%3==1 # get angle, θ, degrees
 50          ang=${a{2+$j}}
 51          -check isnum($ang)" && "$ang>=0" && "$ang<=360
 52          acca+=$ang
 53       -else         # get ω, revolutions
 54          sf=${a{2+$j}}
 55
 56          accsf+=$sf
 57          -if $accsf<0
 58             sf={($sw+$accsf)%$sw}
 59          -elif $accsf>=0
 60             sf=$accsf
 61          -fi
 62          # Ordinal components via Σθ, then populate freq. dom.
 63          rr={$rad*cos(deg2rad($acca))}
 64          ir={$rad*sin(deg2rad($acca))}
 65          -set[carray] {$rr+i(#0,$sf,0,0,0)},$sf,0,0,0
 66          -set[carray] {$ir+i(#0,$sf,0,0,1)},$sf,0,0,1
 67       -fi
 68    -done
 69
 70    # Scale freq. dom. by dom. length - for ifft.
 71    # carray: frequency domain image generated from
 72    # the given wheelie chain.
 73
 74    -mul[carray] $sw
 75
 76 #@cli specplot :
 77 #@cli : Generate a phase diagram from the selected frequency
 78 #@cli : domain image.
 79
 80 specplot :
 81    -foreach
 82      {
 83         # Frequency domain → time domain
 84         -name. carray
 85         -split[carray] c
 86         -ifft[-2,-1]
 87         -append[-2,-1] c
 88         -name. temporal
 89         sw={w#$temporal}
 90
 91         # Screenspace transform.
 92         -fill[temporal] ">
 93                          begin(
 94                                 specw=w#$temporal;
 95                                 id=eye(3);
 96                                 id[0]=specw;
 97                                 id[2]=specw;
 98                                 id[4]=-specw;
 99                                 id[5]=specw;
100                               );
101                          (id*[I(x,y),1])[0,2];
102                        "
103         -permute[temporal] cyzx
104         -input {2*$sw},{2*$sw},1,1
105         -name. canvas
106         -eval[canvas] "begin(
107                               PV=crop(#$temporal);
108                               polygon(
109                                        #$canvas,
110                                        -int(size(PV)/2),
111                                        PV,
112                                        1,
113                                        0xffffffff,
114                                        255
115                                      )
116                             )"
117         -keep[canvas]
118      }

~~~
???

= spectralannotations
### Spectral Annotations

??? Weeds, for those close to the ground.
|  __Line__  |  __Remark__  
|  **17-61** | Command line management, **34-61**, largely follows from wheelie.gmic; see remarks there. Modularization distinguishes this implementation from that of wheelie_simple_simple.gmic. The plotting of the frequency domain with wheelie sums has been isolated to 'fwheelie'. The frequency domain transforming of the  domain and the subsequent rendering of the arabesque has been isolated to 'specplot.' The two may be invoked independently of one another, convenient for separating parsing from rendering. Emulation of the original 'wheelie' command becomes, then, a two-step affair:

~~~
$ gmic                                                             \
   scripts/spectralarabesque.gmic                                  \
   fwheelie 512,0.5000,30,1,0.2500,60,-2,0.5000,314,4,0.1250,32,-7 \
   specplot.
   …
~~~

|  | 'fwheelie' plots wheelie sums in the spectral domain, leaving its image on the list, while 'specplot' transforms and renders the arabesque in a phase diagram.
|  **31-61** |'carray' is the implementation of the 1-D, finite, circular and discrete frequency domain parameter space. The '-repeat' … '-done' loop, spanning **45,68,** parses wheelie specifications from the command line and and plots them in accordance to [Mapping Wheelies to the Frequency Domain](#mapwheelies); see the main text. 'carray' is the main product of 'fwheelie' and is left on the image list. Typically, 'specplot' uses 'carray' to plot the arabesque in an phase diagram.
|  **45-68** |'acca' implements _Σθ_; 'accsf' implements _Σω_; 'sf' is a convenient pointer into 'carray', the frequency domain buffer. We plot ordinals via '-set', **65,66**. As noted in the prècis, we do not set the ordinal at abscissa coordinate '$sf'; we add to what is already there, for in light of wrap-around arithmetic we may visit a frequency coordinate any number of times.
|  **80-118** |specplot: Producing arabesque plot points is a two-step affair. The first step encompasses the transformation of the frequency domain image into its temporal counterpart; that is the nub of **83-89**; '-ifft' effects the inverse discrete Fourier transformation. This leaves temporal complex ordinals plotted along a temporal abscissa: this is the arabesque — but not in presentation form. The second step, **92-102,** makes it so. We harness the '-fill' command to rescale the ordinals to display dimensions based upon the pixel dimensional scaler '$sw'. [-fill](https://gmic.eu/tutorial/fill.html#math_expressions) takes a math expression argument which executes on every pixel. The math expression itself has two parts. The math expression function 'begin()' schedules run-once expressions before per-pixel iterations, ideal for setup. It has a counterpart, 'end()' which similarly schedules run-once expressions after per-pixel iterations, ideal for clean up. In this case, 'begin()' formulates a [homogeneous transform](https://gmic.eu/tutorial/tiled_art.html#affinetransform) for projecting ordinals into a display square. The body of the expression, **101**, applies this matrix to every pixel in the 'temporal' image, which, hitherto, were suitable for a 2 × 2 image centered on the complex plane origin; they are translated and scaled to plot on a '2·$sw' × '2·$sw' range with the coordinate in the upper left corner. Expression '(id*[I(x,y),1])[0,2]' may leave a first-time reader breathless. Within parentheses, matrix 'id', defined in the 'begin()' function, operates on homogeneous position coordinates, which have three elements. Trailing the parentheses, an accessor operator. This accessor extracts the first two elements of the three-element homogeneous position. The last line in the math expression, the '-fill' operator assigns this 2-vector to the current pixel, by the last statement returns values convention.
|  **75-87** |This final set of expressions renders the scaled and translated arabesque on a complex plane, 'canvas'.
|  **75** | Arabesque plots are permuted to lie along the spectral axis so that when they are imported into a math expression vector, the layout can be directly used by 'polygon()' See **79**.
|  **76-77** |'canvas' represents a 2·$sw × 2·$sw drawing space for 'polygon()'.
|  **78-87 **|The math expression function 'crop()' conveniently crops an image list item, organizing its pixels into a vector accessible by math expression functions. Referencing only an image, without crop limit parameters, transfers the image in its entirety into the math environment. 'PV', acquires the arabesque plot points and becomes a plotting source parameter to 'polygon().'

???

= totherebackagain
## To There And Back Again
Suppose we already have an arabesque, or, more broadly, an arbitrary shape topologically equivalent to a circle, but which has been suitably worked over by an Old School ash, 18 inch Louisville Slugger® so as to appear, say, like a 1911 Goudy Bookletter ampersand, over which some tutorial writers appear to be obsessed. Are there wheelies that could generate it?
= figsixteen
===
| ![goudyampersand](images/ampersand_circ.svg)
|*16. Circle ~~slightly~~ ~~somewhat~~ substantially dented into the shape of a 1911 Goudy Bookletter ampersand*
===
Bidirectional discrete Fourier transforms, forward and inverse, link temporal oscillations to frequency domain ordinals. [Mapping Wheelies to the Frequency Domain](#mapwheelies) links wheelies to the frequency domain. On the other end of the inference chain, we can regard the ampersand as being plotted on an complex plane and, starting at [Figure 15](#figfifteen) and backtracking to [Figure 14](#figfourteen), obtain "temporal oscillations". With these in hand, we connect to the frequency domain via a forward Fourier transform. In principle, it seems, nothing bars finding a wheelie chain that twirls out a 1911 Goudy Bookletter Ampersand. We just have to work out the details.

To start, let an "arabesque" be any path that is topologically equivalent to a circle. Hijack the measure of angular displacement along a circle's circumference to also appraise the relative travel along a circle-like path. 180° (née π) is relatively half way around, whether in millimeters or miles.

With that, we then measure the complex coordinates of a point traveling uniformly along such a path. As it travels, it generates periodic signals with real and imaginary components ( [Figure 14](#figfourteen) ). Taking the forward discrete Fourier transform of these give rise to frequency domain ordinals that are commesurate with the periodic signals and, by extension, the arabesque.

So far, so good: we've connected the arabesque's frequency domain image to its temporal path. From there we might consider running [Mapping Wheelies to the Frequency Domain](#mapwheelies) backwards — somehow — separating wheelie sums out into the wheelies themselves.

That, for the moment, may engender a certain angst. Are there specific, unique, wheelie chain solutions coupled to each frequency domain image? Do we have to find the _right_ wheelie chain?

[Mapping Wheelies to the Frequency Domain](#mapwheelies) suggests otherwise. That scheme plots ordinals in the frequency domain arising from summed wheelie orientations and rotation rates, and there are any number of ways to add terms for particular sums: get 7 from 6 + 1. Or 4 + 3. It is certainly possible to find cases where alternate wheelie chains lead to the same frequency domain image. Indeed, consider wheelie chain _Xn_:

|- wheelie | radius (_r_)| orientation (_θ_)| spin (_±ω_)|_Σθ_|_Σω_|_r·cos(Σθ)_|_i·r·sin(Σθ)_
| *   1* | *   2* | *  3* | *  4* | *  5* | *  6* | *     7* | *     8*
|X₀|0.50000|30°|+1|30°|+1|0.43301|0.25000
|X₁|0.50000|15°|+2|45°|+3|0.35355|0.35355
|X₂|0.12500|30°|2n-7|75°|2n-4|0.03235|0.12074
|X₃|0.25000|15°|+3|90°|2n-1|0.00000|0.25000

Or _Yn_:

|- wheelie | radius (_r_)| orientation (_θ_)| spin (_±ω_)|_Σθ_|_Σω_|_r·cos(Σθ)_|_i·r·sin(Σθ)_
| *   1* | *   2* | *  3* | *  4* | *  5* | *  6* | *     7* | *     8*
|Y₀|0.50000|30°|+1|30°|+1|0.43301|0.25000
|Y₁|0.25000|60°|2n-2|90°|2n-1|0.00000|0.25000
|Y₂|0.50000|314°|+4|44°|+3|0.35967|0.34733
|Y₃|0.12500|32°|2n-7|76°|2n-4|0.03024|0.12129

_Wn_, _Xn_, _Yn_ are different chains. Yet, running each through [Mapping Wheelies… ](#mapwheelies) result in the same frequency domain image. Compare columns (5) and (6) among the three chains. The aggregates _Σθ_ and _Σω_ are all the same, except for order of terms, and plot the same frequecy domain image. All would give rise to the loop-de-loop arabesque of [Figure 15](#figfifteen).

This eases our burden. Our search for wheelie chains that could generate 1911 Goudy Bookletter ampersands becomes one of finding _any_ wheelie chain that sums to the 1911 Goudy Bookletter Ampersand frequency domain image.

One way to generate a wheelie chain is from pair-wise differencing of frequency domain ordinals, a complementary operation to summing wheelie chains. The idea stems from wheelie addition used to plot values at ordinals. Put this idea in reverse: difference ordinals to find wheelies.

In wheelie addition, as we walk along the chain, we accumulate a wheelie's orientation and rotational rates to running sums _Σθ_ and _Σω_, employ the aggregate angle _Σθ_ to decompose wheelie length _r_ into its real and imaginary components and add these to the complex value at ordinal _Σω_. Perforce, the just-accumulated wheelie constitutes the _difference_ between the present value at ordinal _Σω_ and the value from the previous step. To recover wheelies, we difference ordinals — _that_ is the process of separating out wheelies.

In particular, we take the difference of the two ordinals, extracting the rotation rate of the wheelie, _ω_. Likewise we rewrite the values in polar form — argument angle _θ_ and modulus _r_ — and take the difference of the argument angles. This extracts the orientation of the wheelie,  _θ_. The length of the wheelie equals the modulus, _r_ of the first term of the subtraction (minuend).

So we can separate out a wheelie belonging to _some_ chain, but that may belong to any number of chains. To extract all the wheelies of a _particular_ chain, we first put the non-zero ordinals of a frequency domain image in any order: some _permutation_. This order then governs how we sequence the taking of differences. To extract the particular wheelie chain corresponding to a permutation, we take the pairwise difference of adjacent ordinals in the permutation. Thus for permutation _a_ of _n_ non-zero ordinals:

= figseventeen
===

$$
\begin{matrix}
A_{0_{(\measuredangle \omega + \theta)}} & = & a_{0_{(\measuredangle \omega + \theta)}} \\
A_{1_{(\measuredangle \omega + \theta)}} & = & a_{1_{(\measuredangle \omega + \theta)}} - a_{0_{(\measuredangle \omega + \theta)}} \\
A_{2_{(\measuredangle \omega + \theta)}} & = & a_{2_{(\measuredangle \omega + \theta)}} - a_{1_{(\measuredangle \omega + \theta)}} \\
& \vdots & \\
A_{k_{(\measuredangle \omega + \theta)}} & = & a_{k_{(\measuredangle \omega + \theta)}} - a_{k-1_{(\measuredangle \omega + \theta)}} \\
& \vdots & \\
A_{n_{(\measuredangle \omega + \theta)}} & = & a_{n_{(\measuredangle \omega + \theta)}} - a_{n-1_{(\measuredangle \omega + \theta)}} \\
\end{matrix}
$$

*11. Finding wheelie chain _An_ through permutation _a_ of frequency domain ordinals*
===

with A₀ constituting the root wheelie. Through such pairwise differencing, any frequency domain ordinal _ak_ can be related to a wheelie sum: _ak_ = Ak + Ak-1 + … + A₁ + A₀, by back-substituting up the chain in [Figure 17](#figseventeen):

Our overall game then runs along these lines:

|      1.  |Digitize the path: obtain discrete samples of the path at (presumably) equal time steps.
|      2.  |Find the frequency domain image of these samples through the discrete forward Fourier transform.
|      3.  |Compute the wheelies through any pair-wise differencing chain of some permutation _a_ of the non-zero ordinals in the frequency domain image.

While, in principle, we could use any permutation of non-zero ordinals, there are both whimsical and practical aspects of differencing "from the origin to the Nyquist rate."

= figeighteen
===
| ![spectralpermutation](images/spectralpermutation.svg)
|*18. Selection order for alternate clockwise and counterclockwise wheelies, large to small magnitude (usually...)*
===

In the vast majority of transformed digitized paths, the ordinals near the origin _ω₀_ have the largest magnitudes; these decrease in progression along the abscissa to the Nyquist Rate. In accordance with the permutation of [Figure 18](#figeighteen), we walk this progression down the abscissa, selecting first large, low-frequency ordinals, then the smaller, high-frequency ones. Whimsically we also alternately select clockwise and counterclockwise ordinals.

Next, we take ordinal differences, these separate out the wheelie chain encoded by the permutation, one that reproduces the input path, following the pair-wise differencing scheme illustrated in [Figure 17](#figseventeen).

'mkwheelielist', found in 'svgtowheelie.gmic', follows the pairwise-differencing scheme of a permutation that approaches the Nyquist Rate from both ends of the frequency domain. Details may be found in the script comments below and in [Path To Wheelie Annotations](#pathtowheelie). 'mkwheelielist' develops a text string of trios _r_, _θ_ and  _±ω_, one for each ordinal difference, returning it in status.


??? svgtowheelie.gmic
~~~
  1 #@cli svg2wheelie : "file",_density,_wheeliecount
  2 #@cli : Generate wheelie triplets from samples of an SVG path. Requires
  3 #@cli : Python 3.x and python module svgpathtools by Andrew Port
  4 #@cli : (mathandy) et al. https://github.com/mathandy/svgpathtools.
  5 svg2wheelie:
  6 # Sample a closed Structured Vector Graphics (SVG) path at regular
  7 # intervals and from that, estimate the orientations, revolutions and
  8 # radii of a chain of wheelies, a.k.a. "epicycles" required to trace
  9 # that path. (1) path to an SVG file. Currently expects one defined
 10 # path, others are ignored. (2) Resolution sets the number of samples at
 11 # powers of two. Resolution → 8 → 2⁸ → 256 samples. Defaults to 10
 12 # (1,204 samples) (3) Limit the number of wheelies to the given
 13 # number. Defaults to 16.
 14
 15    check "isfile('${1}') &&
 16           isint(${2=10}) &&
 17           ${2}>0         &&
 18           isint(${3=16}) &&
 19           ${3}>2
 20          "
 21    fname=$1
 22    res=$2
 23    wcnt=$3
 24    normdiv=1
 25    svg2plots $fname,$res
 26    split. y
 27    fft[-2,-1]
 28    append[-2,-1] c
 29    name. spectral
 30    div[spectral] {w#$spectral}
 31    mkwheelielist[spectral] $wcnt
 32    wlist=${}
 33    rm.
 34
 35 #@cli mkwheelielist : wheelie_count
 36 #@cli : Selected image is a 2n,1,1,2 frequency domain map
 37 #@cli : ('spectral') for a Nyquist Sampling rate of n, a
 38 #@cli : count of pixels. Image from an forward discrete
 39 #@cli : Fourier transform of path samples (fft) with reals
 40 #@cli : occupying channel 0 and imaginaries occupying
 41 #@cli : channel 1. (1) wheelie_count: Limit the number of
 42 #@cli : wheelies to the given number. Defaults to 16.
 43 mkwheelielist :
 44    name. spectral
 45    check isint(${1=16})" && "${1}>2
 46    wcnt=$1
 47
 48 # Clear zero frequency, eliding any offset from
 49 # the complex plane origin. As a consequence, the
 50 # root wheelie originates at the origin.
 51
 52
 53    -set[spectral] 0,0,0,0,0
 54    -set[spectral] 0,0,0,0,1
 55
 56    # Image for dynamic array (da) storage of frequency
 57    # domain ordinals
 58
 59    -input 0
 60    -name. coefficients
 61
 62    # Scan spectral image for non-zero ordinals, as many
 63    # can be zero-length and have no bearing on the
 64    # arabesque. Setting wfound to the count of
 65    # non-zero, meaningful coeffiecients; the
 66    # coefficient image acquires the meaningful
 67    # coefficients, in polar form. Scan alternately down
 68    # the counterclockwise (m%2==0) and clockwise
 69    # (m%2!=0) portions of the frequency axis, toward
 70    # the Nyquist Sampling Rate mid-point. 'o' obtains
 71    # the rotational rate in each loop; 'j' is the index
 72    # to the currently assayed ordinal — it alternates
 73    # between clockwise and counterclockwise indices;
 74    # 'm' is the loopcounter.
 75
 76    wfound={">
 77             wc=get('wcnt',0,0);
 78             sz=0;
 79             repeat(2*wc,m,
 80                 sw=w#$spectral;
 81                 if(
 82                       m%2==0,
 83                       j=int(m/2)+1;
 84                       o=j,
 85                       j=sw-(int(m/2)+1);
 86                       o=-(int(m/2)+1)
 87                   );
 88                 rad=norm2(I(#$spectral,j,0));
 89                 if(rad>0,
 90                       ang=atan2(
 91                                  i(#$spectral,j,0,0,1),
 92                                  i(#$spectral,j,0,0,0)
 93                                );
 94                       ang=rad2deg(ang);
 95                       ang<0?ang=ang+360;
 96                       da_push(#$coefficients,[rad,ang,o])
 97                   );
 98                   );
 99             da_size(#$coefficients)
100            "}
101    -if $wfound
102
103    # The coefficient image may be manipulated as an
104    # image as well as a dynamic array; crop the
105    # penultimate and last pixel, containing the array
106    # length counter. The remainder of the array
107    # contains a permutation of non-zero
108    # coefficients. In this fill operation, we pair-wise
109    # difference them to separate out wheelies. By
110    # virtue of our "ends-to-the-middle" scan, we have
111    # prepared a permutation from which the slowest
112    # rotating wheelies are on the root end of the
113    # chain, alternating clockwise and counterclockwise
114    # rotating wheelies.
115
116       -crop[coefficients] 0,0,0,{$wfound-1}
117       -fill[coefficients] "<
118                              y==0?I:
119                              [
120                               i(0,y,0,0),
121                               i(0,y,0,1)-i(0,y-1,0,1),
122                               i(0,y,0,2)-i(0,y-1,0,2)
123                              ]
124                           "
125
126    # Turn negative angle orientations 360° to situate
127    # them between zero and three-sixty degrees.
128
129    -fill[coefficients] ">if(c==1,if(i<0,i+360,i),i)"
130    -fi
131
132    # Permute coefficient image in such a way as to
133    # order the data stream in magnitude, orientation
134    # and rotational rate triplets, as expected by
135    # wheelie plotters. Returned as a status string.
136
137    permute[coefficients] xczy
138
139    wheelie={crop(#$coefficients)}
140    -remove[coefficients]
141    -status $wheelie
142
143 #@cli svg2plots : "file",_resolution
144 #@cli (1) Retrieve the first path in the SVG 1.1 $file
145 #@cli argument and render it (2) at the indicated
146 #@cli resolution, a power of 2: $_resolution = 8 → 2⁸ → 256.
147 #@cli Resolution defaults to 10; paths are plotted
148 #@cli with 1,204 points.
149 svg2plots:
150    check "isfile('${1}') && isint(${2=10}) && ${2}>0"
151
152    # Python helper writes plots to a text file.
153    # We furnish a temporary file to receive its
154    # output.
155
156    -file_rand
157    outfile=${}
158    fname=$1
159    res=$2
160
161    # Assume a script subdirectory containing python helper
162    # See svghelper.py for details.
163
164    helpercommand="python scripts/svghelper.py \
165                   --normalize                 \
166                   --density "$res"            \
167                   --output "$outfile" "$fname
168
169    -exec $helpercommand
170    -if !isfile('$outfile')
171       error "Could not process "$outfile"!"
172    -fi
173    -input_csv $outfile,0
174    -delete $outfile
175    -permute. yxzc
~~~

???

= pathtowheelie
### Path To Wheelie Annotations

??? Path-to-Wheelie Annotations
|  __Line__  |  __Remark__  
|  **5-35** |'svg2wheelie' is a wrapper script that invokes, in succession, 'svg2plots', see **143,** and 'mkwheelielist', see **35**. Its arguments are (1) a path to an '.svg' file, (2) a plotting density and (3) a wheelie count. Plotting density is taken as a a power of two and resolves to the number of plotting points: 'density' → 9 → 2⁹ → 512 requests a path rendering of five hundred and twelve plots. The next number up, 10, requests 1,024 plots, and so on. 'wheeliecount' limits the number of computed wheelies. In effect, this argument acts as a lowpass filter, eliding the smaller, faster rotating wheelies toward the tip, retaining the larger, slower wheelies toward the root. A limit to sixteen wheelies can still give rise to output paths that are recognizably like the input path. The command returns a parameter list of wheelie triplets: _r_, _θ_, _±ω_, as its status; Creating a pipeline variable from status substitution 'wlist=${}' is the typical next step. Being a wrapper, 'svg2wheelie' prepares arguments for 'svg2plots' and 'mkwheelielist.' It's main internal activity, **26-30**, entails transforming spatial plot points to a frequency domain image, from which 'mkwheelielist' generates a wheelie chain.
|  **35-141** |The 'mkwheelielist' selection decorator should reference a one dimensional frequency domain image of complex coordinates, typically a product of ''-fft'' that has been appended along the spectral axis. First, it clears ω₀ explicity to ensure that the arabesque is origin-centered. Second, it constructs a permutation where low rotational rate, likely large modulii, ordinals precede smaller and faster elements, culling any with a modulus of exactly zero, and alternately selecting ordinals from the counter-clockwise and clockwise regions of the image. See **76-100**. Finally, 'mkwheelielist'  pair-wise differences the ordinals, separating out the wheelies; see **103-141**.
|  **76-100** |'mkwheelielist' accumulates non-zero ordinals in a [dynamic array](https://gmic.eu/reference/mathematical_expressions.html#dynamic_arrays), backed by the 'coefficients' image, created for this purpose at **59-60**. This work takes place in the context of a math expression nominally designed to report on the number of non-zero ordinals found in the frequency domain image. The first part of the expression derives a frequency domain index, 'j' from loop counter 'm' that alternately selects from counterclockwise or clockwise regions of the frequency domain image. If the currently indexed ordinal has a non-zero modulus, _r_, the second part of the expression computes the argument angle, _θ_. The third piece of data needed to specify a wheelie, rotational rate, _±ω_, derives in a fashion similar to the frequency domain index; as indexing proceeds from the the ends of the frequency domain image to the middle, '±(m/2)+1' increments through rotational rates _±ω_. 'da_push()' inserts the _r_, _θ_ and _±ω_ components into the dynamic array. These data do not yet identify a wheelie in the chain; differencing the angular components, _θ_ and _±ω_ of this and adjacent ordinals in the permutation separate out those wheelies constituting the chain. See **103-141**.
|  **103-141** |The third section of the math expression separates out the wheelies constituting the chain, this through a pair-wise differencing iteration as illustrated in [Figure 17](#figseventeen). Though the 'coefficients' image serves as a backing store for dynamic arrays, it remains on the image list and assessible to ''-fill'' math expression arguments; it is through a ''-fill'' math expression argument that coefficients placed on the dynamic array stack are pair-wise differenced, separating out the wheelie chain. A second ''-fill'' command takes another math expression argument to ensure that all wheelie orientations fall in the range '[ 0,…,360° ]'. Having served its purpose as a container, 'mkwheelielist' removes the 'coefficients' image.
|  **143-175** |'svg2plots' is a path digitizer. Its particular approach, digitizing Structured Vector Graphics (SVG) paths, relies on a helper script, 'svghelper.py' to process '.svg' files. That helper script should reside in a directory on your 'PATH'. The care and feeding of shell paths are operating system dependent and off-topic here, but details may be found in [Exec Cheat](https://gmic.eu/tutorial/exec_cheat.html), which walks through 'svghelper.py' in its role as a G'MIC helper file. 'svg2plots' remit is to set up the helper script: creating a temporary file to receive digitized points from the helper, setting the plotting density and requesting scale-independent, normalized plot points. 'svg2plots' confines error checking to whether the requested temporary file exists, aborting if it does not. ''-exec'' furnishes its own error message as well. With success, the temporary file has numeric text strings, each plot datum represented with an floating point x-coordinate, a separating comma, a floating point y-coordinate and a terminating line feed.This layout is intended for G'MIC's ''-input_csv'' command. When its '_read_data_as' parameter is set to zero, that command produces a 2 × _<plot count>_ × 1 x 1 image which ''-permute'' "lays it on its side": a _<plot count>_ × 2 × 1 x 1 image. Row zero of this image consists of the real components of the plots, row one consists of the imaginary components. Typically, subsequent pipeline commands ''-split'' this image on the y axis; the two resulting images become inputs to the forward discrete Fourier transform: ''-fft'' to obtain frequency domain ordinals expressing the frequency distribution of the data set.

???

= wheelieanimations
## Wheelie Animations

In principle, the status string generated by 'svg2wheelie' may be passed to plotters like [wheelie](#wheelielist), but such would underwhelm. That plotter's remit is to draw arabesques from whimsically chosen wheelies. From wheelies derived from arabesques that look like ampersands it draws ampersands, which is imperfectly astounding, as the outcome looks like the given, unchanged.

What is missing, of course, are the gyrations of the wheelies themselves, so seemingly chaotic but, in fact, a choreographed ballet laid out with rocket-launch precision. The frequency domain of ordinals constitutes the master plan. Each pair-wise difference between ordinals dictates to wheelies but three things: length (_r_), orientation (_θ_), and rotation rate (_ω_), a one-time decree that fully determines how the wheelie is to turn just so through time. This may be unremarkable in itself, but a long chain of wheelies, each programmed in such an unremarkable way, can collectively give rise to a wholly remarkable pirouetting, from which a 1911 Goudy Bookletter Ampersand emerges, perhaps, or an _art nouveau_ spectacular. So we need a wheelie plotter that illuminates this dance. 'wheelie_anim', found in 'wheelie_anim.gmic' module, takes a list of wheelie trios, either written by hand or generated by 'svg2wheelie', and plots both the arabesque and the wheelie chain generating it.

= fignineteen
===
![ampersand_anim](images/ampersand_anim.mp4)
|*19. 1911 Goudy Bookletter Ampersand via 1,024 wheelies*
===

 Unlike 'wheelie', 'wheelie_anim' works with a selection decorator so that certain features of the animation may be set '[ <drawingcanvas>, <multiplier>, <background> ]' images set the animation image size, fader rates and a predrawn backplate. A typical animation pipeline follows:
~~~
$ gmic                                                                       \
    -command svgtowheelie.gmic                                               \
    -command wheelie_anim.gmic                                               \
    -svg2wheelie "ampersand_circ.svg",9,256                                  \
    wlist=\${}                                                               \
    -input 600,600,1,3,'lerp([220,220,233,255],[160,240,255,255],y/(h-1))'   \
    -name. background                                                        \
    -input[-2] '(0.92^0.92^0.92^0.995)'                                      \
    -name.. multiplier                                                       \
    -input[-3] [background],[background],[background],4                      \
    -name... arabesque                                                       \
    -wheelie_anim[arabesque,multiplier,background] 300,0.5,\$wlist           \
    -remove.                                                                 \
    -resize 50%,50%,1,3,5                                                    \
    -output ampersand_anim.mp4,30,H264
~~~

??? wheelie_anim
~~~
  1 #@cli wheelie_anim : frames-per-rev,scale,r_0,phase_0,rot_rate_0,…
  2 #@cli : Compose arabesque rotational animation using a three image
  3 #@cli : selection: [-3] Transparent, optionally pre-drawn, image for
  4 #@cli : the arabesque. [-2]: four channel fader multiplier and [-1]:
  5 #@cli : background image. The number of wheelies follows from the
  6 #@cli : argument triplet count following "scale". A single triplet
  7 #@cli : of three arguments specifies length, r, orientation θ and
  8 #@cli : rotation rate of one wheelie. It is an error if the argument
  9 #@cli : list, "less frames-per-rev" and "scale" is not divisible by
 10 #@cli : three. Replaces selection with (1) an animation image
 11 #@cli : sequence of a length equal to the frames_per_revolution
 12 #@cli : argument, and (2) the arabesque transparency reflecting the
 13 #@cli : last frame state, suitable for use as a pre-drawn image for
 14 #@cli : successor arabesque animations.
 15
 16 wheelie_anim:
 17    # wheelie: a segment of a particular (1) radius, (2) phase
 18    # angle (orientation) and (3) discrete angular velocity - a
 19    # relative integral number of revolutions per some unspecified
 20    # base interval, perhaps however long one revolution
 21    # takes. Wheelies chain together, the tail of one situated at
 22    # the head of its antecedent. The first wheelie of the chain
 23    # centers at the origin and the last has, instead of another
 24    # wheelie, an attached marking pen. Thus, the entire chain
 25    # draws an "arabesque" as the individual wheelies rotate at
 26    # their respective angular velocities from their initial
 27    # orientations. This script animates such.
 28    #
 29    # This script renders arabesques "traditionally": Each wheelie
 30    # has radial, phase and angular velocity components.  For each
 31    # increment, and, for each wheelie, apply the angular velocity
 32    # increment, rotating the wheelie, then, with all wheelies
 33    # rotated, plot the endpoint.
 34
 35    emsg="
 36       Select three images, to wit: [-3]: Transparent, optionally
 37       pre-drawn, image for the arabesque. [-2]: four channel fader
 38       multiplier and [-1]: three channel background image; 1:1
 39       aspect ratio works best."
 40
 41    -if size([$[]])!=3
 42       -error $emsg
 43    -fi
 44    -name... arabesque
 45    -name..  multiplier
 46    -name.   background
 47    -resize[multiplier] [arabesque],[arabesque],[arabesque],[arabesque],1
 48    -remove_opacity[background]
 49    -store[multiplier] multiplerimage
 50    -local[arabesque,background]
 51       # Fetch an arbitrarily long argument list to $a0, $a1, …, $an
 52       $=a
 53
 54       # Expect argument one as initial frames per revolution,
 55       # Expect argument two as canvas image scaler
 56       # followed by data triplets: radius, r, phase angle, θ,
 57       # angular velocity, ω.
 58
 59       -check {!(($#-2)%3)}
 60
 61       # Initial argument: frame count per revolution
 62       -check "isint($a1) && $a1>0"
 63       frames_per_rev=$a1
 64       -check isnum($a2)" && "$a2>0
 65       scaler=$a2
 66
 67       # scaling width is the smallest dimension
 68       sw={min(w,h)/2}
 69       -if $sw%2==0
 70          sw+=1
 71       -fi
 72
 73       # Circles argument vector: For each wheelie, compose
 74       # radius and phase arguments into a homogeneous
 75       # transform. In the animation loop, we compose this
 76       # with the "angular tick dependent" (atk) rotational
 77       # transform to plot the wheelie in an generic
 78       # plotting space.
 79
 80       wcnt={round(($#-2)/3,1,-1)}
 81       -input $wcnt,1,1,12
 82       -name. args
 83
 84       # Iterate over argument vector. For each triplet –
 85       # representing a wheelie circle – Fetch radius (rad:
 86       # r), phase angle (ang: θ) and angular velocity (sf:
 87       # ±ω) parameters.
 88
 89       -repeat $#-2 j=$>
 90          -if   $j%3==0 # get radius
 91             rad=${a{3+$j}}
 92             -check isnum($rad)" && "$rad>=0
 93             -set[args] $rad,{round($j/3,1,-1)},0,0,0
 94          -elif $j%3==1 # get angle, degrees
 95             ang=${a{3+$j}}
 96             -check isnum($ang)" && "$ang>=0" && "$ang<=360
 97             -set[args] $ang,{round($j/3,1,-1)},0,0,1
 98          -else         # get ω and set spectral coefficient
 99             sf=${a{3+$j}}
100             -set[args] $sf,{round($j/3,1,-1)},0,0,2
101          -fi
102       -done
103
104       # Iterate over argument image, each 12 channel pixel
105       # representing one wheelie. The first three channels
106       # contain wheelie radius, phase angle and radial
107       # velocity. Compose a homogeneous matrix
108       # transforming the origin to the tip of the wheelie
109       # radius, a radial translation and phase
110       # rotation. Populate the nine remaining channels
111       # with this matrix.
112
113       -fill[args] ">
114                      CPX=I;
115                      orot=rot(          # phase rotation
116                                [0,0,1],
117                                deg2rad(CPX[1])
118                              );
119                      xlat=eye(3);
120                      xlat[2]=CPX[0];    # translation
121                      [                  # args+rot & xlation
122                        CPX[0,3,1],      # arguments
123                        mul(orot,xlat,3) # time-independent
124                      ]                  # matrix
125                   "
126       -permute[args] cyzx
127       -store[args] circles
128
129       # Partial screenspace transform.
130       ssxfrm={">
131                  specw=get('sw',0,0);
132                  scaler=get('scaler',0,0);
133                  id=eye(3);
134                  id[0]=specw/scaler;
135                  id[2]=specw;
136                  id[4]=-specw/scaler;
137                  id[5]=specw;
138                  id"}
139
140       # Homogeneous position vectors for plotting
141       # initial/final segments
142       tracerim={vector3([0,0,1])}
143       firstpt={vector3([0,0,1])}
144
145       # Transparent image to plot wheelies themselves
146       -input [arabesque],[arabesque],[arabesque],[arabesque]
147       -name. wheelplot
148
149       # Stash background for duplication in loop
150       +store[background] back
151
152       # Animate arabesque: 'angular tick dependent' → atk
153       atk=0
154       -repeat $frames_per_rev k=$>
155          atk={2*pi*($k/($frames_per_rev-1))}
156          -local[arabesque,background,wheelplot]
157              -input $multiplerimage
158              -mul[arabesque,multiplier]
159
160              # Plot wheelie indicators: rotate wheelies
161              # by their respective angular velocity
162              # increments, compose this rotation into
163              # the pre-computed phase,
164              # radial-displacement transform from the
165              # argument image, compose with screenspace
166              # transform and plot via polygon()
167
168              -eval[wheelplot] ">
169              begin(
170                 wcnt=get('wcnt',0,0);
171                 omega=get('atk',0,0);
172                 fpr=get('frames_per_rev',0,0);
173                 ik=get('k',0,0);
174                 fpt=get('firstpt',3,0);
175                 trc=get('tracerim',3,0);
176                 pp=vector"{3*($wcnt+1)}"([0,0,1]);
177                 circs=get('circles',"{12*$wcnt}",0);
178                 repeat(
179                      wcnt,k,
180                      idx=wcnt-k-1;
181                      rbradx=mul(
182                                  rot(
183                                      [0,0,1],
184                                      circs[12*idx+2]*omega
185                                     ),
186                                  circs[12*idx+3,9,1],
187                                  3
188                                );
189                      repeat(
190                              k+1,j,
191                              foo=rbradx*pp[3*(k-j),3];
192                              pp[3*(k-j)]=foo[0];
193                              pp[3*(k-j)+1]=foo[1];
194                              pp[3*(k-j)+2]=foo[2];
195                            )
196                       );
197                 ssx=get('ssxfrm',9,0);
198                 repeat(
199                        wcnt,k,
200                        p0=ssx*pp[3*(k),3];
201                        p1=ssx*pp[3*(k+1),3];
202                        polygon(#$wheelplot,
203                                 -2,
204                                 [p0[0,2],p1[0,2]],
205                                 1,
206                                 0xffffffff,
207                                 [115,160,205,255]
208                               );
209                        ellipse(#$wheelplot,
210                                p0[0,2],
211                                1,
212                                1,
213                                0,
214                                1,
215                                [230,90,45,255]
216                               );
217                      );
218                 plt=ssx*pp[0,3];
219                 ik>0?
220                    polygon(#$arabesque,
221                            -2,
222                            [plt[0,2],trc[0,2]],
223                            1,
224                            0xffffffff,
225                            [255,200,100,255]
226                           ):
227                    store(plt,'firstpt',3,1,1,1);
228                 store(plt,'tracerim',3,1,1,1);
229                 ellipse(#$wheelplot,
230                         plt[0,2],
231                         2,
232                         2,
233                         0,
234                         1,
235                         [230,90,45,255]
236                        );
237                 ik==(fpr-1)?
238                    polygon(#$arabesque,
239                            -2,
240                            [fpt[0,2],plt[0,2]],
241                            1,
242                            0xffffffff,
243                            [255,200,100,255]
244                           )
245                   )
246                               " # end of eval
247              -blend[background] [arabesque],alpha
248              -blend[background] [wheelplot],alpha
249              -mul[wheelplot] 0
250              -mv[background] 0
251              -name[background] frame-$k
252          -done # local environment
253          -input[-2] $back
254       -done # repeat frames per 360° revolution
255       -rm[wheelplot,background]
256    -done # local argument environment of [arabesque,background]
257
258 #@cli durga : _radius_0,_phase_0,_angular_velocity_0,…
259 #@cli : Sequence a series of animations by successively adding
260 #@cli : wheelies, one at a time, starting with the initial wheelie
261 #@cli : that just generates a circular arabesque. Furnish any number
262 #@cli : of wheelie triplets in the argument list, or leave that list
263 #@cli : empty; durga will generate a list of five randomly composed
264 #@cli : wheelies. Selected image sets the animation size and
265 #@cli : background composition. Framerate is fixed at 24
266 #@cli : frames/second. Select the background image to set animation
267 #@cli : frame size. Arguments should be in groups of three: radius,
268 #@cli : phase, angular velocity.
269
270 durga : -skip "${1=}"
271    emsg="Select the background image to set animation frame size.
272          Arguments should be in groups of three: radius, phase,
273          angular velocity."
274    frames={24*6}
275    -local[]
276       is_arg={isnum("$1")}
277    -onfail
278       is_arg=0
279    -done
280    -if size([$[]])==0
281       -input 300,300,1,3,lerp([200,200,230],
282                               [230,200,200],
283                   y/(h-1)
284                  )
285    -fi
286
287    # Create, get construction images
288    -name. background
289    -remove_opacity[background]
290    -input[-2] (0.99^0.94^0.92^0.998)
291    -name.. multiplier
292    -input[-3] [background],[background],[background],4
293    -name... arabesque
294
295    # Wheelie arguments?
296    -if $is_arg>0
297       -if $#%3==0
298          $=a
299          wcnt={$#/3}
300          ra=''
301          ph=''
302          av=''
303          -repeat $# j=$>
304             -if $j%3==0 # get radius
305                    rad=${a{1+$j}}
306                -check isnum($rad)" && "$rad>=0
307                ra={[[$ra],[$rad]]}
308             -elif $j%3==1 # get angle, degrees
309                ang=${a{1+$j}}
310                -check isnum($ang)" && "$ang>=0" && "$ang<=360
311                ph={[[$ph],[$ang]]}
312             -else         # get ω and set spectral coefficient
313                sf=${a{1+$j}}
314                -check isint($sf)
315                av={[[$av],[$sf]]}
316             -fi
317          -done
318          ra={[$ra][1,size([$ra])-1,1]}
319          ph={[$ph][1,size([$ph])-1,1]}
320          av={[$av][1,size([$av])-1,1]}
321       -else
322          -error $emsg
323       -fi
324    # No arguments. Make up our own. Fixed at
325    # 5 wheelies, no phase displacement.
326    -else
327       wcnt=5
328       ra={u(vector$wcnt(1))}
329       ph={vector$wcnt(0)}
330       av={"
331              rad=u(k=vector$wcnt(1.5))-0.75;
332              sgn=2*round(rad,1,1)-1;
333              mag=sort(abs(5*rad),1);
334              rmag=round(mag/min(mag),1,1);
335              rmag*sgn
336          "}
337    -fi
338
339    args=""
340    +store[multiplier,background] animback
341    -repeat {$wcnt} i=$>
342       -local[arabesque,multiplier,background]
343          acnt={size([$args])}
344          wcount={$acnt/3}
345          newargsz={$acnt+3}
346          args={"
347                  RA=get('ra',$wcnt,0);
348                  PH=get('ph',$wcnt,0);
349                  AV=get('av',$wcnt,0);
350                  RL=RA[0,$wcount+1,1];
351                  scale= 1.0/sum(RL);
352                  RL=round(RL*scale,0.01,0);
353                  NAR=vector$newargsz(0);
354                  repeat($wcnt+1,k,
355                         NAR[3*k]=RL[k];
356                         NAR[3*k+1]=PH[k];
357                         NAR[3*k+2]=AV[k]
358                        );
359                  NAR
360               "}
361          -wheelie_anim[arabesque,multiplier,background] $frames,1.125,$args
362          -input $animback
363       -done
364    -done
365    -remove[arabesque,multiplier,background]

~~~

???

Alas, the primary difference between 'wheelie_simple.gmic' and 'wheelie_anim.gmic' are the inclusion of animation loops. G'MIC animation is worth a Cookbook article or more in its own right, and should we persue it in detail here we will wander too far into the weeds.

In broad strokes, the animation loop technique harnessed in 'wheelie_anim.gmic' is a frame generator that draws a time-slice frame for each loop iteration. Frame generators leave a large sequence of images on the list — but not a single image composed of a lot of slices. the ''-output'' command is sensitive to file extensions for video formats. Depending on particular video formats, the video format file name given as an argument to '-output' can take a list of comma separated qualifiers; you could manage specifics of the output such as the video frame rate or compression format. For example, this undecorated '-output' command:

~~~
 -output ampersand_anim.mp4,30,H264
~~~

will incorporate _every_ image on the list into a thirty frame-per-second animation, the video following the [H264 video compression standard](https://en.wikipedia.org/wiki/Advanced_Video_Coding). See [Input/Output Properties](https://gmic.eu/reference/input_output_properties.html#top) for the qualifiers appropriate for each video format.

= postscript
## PostScript
When finding wheelies to plot various dented circles, our feet land on a well-trodden path. Going back a decade or more, there have been eruptions of [fantastic constructions](https://www.youtube.com/watch?v=-qgreAUpPwM) of gyrating arrows that do etch-a-sketch things: drawing birds, flowers, even portraits of Jean-Baptiste Joseph Fourier or Santiago Ginnobili's [Homer Simpson](https://www.youtube.com/watch?v=QVuU2YCwHjw).

Probably the best adjunct to this Beginner's Cookbook is two Grant Sanderson (3blue1brown) videos [But what is the Fourier Transform? A visual introduction.](https://www.youtube.com/watch?v=spUNpyF58BY) and its companion [But what is a Fourier series? From heat flow to drawing with circles](https://www.youtube.com/watch?v=r6sGWTCMz2k).

Our wheelie is a pseudonym for an _epicycle_ in these other ouvres. If you wish to google your way to other approaches, the search terms [epicycle fourier](https://www.google.com/search?q=fourier+epicycles&client=firefox-b-1-e&sxsrf=APq-WBsmUcpj0VazeDX0ypEoGPIb0xKX3w%3A1649089042403&ei=EhpLYvShGOukptQPhKqAuAE&ved=0ahUKEwj08sy05_r2AhVrkokEHQQVABcQ4dUDCA0&uact=5&oq=fourier+epicycles&gs_lcp=Cgdnd3Mtd2l6EAMyBAgjECcyBAgAEEMyBQgAEIAEMgUIABCGAzIFCAAQhgMyBQgAEIYDMgUIABCGAzIFCCEQoAE6BwgjELADECc6BwgAEEcQsANKBAhBGABKBAhGGABQuglYuglglBtoAXABeACAAeoBiAHqAZIBAzItMZgBAKABAcgBCcABAQ&sclient=gws-wiz#bsht=CgRmYnNtEgIIBA) provides a nice survey. In [ Epicycles, complex Fourier series and Homer Simpson's orbit ](https://www.youtube.com/watch?v=qS4H6PEcCCA) [Burkard Polster](https://en.wikipedia.org/wiki/Burkard_Polster) ( "Mathologer" ) uses Santiago Ginnobili's epicyclic rendering of Homer Simpson as a jumping off point as to what may be going on with all of those circles. [Daniel Shiffman ( aka Coding Train )](https://www.youtube.com/watch?v=MY4luNgGfms) runs through a JavaScript implementation; other implementations in other languages abound. But this is G'MIC's very own way. Enjoy.

