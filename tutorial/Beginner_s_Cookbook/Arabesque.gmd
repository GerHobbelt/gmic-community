# Arabesques
%% x "mkdir -p img" %%
%% -m scripts/wheelie_anim.gmic input 1024,1024,1,3,lerp([219,214,233],[219,187,91],y/(h-1)) durga. 1,90,1,0.125,0,7,0.5,0,-3,0.5,0,5 [-1]x48 erode_circ 3 -resize 29.3%,29.3%,1,3,5 o img/arabesque.mp4,24,H264 rm %%
%% -m scripts/wheelie_anim.gmic i 600,600,1,3,lerp([220,220,233,255],[180,180,200,255],y/(h-1)) nm. background -i[-2] (0.92^0.92^0.92^0.995) nm.. multiplier -i[-3] [background],[background],[background],4 -nm... arabesque wheelie_anim[arabesque,multiplier,background] 120,{1/3},0,0,{1/3},0,0,{1/3},0,1 erode_circ 2 rm. r 50%,50%,1,3,5 o img/simple.mp4,24,H264 rm %%
%% -m scripts/wheelie_anim.gmic i 600,600,1,3,lerp([220,220,233,255],[180,180,200,255],y/(h-1)) nm. background -i[-2] (0.92^0.92^0.92^0.995) nm.. multiplier -i[-3] [background],[background],[background],4 -nm... arabesque wheelie_anim[arabesque,multiplier,background] 120,{1/3},0,0,{1/3},0,1,{1/3},0,2 erode_circ 2 rm. r 50%,50%,1,3,5 o img/simpletoo.mp4,24,H264 rm %%
|![Arabesque](img/arabesque.mp4)\n               *"Durga's idle arabesques"*|During brief interludes, when tranquility prevails and the peoples of the world are in complete accord, Durga might take ease from her duties and find serenity through simple pursuits.\n\nIt is a small pleasure to swing a compass marker around its anchor leg, and if hands might quave arcs still run true — not that palsy ever troubles Durga, master as she is of the _chakra_ and _trishul_. And so it is hardly burdensome for her to take up compass after compass, anchor to marker, twirling each at revolutions and spreads picked through whimsy.\n\nSuch a flurry of hands and arms might astonish mortals, but for the slayer of the abominable Mahishasura it is just so many twirlings. With each added compass, the culminating marker traces ways ever more sublime, awarding Durga escalating delights. And so it goes — until demons arise. Durga must then put away her compasses and take up her arrows and bow.
= wheelie
### Wheelies
Deficient as we are in arms, we seek computerized compensations. Accordingly, let _wheelies_ model compass pairs: one end of a segment is a hinge that sticks to whatever it has been attached and the other end swings free. Chains of these emulate Durga's compass-upon-compass pile-ons.

= firstplay
With each wheelie we may:

|      1.  |set a particular radius:|      _r_
|      2.  |pick a starting orientation:|      _θ_
|      3.  |choose a signed, clockwise or counterclockwise, rotational rate:|     _±ω_

The game is to place wheelies, end-to-end, at their starting orientations and take a picture. Account for _ωt_ in all the orientations and take another picture, and so on, until the accumulated change in orientation reaches some preset.

Here is the play:

|      1.  |Root the first wheelie at the origin.
|      2.  |Hinge additional wheelies at successive free end points, perhaps setting their orientation differently or aligning them all. Do that any number of times, _or_
|      3.  |attach a marker to the rim of a terminal wheelie and take its picture.
|      4.  |Adjust the orientations to account for _ωt_ and plot again … and again, making an animation, until the accumulated adjustment equals the preset.

In animation, a wheelie's circular motion fathoms easily. Add a few more, however, and complexity strikes us dumb. The remedy for that are patterns. These, in recurrence, divide and conquer.
= figone
===
![wheeliediagram](images/wheeliewalk.svg)
*1. Walking from marker tip to the origin*
===

Paired wheelies, _antecedent_ and _successor_, provide the template. First, characterize relative motion in the locality of a wheelie pair. Then aggregate motions of pairs into larger localities — ultimately that of the whole.

Start with the penultimate and final pair. Establish a local coordinate system. Orient the antecedent to zero degrees, anchor at the local origin and tip aligned with the local _x_ axis. Now bring in the successor. It's sticky end hinges to the antecedent's tip while its own swings free.

The factors accounting for the successor's local motion are its length, _r_, and its orientation _θ + ωt_. Here, _ωt_ is the time-varying part of its orientation, the product of its rotational rate and accumulated ticks: _t = (Δt₀ + Δt₁ + … )_.

These factors bring about an [affine matrix](https://gmic.eu/tutorial/tiled_art.html#affinetransform). Such a matrix takes a point in the neighborhood of the successor's origin (_née_ antecedent's tip) through a translation by _r_ and a rotation by _θ + ωt_:
= figtwo
===

$$
\begin{bmatrix} m_x \\ m_y \\ 1 \end{bmatrix} =
\begin{bmatrix}
\-cos (\theta + \omega t) & -\-sin (\theta + \omega t) & r_x \\
\-sin (\theta + \omega t) & \-cos (\theta + \omega t) & r_y \\
0 & 0 & 1
\end{bmatrix}
\begin{bmatrix} o_x \\ o_y \\ 1 \end{bmatrix}
$$
*2. A Wheelie transform taking a point at _o_ (origin) to _m_ (tip)*
===

This matrix characterizes motion in the locality of this wheelie pair. As _Δt_ ticks off, changing _ωt_, the tip animates a circle of radius _r_; not very interesting but readily grasped.
= figthree
===
![Simple](img/simple.mp4)
*3. The locality of one wheelie pair*
===
Shift toward the root. Write a second matrix. This relates the root-ward wheelie tip to _its_ antecedent: a second circular plot. Multiply the two matrices from right to left to aggregate the motion of both.
= figfour
===
![SimpleToo](img/simpletoo.mp4)
*4. Localities of the second and third, and first and second wheelie pairs compounded together*
===
And so we go, compounding individual circular motions into wider localities. Eventually we obtain the overall motion of the terminal tip relative to the initial root. The pairwise writing of matrices and their aggregation is our divide-and-conquer play. The arabesque of the whole arises from the actions of the parts.

We mark one plot and tick _Δt_. That changes the orientation of all wheelies, of course, so we re-walk the walk, compound the adjusted matrices and plot the second mark. And again. And again… …until the preset has been reached.

After all that — we're done. All that's left is coding.

??? wheelie.gmic
~~~
  1    wheelie :
  2       # wheelie: a circle of a particular (1) radius, (2) phase angle
  3       # (orientation) and (3) discrete angular velocity - a relative
  4       # integral number of revolutions per however long one revolution
  5       # takes. Wheelies chain together, the center of one situated at 0°
  6       # on the rim of its predecessor. The first wheelie of the chain
  7       # centers at the origin and the last has, instead of another
  8       # wheelie, an attached marking pen. Thus, the entire ensemble 
  9       # draws an "arabesque" as the individual wheelies rotate at their
 10       #  respective angular velocities from their initial orientations.
 11    
 12       # Fetch an arbitrarily long argument list to $a0, $a1, …, $an
 13    
 14       $=a
 15    
 16       # Expect data triplets: radius, phase angle, angular velocity.
 17    
 18       -check "isint($a1) && !(($#-1)%3)"
 19    
 20       # Initial argument: side width (sw)
 21    
 22       sw={$a1/2}
 23    
 24       # Argument image: For each wheelie, compose radius and phase
 25       # arguments into a transformation matrix. In the generation
 26       # loop, we compose this with the angle resulting from one
 27       # angular velocity step.
 28    
 29       wcnt={int(($#-1)/3)}
 30       -input $wcnt,1,1,12
 31       -name.  args
 32    
 33       # Iterate over argument vector. For each triplet – representing a
 34       # wheelie – Fetch radius (rad), phase angle (ang) and angular
 35       # velocity (sf) parameters.
 36    
 37       -repeat $#-1,j
 38          -if   $j%3==0 # get radius
 39             rad=${a{2+$j}}
 40             -check isnum($rad)" && "$rad>=0
 41             -set[args] $rad,{round($j/3,1,-1)},0,0,0
 42          -elif $j%3==1 # get angle, degrees
 43             ang=${a{2+$j}}
 44             -check isnum($ang)" && "$ang>=0" && "$ang<=360
 45             -set[args] $ang,{round($j/3,1,-1)},0,0,1
 46          -else         # get ω and set spectral coefficient
 47             sf=${a{2+$j}}
 48             -set[args] $sf,{round($j/3,1,-1)},0,0,2
 49          -fi
 50       -done
 51    
 52       # Iterate over argument image, each 12 channel pixel representing
 53       # one wheelie. The first three channels contain wheelie radius,
 54       # phase angle and radial velocity. Compose a matrix transforming
 55       # the origin to the tip of the wheelie, a radial translation and
 56       # phase rotation. Populate the nine remaining channels with this
 57       # matrix.
 58    
 59       -fill[args] ">
 60               CPX=I;
 61               orot=rot([0,0,1],deg2rad(CPX[1])); # phase rotation
 62               xlat=eye(3);
 63               xlat[2]=CPX[0];                    # translation origin
 64               FIN=[CPX[0,3,1],mul(orot,xlat,3)]; # -to-rim, i.e.
 65               FIN                                # 'rotation & xlation'
 66                   "                              # store above in
 67                                                  # 12-channel pixel
 68       -permute[args] cyzx
 69       -store[args] circles
 70    
 71       # Screenspace transform.
 72       ssxfrm={"
 73                specw=get('sw',0,0);
 74                id=eye(3);
 75                id[0]=specw/1.5;
 76                id[2]=specw;
 77                id[4]=-specw/1.5;
 78                id[5]=specw;
 79                id
 80               "}
 81    
 82       # Draw arabesques on this image
 83       -input {2*$sw},{2*$sw},1,1
 84       -name. canvas
 85    
 86       atk=0
 87       lastpt={vector3([0,0,1])}
 88       firstpt={vector3([0,0,1])}
 89       -repeat 3*$sw,k
 90           # For each wheelie:
 91           # increment by angular velocity
 92           # find corresponding rotation matrix
 93           # compose with radial argument image, compose
 94           # with screenspace transform and plot via polygon().
 95    
 96           -eval ">
 97               const cc=$wcnt;
 98               fpt=get('firstpt',3,0);
 99               ik=get('k',0,0);
100               lpt=get('lastpt',3,0);
101               omega=get('atk',0,0);
102               specw=get('sw',0,0);
103               circs=get('circles',12*cc,0);
104               pp=vector3([0,0,1]);
105               imat=eye(3);
106               repeat(
107                     cc,k,
108                     idx=cc-k-1;
109                     imat=mul(
110                             mul(
111                                rot([0,0,1],circs[12*idx+2]*omega),
112                                circs[12*idx+3,9,1],
113                                3
114                                ),
115                             imat,
116                             3
117                             );
118                     );
119               ssx=get('ssxfrm',9,0);
120               plt=ssx*(imat*pp);
121               ik>0?
122               polygon(#$canvas,-2,[plt[0,2],lpt[0,2]],1,0xffffffff,255):
123               store(plt,'firstpt',3,1,1,1);
124               store(plt,'lastpt',3,1,1,1);
125               ik==(3*specw-1)?
126               polygon(#$canvas,-2,[fpt[0,2],plt[0,2]],1,0xffffffff,255)
127                  "
128           atk={2*pi*($k/(3*$sw-1))}
129       -done
~~~
???

= annotations
### Annotations

??? Weeds, for those wishing to go into them.
|  __Line__  |  __Remark__  
|  **14** | '$=a' A pseudo assignment. G'MIC transforms this into a series of actual assignments. This _'$-expression'_ generates an assignment sequence with the base name 'a' for however many elements on the command line there may be. '$a0' identifies the name of the script, so one could alter script behavior based on the script name. '$a1…' onward are the arguments. See [Adding Custom Commands](https://gmic.eu/reference/adding_custom_commands.html#top). There is nothing special about the base name 'a'. It could be anything: '$=fruitloops' initializes command line variables '$fruitloops0, …, $fruitloops<n>'.
|  **16-27** |We sanity-check the arguments. 'wheelie' expects '$a1' to specify the length of one side of a square drawing canvas, so anticipates that the first argument is an integer. '$#' is another _'$-expression'_; this one resolves to the number of comma-separated arguments given to 'wheelie'. Wheelie specifications occur in groups of three, _r_, _θ_ and _±ω_ so '!(($#-1)%3)' enforces arguments in triplets; it is _False_ if the number of arguments, less the first, is not evenly divisable by three. Thus, the user specifies the image size with the first argument and employs triplets of successive arguments to specify wheelies, one triplet for each.
|  **22,29** |Curly brace pairs indicate a number of possible substitutions, see [Substitution Rules](https://gmic.eu/reference/substitution_rules.html#top), and if the contents of curly braces cannot be attributed to requests for some image feature, it bottoms out to a math expression. For those new to math expressions, the encounter is a bit like falling into a rabbit hole, left-and-right curly braces ideographic of the impending cavity. Take a deep breath, grasp something solid, and remember that, above all, some kind of substitution is going on, and the source of it is the results of the math computation. In the present cases, they are the right hand sides of assignment operators that initialize pipeline variables. [Mathematical Expressions](https://gmic.eu/reference/mathematical_expressions.html#top) furnishes a complete, if terse, set of objects that make up mathematical expressions. Of the present cases, the first sets a resolution metric. '$sw' associates one unit of distance in the computation space of wheelies to a particular number of pixels, thus anchoring our relative lengths to something definite: the screen space of pixels. This resolution metric figures in a number of sizing tasks, such as scaling the number of plots necessary to draw an arabesque. Not so many for small pixel dimensions; a lot otherwise. The second derives 'circle count' – aka, the number of wheelies specified in the argument list. This is just the number of arguments dedicated to wheelie specifications, '$#-1', divided by three, because each wheelie consists of three arguments.
|  **30-51** |The 'args' image is not for display; it is an argument database. Each pixel in this "argument image" specifies aspects of one wheelie. Channels 0-2 hold _r_, _θ_ and _±ω_ and this first 'repeat…done' loop saves them for future reference; channels 3-11 are reserved for the wheelie-specific affine transforms. To reduce computations in the animation loop between **92-132**, we break computation into "stage 1" and "stage 2" phases. "Stage 1" precomputes matrices with only _r_ and _θ_ elements, which are time-independent. "Stage 2" occurs at every _Δt_ tick, but only needs to composite a pure rotation into the "stage 1" matrix, reflecting the time-dependent rotation angle _ωt_.
|  **53-70** |'fill' iterates over the 'args' image, computing the "stage 1" affine transformations for each wheelie. Storage for each wheelie occupies a twelve channel pixel of the image; In each step of the fill, the current pixel, 'I', represents all that is known about one wheelie; **61** aliases 'I' to 'CPX' for convenience. At the outset, these pixel vectors just hold  _r_, _θ_ and _±ω_. Over the course of iteration, we compute and store the time-independent "stage 1" transform matrix, as noted above. When done with filling this "wheelie database", we harness [store](https://gmic.eu/tutorial/store.html) to make the wheelie vectors accessible to the math expression parser; it may do so through the 'circles' _image storage variable_. The permutation prior to 'store' is for convenience. The reorganizing of the 'args' image through this permutation leaves wheelie components arrayed along the 'arg' image 'x' axis instead of along its spectral axis. The wheelie vectors contiguous along the 'x' axis make for more straightforward access in the arabesque drawing loop.
|  **62** | 'rot()' generates pure rotational matrices: 2 × 2 for two dimensional work and 3 × 3 for three dimensional. In the latter form, one provides the axis of rotation to complete the specification: '[0,0,1]' identifies the three-space _+z_ unit axis.\n\nThat we are operating in three dimensions may give one reason to pause. Recall our preference for working with [homogeneous points](https://gmic.eu/tutorial/tiled_art.html#affinetransform), inhabitants of a three dimensional projective space, so that we can encapsulate both rotation and translation in one transform — as well as diambiguate points from vectors. In this case, the axis of choice is the _+z_ axis, perpendicular to the canvas, so that when we rotate points in the canvas plane, they stay in the canvas plane. The first use of this function gives us 'orot', _origin rotation_ derived from _θ_, the second element of the wheelie vector. 'deg2rad()' conveniently converts this element from degrees to radians. So does the ° operator — the degree symbol. Thus 45.739° in a G'MIC math expression quietly transforms itself into ≈ 0.798296 radians. Consult your operating system manual on how to obtain off-keyboard characters if you cannot find the ° sign on it.
|  **63,64** |We generate the translation matrix, 'xlat' by starting with the 3 × 3 identity matrix, as furnished by 'eye()'. In an affine transform, elements two and five embody spatial displacement. We set only an _x_ displacement, this the length of the wheelie; what of _y_? Recall from the main discussion that we view individual wheelies in a relative way, so it suits us to build up the local wheelie transform where the wheelie itself is in a standard orientation: zero degrees orientation with the wheelie aligned to the _+x_ axis. Thus, in this most local of spaces, there is no displacement in _y_.
|  **65,66** |Overall, we re-compose the 12 element wheelie vector from two fields. The first, elements 0 - 2, copies _r_, _θ_ and _±ω_.\n\nThis copy makes use of the _accessor_ operator, a pair of open-and-close square brackets, which takes as many as three arguments: `[<starting index>, <subvector length>, <stride>]`; the accessor operator extracts subvectors from source vectors. The first argument marks the index in the source vector where the subvector starts. It is the only required argument and, used in isolation, simply extracts a single element from the source vector. The second argument, if present, sets the length of the subvector. Thus 'V=[0,1,2,3,4,5,6,7,8,9]'; 'SV=V[5,3]' sets 'SV' to '[5,6,7]', the three element subvector beginning at index = '5'. The third argument, if present, sets the _stride_, and defaults to increments of one element. Thus 'V=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];V[0,4,4]' retrieves the subvector '[0,4,8,12]', the four element subvector starting at index '0' in the source and consisting of every fourth element. Extracting a subvector through the accessor operator is a read-only operation; one cannot use it on the left hand side of an assignment and expect to set the values of a left hand subvector. For that, consider 'copy()', which can transcribe a subvector form a source to destination.\n\nThe second field composing the wheelie vector harnesses 'mul()' to compose the two matrices: 'orot', the rotation component generated from  _θ_, and 'xlat' the translation component generated from _r_. The right-to-left multiplication, or _composition_, of the translation and rotation matrices produces the _wheelie matrix_. This matrix transforms a point at the origin of the wheelie to its tip and reflects the combined operation of displacing the point along the _+x_ axis by a distance equal to the length of the wheelie (_r_) then rotating this position vector by _θ_. Care must be taken, for the right-to-left composition of a translation and a rotation is not the same as a left-to-right composition of a rotation and a translation. With the latter, the resulting matrix reflects the combined operation of first rotating the point at the origin, and _then_ translating it. Alas! The rotation of a zero-length position vector is of no consequence. A point rotating around itself remains unchanged. That leaves just the translation, not a full characteration of the transform. That is why the composition starts with 'xlat', generating a positive length displacement, to which we compose 'orot', the displacement vector rotated, and not the other way around. The non-communicative quality of matrix algebra is a source of many an interesting bug — amusing after the fact, exasperating in the moment.\n\nWe form a new wheelie vector, 'FIN' (final). 'FIN' contains, front-to-back, the three- and nine-element fields consisting of the wheelie triplet and its allied affine transform. 'FIN' by itself on the final line of the math expression is an implicit assignment to some "target." What that target may be depends on command line context in which the math expression was invoked. In the context of the [fill](https://gmic.eu/tutorial/fill.html) command, that target is the current pixel in the fill image iteration.
|  **85-121** |The arabesque drawing loop draws one mark of the arabesque per iteration. '-repeat 3*$sw,k … -done' establishes the number of plots; 'k' grows with larger images. The multiplier, '3', also stems from artistic whimsy; lower this multiplier for faster, sparser plotting. The loop operates once for each _Δt_.\n\nThe wheelie walk discussed in the main article is realized through the '-repeat cc,k … -done' loop from **109-121** and, among other chores, it retrieves the stage 1 time-independent transform from 'circs', the wheelie database, and composites it with the rotation matrix for _ωt_. The inner 'mul()' expression spanning **113-117**, performs this composition. The rotation matrix for _ωt_ is the first term of 'mul()': 'circs[12*idx+2]' retrieves the wheelie-specific angular velocity, _ω_, from the wheelie database; 'omega' holds accumulated "time", a whimsical proxy for travelling through parameter space. 'Omega' is a math expression alias for the command line analog, '$atk'. See **131** and **104**, which brings the command line variable '$atk' into the math expression. Rotation around the _+z_ projection space axis produces the rotation matrix for _ωt_. The second term of 'mul()' is the stage 1 time-independent transform, the composition of _r_ and _θ_. The composition of these two terms produces the dynamic version of the wheelie matrix.\n\nThe outer 'mul()' expression spanning **112-120**,accumulates the dynamic wheelie matrices into 'imat' — this, the realization of the tip-to-origin walk. Dropping out of the 'repeat' loop spanning **109-121** delivers 'imat'. It embodies the entire transform of a point at the origin of the entire ensemble up to the tip of the final wheelie.
|  **122-130** |The bottom of the arabesque drawing loop concerns itself with plotting arabesque marks: line segments between adjacent _Δt_ plots and drawn by 'polygon()'. The drawing loop maintains a two-plot window, realized by storage variables 'firstpt' and 'lastpt' These points are in display space, so the matrix responsible for that transform is summoned from storage variable 'ssxform'. Recall **72-84**. Referring to **123**, 'imat*pp' carries a point from the origin to the wheelie tip and is subsequently transformed by 'ssx' into a screen space plot.\n\nTo create a two point plotting window, the drawing loop retains the plot of the previous iteration in 'lastpt' and draws from that to the current plot; before the iteration finishes, the current plot becomes the next inhabitant of 'lastpt', to serve in a similar capacity in the next iteration. That accounts for most drawing activity, excepting the initial and final boundary cases. Nothing is plotted in the first iteration. Instead, the initial plot is stashed to both 'firstpt' and 'lastpt'. Through all remaining iterations, up to the last, 'firstpt' is undisturbed. When the last iteration is realized and plotting has taken place, there remains a gap between 'firstpt' and 'lastpt.' These become plot points for an extra, final call to 'polygon()', which closes the gap between the initial and final plots, finishing the arabesque.

???

= demonsarise
## Demons Arise
To this settled way of thinking come demons…

Drawing arabesques with wheelies exemplifies following one's nose. We more-or-less design from what we see. See a compass; imagine a wheelie. Post-and-lintel, to be sure, but post-and-lintel works just fine — thank you — in all that doors require for letting people get around.

But along come arches — a disruptive technology, allowing piecemeal rocks to span greater distances than contiguous lintels, which, perforce, break if spans are too great. For wheelies, what disrupts is the [inverse discrete Fourier transform](https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Inverse_transform). With it we ditch step-and-repeat; the transform generates the entire arabesque in just one throw.

The shiv that cuts is this: Wheelies are cognates of _frequency domain_ points, plots inhabiting a one dimensional parameter space, containing at regular frequency samples, information about oscillations: their magnitudes, phasing and frequencies.
= figfive
===
![spectralspace](images/spectralspace.svg)
*5. Plotting _nth_ wheelie in a one dimensional, discrete, circular and finite frequency domain.*
===

|      1.  |The frequency domain is discrete, finite and circular:
|      1a.  |Its origin corresponds to a rotation rate of zero. Discrete frequencies, _ω_, mark off the abscissa and are commensurate to the wheelie's rotational rate.
|      1b.  |The abscissa wraps around. Clockwise and counterclockwise rotational coordinates extend from the left and right of the origin, meeting at a _folding_ or [Nyquist sampling rate](https://en.wikipedia.org/wiki/Nyquist_rate) (_n_), setting the length of the space: _2·n_.
|      1c.  |As a consequence of folding, addition and subtraction become [modular](https://en.wikipedia.org/wiki/Modular_arithmetic) operations. Subtrahends larger than their minuends do not produce negative quantities, but invoke an implied addition of the length of the space as many times as necessary to bring resultants into the interval _0,…,2·n_. Similarly, addends exceeding the length of the space invoke an implied substraction of the length, again as many times as necessary to bring resultants into the same interval.
|      2.  |A point in this domain represents a _displacement under rotation_. Complex ordinates denote both the displacement's magnitude and its direction. One need not squint very hard to see how a wheelie also expresses a complex number, and that number's coordinate in the frequency domain also denotes the wheelie's rotational rate.
|      3.  |A minimum Nyquist sampling rate may be chosen to distinguish, within one sampling cycle, _at least_ two distinct orientations of the most rapidly spinning points.

Transforming this space by way of the inverse discrete Fourier transform produces an oscillatory signal of complex values. Plotting these in the complex plane generates the arabesque — all in one go — corresponding to the initial frequency domain plots.

There is an art to that. It's essential not to plot _single_ wheelies in the frequency domain, but wheelie _sums_. This provision stems from wheelies chaining together. A wheelie in the chain reflects its own spin, but also the combined spins of antecedent wheelies. Similarly, the orientation of a wheelie in the chain reflects its own deflection angle from its antecedent and that of all other antecedents back to the root. This provision promotes the following plotting algorithm:
= mapwheelies
### Mapping Wheelies to the Frequency Domain
|      1.  |Starting from the root wheelie, initialize aggregate sums for orientation, _Σθ_, and rotational rate, _Σω_, with the orientation of the root, _θ₀ → Σθ_, and the root's rotational rate, _±ω₀ → Σω_.
|      1a.  |If _Σω_ < 0, add twice the Nyquist rate: _Σω + 2·n → Σω_ in accordance with modular arithmetic.
|      2.  |With the current wheelie, decompose its radius, _r_, into complex components: _r_ → _r·cos(Σθ) + i·r·sin(Σθ)_.
|      3.  |Add this decomposed complex radius to the value at frequency domain coordinate _Σω_.
|      4.  |If there are no further wheelies in the chain, branch to 6. Otherwise:
|      5.  |Proceed to the next wheelie in the chain from the root. Add its orientation, _θ_, and rotational rate, _ω_, to aggregate sums:  _θ + Σθ → Σθ_, and _ω + Σω → Σω_.
|      5a.  |If _Σω_ < 0, then add the Nyquist rate: _Σω + 2·n → Σω_ in accordance to modular arithmetic. Branch to 2.
|      6.  |We've finished plotting. The inverse discrete Fourier transform generates the arabesque; we exit.
= figsix
===
| ![wheeliespatial](images/wheeliespatial.svg)
|*6. Accumulated orientations and rotationl rates of wheelies determine plotting values (_r·cos(Σθ) + i·r·sin(Σθ)_) and frequency domain coordinates ( Σω )*
===

Consider these wheelies (also shown above):

|- wheelie | radius (_r_)| orientation (_θ_)| rotational rate (_±ω_)|_Σθ_|_Σω_|_r·cos(Σθ)_|_i·r·sin(Σθ)_
| *    1* | *    2* | *    3* | *    4* | *    5* | *    6* | *    7* | *    8*
|W₀|0.5|30°|+1|30°|+1|0.43301|0.25000
|W₁|0.125|45°|_2n-5_|75°|_2n-4|0.03235|0.12074
|W₂|0.25|15°|+3|90°|_2n-1_|0.00000|0.25000
|W₃|0.5|315° (-45°)|+4|45°|+3|0.35355|0.35355

This algorithm is analogous to the wheelie walk of yore; we loop over the wheelies and, for each, add the real and imaginary radial components (columns 7 and 8) to the ordinate at coordinate _Σω_ (column 6). This itself is an accumulation, since _Σω_ is a modular sum and subject to wrapping around, there could be values already added from prior loops.

= figseven
===
| ![wheeliespectral](images/wheeliespectral.svg)
|*7. Accumulated orientations and rotational rates establish ordinals (_r·cos(Σθ) + i·r·sin(Σθ)_) and abscissa coordinates ( Σω )*
===

What obtains could be termed the "frequency domain image" of the arabesque. When we transform it to the temporal domain through the inverse discrete Fourier transform, we obtain periodic oscillatory complex ordinates on the interval _0, …, 2·π (0°, …, 360°)_.
= figeight
===
| ![wheelietemporal](images/wheelietemporal.svg)
|*8. Temporal counterpart of the frequency domain: wheelie plots*
===

The arabesque itself appears by plotting the ordinates on the complex plane.
= fignine
===
| ![wheelieplot](images/wheelieplot.svg)
|*9. Arabesque of wheelies W₀, W₁, W₂ and W₃*
===

Spectralarabesque.gmic implements this scheme, first plotting the frequency domain image from wheelie sums, then obtaining the arabesque in the spatial domain:

??? spectralarabesque.gmic
~~~
 1 # spectral_width,radius_0,angle_0,angular_velocity_0[,radius_1,angle_1,angular_velocity_1],…
 2 fwheelie :
 3    $=a
 4 
 5    # Expect data triplets
 6    -check {!(($#-1)%3)}
 7 
 8   sw={$a1/2}
 9    -if $sw%2==0
10       sw+=1
11    -fi
12 
13    # Two row vectors for real and imaginary frequency domain samples. Size from first
14    # argument
15    -input $sw,1,1,2
16    -name. carray
17 
18    # Fetch and check diameter, phase angle and angular velocity parameters
19    accsf=0
20    acca=0
21    -repeat $#-1,j
22       -if   $j%3==0 # get radius
23          rad=${a{2+$j}}
24          -check isnum($rad)" && "$rad>=0
25       -elif $j%3==1 # get angle, degrees
26          ang=${a{2+$j}}
27          -check isnum($ang)" && "$ang>=0" && "$ang<=360
28          acca+=$ang
29       -else         # get ω and set spectral coefficient
30          sf=${a{2+$j}}
31 
32          accsf+=$sf
33          -if $accsf<0
34             sf={($sw+$accsf)%$sw}
35          -elif $accsf>=0
36             sf=$accsf
37          -fi
38 
39          rr={$rad*cos(deg2rad($acca))}
40          ir={$rad*sin(deg2rad($acca))}
41          -set[carray] {$rr+i(#0,$sf,0,0,0)},$sf,0,0,0
42          -set[carray] {$ir+i(#0,$sf,0,0,1)},$sf,0,0,1
43       -fi
44    -done
45    -mul[carray] $sw
46    
47 specplot :
48    # Frequency domain → time domain
49    -name. carray
50    -split[carray] c
51    -ifft[-2,-1]
52    -append[-2,-1] c
53    -name. temporal
54    sw={w#$temporal}
55 
56    # Screenspace transform.
57    fill[temporal] ">
58                     begin(
59                            specw=w#$temporal;
60                            id=eye(3);
61                            id[0]=specw/1.5;
62                            id[2]=specw;
63                            id[4]=-specw/1.5;
64                            id[5]=specw;
65                          );
66                     hco=id*[I(x,y),1];
67                     hco[0,2]
68                   "
69    -permute[temporal] cyzx
70    -input {2*$sw},{2*$sw},1,1
71    -name. canvas
72    -eval[canvas] ">begin(PV=crop(#0);polygon(#-1,-s#0,PV,1,0xffffffff,255))"
73    -keep[canvas]
~~~
???

??? Weeds, for those close to the ground.
|  __Line__  |  __Remark__  
|  **1-73** | Command line management, **18-37**, largely follows from wheelie.gmic; see remarks there. Modularization separates this implementation from that of wheelie.gmic in that plotting the frequency domain with wheelie sums has been isolated to 'fwheelie', while the transform to the spatial domain and the subsequent rendering of the arabesque has been isolated to 'specplot.' The two may be invoked independently of one another, convenient for investigation. Emulation of the original 'wheelie' command is a two-step affair:
||'gmic scripts/spectralarabesque.gmic fwheelie 512,0.5000,30,1,0.2500,60,-2,0.5000,314,4,0.1250,32,-7 specplot.'
||renders the running example. 
|  **13-17** |'carray' is the implementation of the 1-D, finite, circular and discrete frequency domain parameter space and plot it in accordance to [Mapping Wheelies to the Frequency Domain](#mapwheelies). 
|  **28-42** |'acca' implements _Σθ_; 'accsf' similarly implements _Σω_. '$sf' is a convenient pointer into the 'carray' buffer. We plot values via '-set'. As noted in the prècis, we do not set the ordinate at abscissa coordinate '$sf'; we add to what is already there, for in light of wrap-around arithmetic we may visit a frequency coordinate any number of times.   
|  **47-17** |remark

???


= totherebackagain
## To There And Back Again
Suppose we already have an arabesque, or, more broadly, an arbitrary shape topologically equivalent to a circle, but which has been suitably worked over by an Old School ash, 18 inch Louisville Slugger® so as to appear, say, like a 1911 Goudy Bookletter ampersand, over which a few tutorial writers seem obsessed. Are there wheelies that could generate it?
= figten
===
| ![goudyampersand](images/ampersand_circ.svg)
|*10. Circle ~~slightly~~ ~~somewhat~~ substantially dented into the shape of a 1911 Goudy Bookletter ampersand*
===
To put a stake in the ground, let us say that there are. In setting ourselves along this course, our feet land on a well-trodden path. Going back a decade or more, there have been eruptions of [fantastic constructions](https://www.youtube.com/watch?v=-qgreAUpPwM) of gyrating arrows that do etch-a-sketch things: drawing birds, flowers, even portraits of Jean-Baptiste Joseph Fourier or Santiago Ginnobili's [Homer Simpson](https://www.youtube.com/watch?v=QVuU2YCwHjw).

In this ovure, our wheelie is a pseudonym for an _epicycle_ and the rôle it plays is that of a brick: a building block with standard behaviors. Here, the behaviors are radius, _r_, orientation, _θ_ and spin, clockwise or otherwise, _±ω_. These come with attachment points for chaining them and out of them we may draw anything that pleases and is periodic — so long as we have the code.

The code, to wit: the particular settings _r, θ,_ and _±ω_ that, applied to wheelies in an orderly way, draws flowers, birds, Homer Simpsons or 1911 Goudy Bookletter ampersands. Hitherto we've been choosing settings by whimsy and seeing what twirls. Now we're walking backwards to _find_ settings _r, θ,_ and _±ω_ to draw preconceived whimsies: ampersands and such.

But, verily, walking backwards is what we _have_ been doing. Plotting wheelie sums in the frequency domain and harnessing the inverse discrete Fourier transform to plot spatial arabesques has a forward counterpart. Harness the (forward) discrete Fourier transform to produce the frequency domain image of the preconceived arabesque, and take differences of frequency domain values to find the wheelies. 

We might, for the moment, feel a certain angst about recovering wheelies through differencing frequency domain values. Difference how? Don't we have to find a _specific_ set of wheelies?

It turns out that we don't have to worry about that. There is something interesting about the four wheelies entabulated here:

|- wheelie | radius (_r_)| orientation (_θ_)| rotational rate (_±ω_)|_Σθ_|_Σω_|_r·cos(Σθ)_|_i·r·sin(Σθ)_
| *   1* | *   2* | *   3* | *   4* | *    5* | *     6* | *     7* | *    8*
|W₀|0.5000|30|1|30|1|0.43301|0.25000
|W₁|0.2500|60|-2|90|-1|0.00000|0.25000
|W₂|0.5000|314|4|44|3|0.35967|0.34733
|W₃|0.125|32|-7|76|-4|0.030240|0.12129

What is interesting about these four wheelies is that their root-to-tip sums produce the same frequency domain plots as the first four wheelies. Wheelie chains are _not_ cognates of arabesques. An arabesque could arise from any number of wheelie chains; the wheelie chains need only to produce a particular frequency domain image to produce a given arabesque. There are any number of equivalent wheelie chains that produce a common set of frequency domain plots; all of these chains would produce the same arabesque.

It need not be four wheelies. The following set of eight wheelies produce the same arabesque as the previous two sets of wheelies.

|- wheelie | radius (_r_)| orientation (_θ_)| rotational rate (_±ω_)|_Σθ_|_Σω_|_r·cos(Σθ)_|_i·r·sin(Σθ)_
| *    1* | *    2* | *    3* | *    4* | *    5* | *    6* | *    7* | *    8*
|W₀|0.5000|30|1|30|1|0.43301|0.25000
|W₁|0.2500|60|-2|90|-1|0.00000|0.25000
|W₂|0.0015|326|3|56|2|0.00084|0.00124
|W₃|0.0007|339|-4|35|-2|0.00057|0.00040
|W₄|0.5000|10|5|45|3|0.35355|0.35355
|W₅|0.0009|12|-6|57|-3|0.00049|0.00075
|W₆|0.0021|164|7|221|4|-0.00158|-0.00138
|W₇|0.1250|216|-8|77|-4|0.02812|0.12180


~~~
In [82]: foo = np.array(
    ...:     [
    ...:           0.5   * np.exp(complex(0, np.radians(30)          + (1)       * t))
    ...:         + 0.125 * np.exp(complex(0, np.radians(30+45)       + (1-5)     * t))
    ...:         + 0.25  * np.exp(complex(0, np.radians(30+45+15)    + (1-5+3)   * t))
    ...:         + 0.5   * np.exp(complex(0, np.radians(30+45+15-45) + (1-5+3+4) * t))
    ...:         for k in np.linspace(0, 2 * np.pi, 360)
    ...:     ]
    ...: )
or populating the real part...
In [116]: foo = np.array(
     ...:     [
     ...:           np.exp(complex(np.log(0.5),   np.radians(30)          + (1)       * t))
     ...:         + np.exp(complex(np.log(0.125), np.radians(30+45)       + (1-5)     * t))
     ...:         + np.exp(complex(np.log(0.25),  np.radians(30+45+15)    + (1-5+3)   * t))
     ...:         + np.exp(complex(np.log(0.5),   np.radians(30+45+15-45) + (1-5+3+4) * t))
     ...:         for k in np.linspace(0, 2 * np.pi, 360)
     ...:     ]
     ...: )
Make an arabesque from a wheelie list:
gmic scripts/wheelie_simple.gmic wheelie 512,0.5,30,1,0.125,45,-5,0.25,15,3,0.5,315,4

Test SVG reader, bypass wheelie generation. Read an SVG file, fetch the first path, log it in an image. Sanity check it with a frequency domain converter
gmic scripts/svgtowheelie.gmic scripts/spectralarabesque.gmic svg2plots images/ampersand_circ.svg,8 split. y -ifft[-2,-1] append[-2,-1] c mul. '{2*w}' -d specplot.
~~~

A few years ago, Grant Sanderson (3blue1brown) wished to impart the _feel_
 Consider  Follow your nose and find just line segments — _wheelies_ — each with one rooted and one free endpoint. If making arabesques is your order, then look no further than a chain of wheelies.

[](https://www.youtube.com/watch?v=s_L-fp8gDzY) entered the expository fray with [But what is the Fourier Transform? A visual introduction.](https://www.youtube.com/watch?v=spUNpyF58BY) favoring illustrative animations over notational expository. Just a few wheels occasion arabesques, our jumping off point.
~~~
gmic spectralarabesque.gmic fwheelie 512,1,0,1,0.5,0,-3,0.5,0,-7
   1  0.469846, 0.171010
 248 -0.286788, 0.409576
 255  0.211309, 0.453140
 Proof of concept: gmic -debug wheelie_aplot.gmic svgtowheelie.gmic wheelie 1024,1,0,1,0.5,0,-3,0.5,0,7 -name. spectral mkwheelielist[spectral] 16 wlist=\${} keep[0] wheelie 1024,\$wlist o[0] foo_one.png o[1] foo_too.png
~~~
