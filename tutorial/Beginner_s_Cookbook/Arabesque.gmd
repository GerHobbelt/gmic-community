# Arabesques
%% x "mkdir -p img" %% %% -m scripts/wheelie_anim.gmic input 1024,1024,1,3,lerp([219,214,233],[219,187,91],y/(h-1)) durga. 1,90,1,0.125,0,7,0.5,0,-3,0.5,0,5 [-1]x60 erode_circ 3 -resize 29.3%,29.3%,1,3,5 o img/arabesque.mp4,24,H264 rm %% %% -m scripts/wheelie_simple.gmic 300,300,1,1 gtutor_wheelie 0.375,0,1,0.375,0,2 o. img/simple_01.png rm %% %% -m scripts/wheelie_simple.gmic 1024,1024,1,1 gtutor_wheelie 0.375,0,1,0.3125,0,2,0.25,0,5 dilate_circ 4 r2dx. 300,5 o img/simple_02.png rm %% %% -m scripts/wheelie_simple.gmic 1024,1024,1,1 gtutor_wheelie 0.375,0,1,0.3125,0,2,0.25,0,5,0.0625,57,-6,0.03125,85,-11 dilate_circ 4 label. -apply_curve. 1,0,255,127,0,255,255 map. aurora r2dx. 300,5 o img/simple_03.png rm %% %% -m scripts/wheelie_simple.gmic 1024,1024,1,1 gtutor_wheelie 0.375,343,1,0.375,0,-3,0.25,350,-3 dilate_circ 4 r2dx. 300,5 o img/simple_04.png rm %% %% -m scripts/wheelie_anim.gmic i 600,600,1,3,lerp([220,220,233,255],[180,180,200,255],y/(h-1)) nm. background -i[-2] (0.92^0.92^0.92^0.995) nm.. multiplier -i[-3] [background],[background],[background],4 -nm... arabesque wheelie_anim[arabesque,multiplier,background] 120,1.125,{1/3},0,0,{1/3},0,0,{1/3},0,1 erode_circ 2 rm. r 50%,50%,1,3,5 o img/simple.mp4,24,H264 rm %% %% -m scripts/wheelie_anim.gmic i 600,600,1,3,lerp([220,220,233,255],[180,180,200,255],y/(h-1)) nm. background -i[-2] (0.92^0.92^0.92^0.995) nm.. multiplier -i[-3] [background],[background],[background],4 -nm... arabesque wheelie_anim[arabesque,multiplier,background] 120,1.125,{1/3},0,0,{1/3},0,1,{1/3},0,2 erode_circ 2 rm. r 50%,50%,1,3,5 o img/simpletoo.mp4,24,H264 rm %% %% -m scripts/wheelie_anim.gmic i 600,600,1,3,lerp([220,220,233,255],[180,180,200,255],y/(h-1)) nm. background -i[-2] (0.92^0.92^0.92^0.995) nm.. multiplier -i[-3] [background],[background],[background],4 -nm... arabesque wheelie_anim[arabesque,multiplier,background] 120,1.125,{1/3},0,1,{1/3},0,2,{1/3},0,3 erode_circ 2 rm. r 50%,50%,1,3,5 o img/simplethree.mp4,24,H264 rm %% %% -m scripts/wheelie_simple.gmic 512,512,1,1 gtutor_wheelie 0.375,343,1,0.375,0,-3,0.25,350,-3 dilate. 8 label 3 1,10,1,3,u([255,255,255]) =>. palette map.. [palette] rm. -gtutor_tileit. 0,0.25,1,1,1,0,8,1 o. img/clover.png rm %%

|- [Wheelies](#wheelie)| [Wheelie Math](#wheelmath)| [To There And Back Again](#totherebackagain)| [Wheelie Animations](#wheelieanimations)| [PostScript](#postscript)

|![Arabesque](img/arabesque.mp4)\n               *"Durga's idle arabesques"*|During brief interludes, when tranquility prevails and the peoples of the world are in complete accord, Durga might take ease from her duties and find serenity through simple pursuits.\n\nIt is a small pleasure to swing a compass marker around its anchor leg, and if hands might quave arcs still run true — not that palsy ever troubles Durga, master as she is of the _chakra_ and _trishul_. And so it is hardly burdensome for her to take up compass after compass, anchor to marker, twirling each at spins and spreads picked through whimsy.\n\nSuch a flurry of hands and arms might astonish mortals, but for the slayer of the abominable Mahishasura it is just so many twirlings. With each added compass, the culminating marker traces ways ever more sublime, awarding Durga escalating delights. And so it goes — until demons arise. Durga must then put away her compasses and take up her arrows and bow.
= wheelie
## Wheelies
Deficient as we are in arms, we seek computerized compensations. Accordingly, let _wheelies_ model compass pairs: one end of a segment is a hinge that sticks to whatever it has been attached and the other end swings free. Chains of these emulate Durga's compass-upon-compass pile-ons.

Roughly, we'd like to have some command, 'gtutor_wheelie' — which we don't know how to write yet. But let's imagine it lives in a place called 'scripts/wheelie_simple.gmic' and can draw simple arabesques:
= wheeliesample
===
|-![simple_01](img/simple_01.png)|![simple_02](img/simple_02.png)|![simple_03](img/simple_03.png)
| 'simple' | 'threewheelie' | 'colorwheelie'
===

This produces a two-wheelie arabesque:
= simple
~~~
simple:
    -command scripts/wheelie_simple.gmic
    -input 300,300,1,1
    -gtutor_wheelie. 0.375,0,1,0.375,0,2
    -output. simple.png
~~~

`0.375,0,1` specifies a wheelie with a radius (length) of `0.375`, an initial orientation of `0°` and a rotational rate of one counterclockwise revolution per period — a "frequency" of one cycle. The second wheelie, `0.375,0,2` is almost the same as the first but has twice the counterclockwise rotation rate. These cycles can have any duration; we don't care. We operate in relative time, duration consisting of indefinite "periods."

Or maybe you want a more fancy three-wheelie arabesque:
= threewheelie
~~~
threewheelie:
    -command scripts/wheelie_simple.gmic
    -input 1024,1024,1,1
    -gtutor_wheelie 0.375,0,1,0.3125,0,2,0.25,0,5
    -dilate_circ 4
    -resize2dx. 300,5
    -output. threewheelie.png
~~~

So maybe you find the white-on-black output a little plain. But that scheme lends itself to further embroidery. Such is done with this five-wheelie:
= colorwheelie
~~~
colorwheelie :
   -command scripts/wheelie_simple.gmic
   -input 1024,1024,1,1
   -gtutor_wheelie 0.375,0,1,0.3125,0,2,0.25,0,5,0.0625,57,-6,0.03125,85,-11
   -dilate_circ 4
   -label.
   -apply_curve. 1,0,255,127,0,255,255
   -map. aurora
   -resize2dx. 300,5
   -output. colorwheelie.png
~~~

So let's set about to write this 'gtutor_wheelie' thing.

= firstplay
With each wheelie we may:

|      1.  |set a particular radius:|      _+r_
|      2.  |pick a starting orientation:|      _±θ_
|      3.  |choose a signed, clockwise or counterclockwise, rotational rate:|     _± 2πf_

Thus, to make a _wheelie chain_ ( [Figure 1](#figone) ):

|      1.  |Root the first wheelie at the origin.
|      2.  |Hinge additional wheelies at successive free end points, perhaps setting their orientation differently or aligning them all. Do that any number of times, _or_
|      3.  |attach a marker to the rim of a terminal wheelie and take a picture of the pip it draws.
|      4.  |Adjust the orientations to account for _2πft_ and plot again … and again until the accumulated adjustment equals the preset. What remains is the traversal path of the marker in all of its charm — an arabesque.

Plot by plot, a wheelie's circular motion fathoms easily. But add a few more — complexity strikes us dumb. The remedy for that are patterns. These, in recurrence, divide and conquer.

= figone
===
|-![wheeliediagram](images/wheeliewalk.svg)
| *1. Walking a wheelie chain from marker tip to the origin*
===

Let paired wheelies, _antecedent_ and _successor_, provide the exemplary pattern. First, characterize relative motion in the locality of a wheelie pair. Then aggregate motions of pairs into larger localities — ultimately that of the whole.

Start with the next-to-the-last and final wheelie. Establish a local coordinate system encompassing this last pair. Orient the antecedent to zero degrees, anchor at the local origin and tip aligned with the local _x_ axis. Now bring in the successor. It's sticky end hinges to the antecedent's tip while its own swings free.

The factors accounting for the successor's local motion with respect to its antecedent are its length, _r_, and its orientation _θ + 2πft_. Here, _2πft_ is the time-varying part of its orientation, the product of its rotational rate _2πf_ and accumulated ticks: _t = (Δt₀ + Δt₁ + … )_.

These factors bring about an [affine matrix](https://gmic.eu/tutorial/tiled_art.html#affinetransform), one that takes a point in the neighborhood of the successor's origin (_née_ antecedent's tip) through a translation by _r_ and a rotation by _2πft + θ _:
= figtwo
===

$$
\begin{bmatrix} m_x \\ m_y \\ 1 \end{bmatrix} =
\begin{bmatrix}
\-cos ( 2 \pi f t + \theta) & -\-sin ( 2 \pi f t + \theta) & r_x \\
\-sin ( 2 \pi f t + \theta) & \-cos ( 2 \pi f t + \theta) & r_y \\
0 & 0 & 1
\end{bmatrix}
\begin{bmatrix} o_x \\ o_y \\ 1 \end{bmatrix}
$$
*2. A Wheelie transform taking a point at _o_ (origin) to _m_ (tip)*
===

This matrix characterizes motion in the locality of this wheelie pair. As _Δt_ ticks accumulate, changing _2πft_, the tip traces a circle of radius _r_; not very interesting but readily grasped.
= figthree
===
|-![Simple](img/simple.mp4)
| *3. The locality of one wheelie pair*
===
Shift toward the root. Write a second matrix. This relates the root-ward wheelie tip to _its_ antecedent: a second circular plot. Multiply the two matrices from right to left to aggregate the motion of both.
= figfour
===
|-![SimpleToo](img/simpletoo.mp4)
| *4. Localities of the second and third, and first and second wheelie pairs compounded together*
===
And so we go, compounding individual circular motions into wider localities. Eventually we obtain the overall motion of the terminal tip relative to the initial root. The pairwise writing of matrices and their aggregation is our divide-and-conquer play. The arabesque of the whole arises from the actions of the parts.
= figfive
===
|-![SimpleThree](img/simplethree.mp4)
| *5. Localities of three wheelies of rates one, two and three*
===

We mark one plot and tick _Δt_. That changes the orientation of all wheelies, of course, so we re-walk the walk, compound the adjusted matrices and plot the second mark. And again. And again … until the preset has been reached.

After all that — we're done. We know how to write this 'gtutor_wheelie' thing. The implementation looks something like 'wheelie_simple.gmic'. Unroll it for details. See [Annotations](#annotations) for the weeds.

= wheelielist
??? wheelie_simple.gmic
~~~
#  1 #@cli gtutor_wheelie : radius₀>0,–∞<orientation₀<+∞,-∞<rotrate₀<+∞…
#  2 #@cli : Compose an arabesque from a chain of wheelies; specify each
#  3 #@cli : link with triplets: radius (+float), orientation (±degrees,
#  4 #@cli : float), rotational rate (±integer) and draw on the selected
#  5 #@cli : images.  A wheelie is a tail-anchored rotating vector of a
#  6 #@cli : particular (1) radius, (2) phase angle (orientation) and (3)
#  7 #@cli : discrete rotational rate, some relative integral number of
#  8 #@cli : revolutions per an unspecified period. Wheelies chain
#  9 #@cli : together, the center of one situated at the 0° mark on the
# 10 #@cli : rim of its antecedent. The first wheelie of the chain
# 11 #@cli : centers on the origin and the last has attached instead of
# 12 #@cli : another wheelie, a marking pen. Thus, the entire ensemble
# 13 #@cli : draws an "arabesque" as the individual wheelies rotate at
# 14 #@cli : their respective rotational rates and from their initial
# 15 #@cli : orientations.
# 16 #@cli : $ gmic 1024,1024,1,1 gtutor_wheelie. 0.5,67,1,0.25,0,-3 name. tricirc
# 17 
# 18 gtutor_wheelie: 
# 19    # Fetch an arbitrarily long argument list to $a0, $a1, …, $an
# 20 
# 21    $=a
# 22 
# 23    # Expect data triplets: radius, phase angle, angular velocity.
# 24 
# 25    -check "!(($#)%3)"
# 26 
# 27    # Argument image: For each wheelie, compose radius and phase
# 28    # arguments into a transformation matrix. In the generation
# 29    # loop, we compose this with the angle resulting from one
# 30    # angular velocity step.
# 31 
# 32    wcnt={int(($#)/3)}
# 33    -input $wcnt,1,1,12
# 34    -name.  args
# 35 
# 36    # Iterate over argument vector. For each triplet –
# 37    # representing a delta wheelie – Fetch radius (rad), phase
# 38    # angle (ang) and angular velocity (sf) parameters.
# 39 
# 40    -repeat $# j=$>
# 41       -if   $j%3==0 # get radius
# 42          rad=${a{1+$j}}
# 43          -check isnum($rad)" && "$rad>=0
# 44          -set[args] $rad,{round($j/3,1,-1)},0,0,0
# 45       -elif $j%3==1 # get angle, degrees
# 46          ang=${a{1+$j}}
# 47          -check isnum($ang)
# 48          -set[args] $ang,{round($j/3,1,-1)},0,0,1
# 49       -else         # get ω and set spectral coefficient
# 50          sf=${a{1+$j}}
# 51          -set[args] $sf,{round($j/3,1,-1)},0,0,2
# 52       -fi
# 53    -done
# 54 
# 55    # Iterate over argument image, each 12 channel pixel
# 56    # representing one wheelie. The first three channels contain
# 57    # wheelie radius, phase angle and radial velocity. Compose a
# 58    # matrix transforming the origin to the tip of the wheelie, a
# 59    # radial translation and phase rotation. Populate the nine
# 60    # remaining channels with this matrix.
# 61 
# 62    -fill[args] ">
# 63         CPX=I;
# 64         orot=rot([0,0,1],deg2rad(CPX[1])); # phase rotation
# 65         xlat=eye(3);
# 66         xlat[2]=CPX[0];                    # translation origin
# 67         [CPX[0,3,1],mul(orot,xlat,3)];     # -to-rim, i.e.
# 68                "                           # 'rotation & xlation'
# 69                                            # store above in
# 70                                            # 12-channel pixel
# 71    -permute[args] cyzx
# 72    -store[args] circles
# 73 
# 74    # Screenspace transform.
# 75    foreach {
# 76        # Draw arabesques on the current image
# 77        # Designate it as the drawing "canvas".
# 78        -name. canvas
# 79        specw={int(min(w,h)/2)} 
# 80        ssxfrm={"
# 81                 sw=get('specw',0,0);
# 82                 id=eye(3);
# 83                 id[0]=sw;
# 84                 id[2]=sw;
# 85                 id[4]=-sw;
# 86                 id[5]=sw;
# 87                 id
# 88                "}
# 89        atk=0 # Accumulate "angular ticks"...
# 90        lastpt={vector3([0,0,1])}
# 91        firstpt={vector3([0,0,1])}
# 92        -repeat 3*$specw k=$>  # Animation loop 
# 93          # For each wheelie:
# 94          # increment by angular velocity
# 95          # find corresponding rotation matrix
# 96          # compose with radial argument image,
# 97          # compose with screenspace transform
# 98          # and plot via polygon().
# 99 
#100          -eval ">
#101           const cc=$wcnt;
#102           fpt=get('firstpt',3,0);
#103           ik=get('k',0,0);
#104           lpt=get('lastpt',3,0);
#105           omega=get('atk',0,0);
#106           sw=get('specw',0,0);
#107           circs=get('circles',12*cc,0);
#108           pp=vector3([0,0,1]);
#109           imat=eye(3);
#110           repeat(
#111                 cc,k,
#112                 idx=cc-k-1;
#113                 imat=mul(
#114                         mul(
#115                            rot([0,0,1],circs[12*idx+2]*omega),
#116                            circs[12*idx+3,9,1],
#117                            3
#118                            ),
#119                         imat,
#120                         3
#121                         );
#122                 );
#123           ssx=get('ssxfrm',9,0);
#124           plt=ssx*(imat*pp);
#125           ik>0?
#126           polygon(#$canvas,-2,[plt[0,2],lpt[0,2]],1,0xffffffff,255):
#127           store('firstpt',plt,3,1,1,1);
#128           store('lastpt',plt,3,1,1,1);
#129           ik==(3*sw-1)?
#130           polygon(#$canvas,-2,[fpt[0,2],plt[0,2]],1,0xffffffff,255)
#131                "
#132           atk={2*pi*($k/(3*$specw-1))}
#133        -done #Animation loop
#134    } #foreach
~~~
???

= annotations
### Annotations

??? Weeds, for those wishing to delve into them.
|  __Line__  |  __Remark__  
|  **21** | '$=a' A pseudo assignment. G'MIC transforms this into a series of actual assignments. This _'$-expression'_ generates an assignment sequence with the base name 'a' for however many elements on the command line there may be. '$a0' identifies the name of the script, so one could alter script behavior based on the script name. '$a1…' onward are the arguments. See [Adding Custom Commands](https://gmic.eu/reference/adding_custom_commands.html#top). There is nothing special about the base name 'a'. It could be anything: '$=fruitloops' initializes command line variables '$fruitloops0, …, $fruitloops<n>'. See **42** for usage.
|  **25** | __Argument Count:__ '$#' is an _'$-expression'_ that resolves to the number of comma-separated arguments given to 'gtutor_wheelie'. Thus, with the pseudo assignment shown in **21**, the command line interpreter would resolve '${a{$#}}' to the last command line argument. See also **42**.
|  **25** | __Argument Triplets:__ Wheelie specifications occur in groups of three, _+r_, _±θ_ and _±2πf_, so modulo 3 inverted, '!(($#)%3)', resolves to _True_ in such cases, enforcing arguments given three-at-a-time. Thus, the user employs triplets of successive arguments to specify wheelies, one triplet for each wheelie.\n\n __Substitutions:__ '$-expressions' specifically appear in custom command definitions, such as the one of which we are in the midsts: 'gtutor_wheelie.' See [Adding Custom Commands](https://gmic.eu/reference/adding_custom_commands.html#top). See also [Substitution Rules](https://gmic.eu/reference/substitution_rules.html#top) for those substitutions that the command line parser recognizes in any setting, not just custom commands.
|  **32** | __Math Expressions:__ Curly brace pairs here invoke the [Mathematical Expression Parser](https://gmic.eu/reference/mathematical_expressions.html#top). The present case sets the command line variable 'wcnt' to the number of wheelies specified on the command line. '$#', divided by three provides such, as each wheelie consists of three command line arguments.
|  **33-53** | __Persistent Storage:__ Before [Dynamic Arrays](https://gmic.eu/reference/mathematical_expressions.html#dynamic_arrays), it was not uncommon to harness images as persistent data storage, here image 'args' (**34**), for mathematical environments, as these do not persist. Data storage images also underlie Dynamic Arrays, but wrapped in a nice application programmer's interface (API). In this Old School approach, 'args' is not intended for display but as an argument database, one shared across math expression invocations.\n\n __Wheelie Database I:__ Each pixel in this "argument image" specifies aspects of one wheelie. Channels 0-2 hold _+r_, _±θ_ and _±2πf_ data, and this first 'repeat…done' loop, **40-53**, saves them for future reference; see **114-118**. Channels 3-11 are reserved for the wheelie-specific affine transforms. To reduce computations in the animation loop between **92-133**, we break the computation of the affine matrix into "stage 1" and "stage 2" phases. "Stage 1" precomputes matrices with only _+r_ and _±θ_ elements, which are time-independent. "Stage 2" computation occurs much more frequently, at every Δt tick, but with stage 1 computations done, there is only a need to composite an additional rotation into "stage 1", reflecting wheelie rotation during _Δt_. See **115**.
|  **42** | __Accessing Argument Lists:__ A pseudo assignment such as '$=a', see **21**, gives rise to a a number of actual command line variables '$a0, $a1', …, '$a<n>'. An "array-like" addressing scheme may be carried out, which 'rad=${a{1+$j}}' exemplifies. The curly-brace '{1+$j}' post-fixed to 'a' is reminiscent of a decorator indexing the "j-plus-one" argument array element. However, suggestive though that notation may be, no actual array access is taking place — it is just syntax sugar. This sweetening relies on the kind of name coordination that the pseudo assignment '$=a' sets up: a set of variables with common basenames and numeric suffixes in progression.\n\nIn fact, the command line interpreter undertakes a double substitution. The innermost braces ultimately invoke a mathematical expression; see **32**. But before such, the command line interpreter looks up the current value of '$j' and substitutes it for the look-up value; then the mathematical expression parser is invoked. That tool "sees" just two literal numbers, '1' and the loop count which '$j' formerly referenced. The mathematical parser has no idea about '$j'; it exists in another universe. The mathematical parser has just two literal values; it adds these and hands the results back to the command line interpreter.\n\nThe command line interpreter now regards the transformed construct anew: it is a variable '${a<n>}' with _<n>_ the number that '$j' represents. This engenders a _second_ substitution, a look up for what '$a', followed by some number _<n>_, represents. With foresight and planning, '${a<n>}' actually exists, the look up of which 'rad' duly acquires.\n\nSo for those familiar with this syntax sugar, the process seemingly "accesses the argument array" and all goes well. However, should foresight or planning be lacking — misunderstanding the number of arguments, perhaps — then the look up proceeds anyway, likely returning the empty string of a command line variable used before it is assigned. From there, any number of subtle bugs may arise. Foresight and planning follows from a pseudo assignment such as '$=a' to set up the pseudo argument array.  
|  **62-68** | __Wheelie Database II:__ ''-fill'' iterates over the 'args' image, computing the "stage 1" affine transformations for each wheelie. Storage for each wheelie occupies one of the twelve channel pixels of the 'args' image; In each step of the fill, the current 'arg' image pixel, 'I', represents all that is known about one particular wheelie.
|  **63** | __Pixel Accessors:__ Assigning 'I' to 'CPX' is not a (redundant) assignment of one vector to another, rather it is the creation of a vector from a _pixel accessor function_. The right hand side, 'I', is the pixel accessor; see [Specific Functions](https://gmic.eu/reference/mathematical_expressions.html#specific_functions), bullet points 5 – 10. This particular variant accesses pixels and converts them to vectors and is one from a family of functions dedicated to image pixel access. As the pixel accessor function lacks an argument decorator, the default is in play: 'I(#ind,x,y,z,interpolation,boundary_conditions)' where 'x', 'y', and 'z' are the predefined math expression variables that, under image iteration, assume the current image column, row and depth values.\n\nBy default, pixel accessors reference the current image. An optional "hashtag-number" initial argument explicitly identifies an access source by an image list index: '#2' identifies the third image on the list, counting from the beginning (remember: zero-indexed: 0,1,2!); '#-3' identifies the third image counting from the end of the list. '#$bluishimag' identifies the image named 'bluishimag', should one exist. If there is no image that is so named, or if any of access identifiers reach beyond the boundaries of the image list, you cop an access error.\n\nYou can access in-between pixels. That is, pixel coordinates 'x', 'y' and 'z' may be reals with fractional parts — you access the void between pixels! What happens then? An _interpolation_ takes place through one of three flavors: '0:nearest neighbor'; the interpolator reports the value of the nearest pixel along each image axis; '1:linear'; the interpolator reports the value taken from a linear ramp between the two actual neighboring pixels; '2:cubic'; the interpolator reports the value taken from a cubic spline intersecting the two actual neighboring pixels. See [Pixel Accessors: Kinds of interpolation](#interpolation).\n\nYou can access off-image pixels; perhaps you have overidden 'x' with a value far exceeding the image width. What happens then? You apply boundary policy via 'boundary conditions:' '0:dirichlet', the off-pixel is black, '1:neumann', the off-pixel is the same as the nearest edge pixel, '2:periodic', images repeat out to infinity along all axes; the off-pixel assumes the value of wherever it is in this repeating cycle, or '3:mirror', edges are mirror axes where images flip, and flip again out to infinity; the off-pixel assumes the value of wherever it is in this mirror repeating cycle. See [Images Have Edges: Now What?](https://gmic.eu/tutorial/images_have_edges_now_what.html) for the deep dive.\n\nSome pixel accessor functions use a square-bracket decorator, these intended to reference images as if they were one dimensional arrays: 'I[_#ind,offset,_boundary_conditions]'. It is easy to confuse this notation with accessing elements of a vector, also using square brackets, and, by extended confusion, taking 'I' to be a vector. Don't confuse this square bracket flavored pixel accessor with  _vector accessors_, described later; see **67**.
|  **64** | __Making Rotation Matrices:__ 'rot()' generates pure rotational matrices: 2 × 2 for two dimensional work and 3 × 3 for three dimensional. In the latter form, one provides the axis of rotation to complete the specification: '[0,0,1]' identifies the three-space _+z_ unit axis.\n\nThat we are operating in three dimensions may give one reason to pause. Recall our preference for working with [homogeneous points](https://gmic.eu/tutorial/tiled_art.html#affinetransform), inhabitants of a three dimensional projective space, so that we can encapsulate both rotation and translation in one transform — as well as disambiguating points from vectors. In this case, the axis of choice is the _+z_ axis, perpendicular to the canvas, so that when we rotate points in the canvas plane, they stay in the canvas plane. The first use of this function gives us 'orot', _origin rotation_ derived from _θ_, the second element of the wheelie vector. 'deg2rad()' conveniently converts this element from degrees to radians. So does the ° operator — the degree symbol. Thus 45.739° in a G'MIC math expression quietly transforms itself into ≈ 0.798296 radians. Consult your operating system manual on how to obtain off-keyboard characters if you cannot find the ° sign on it.
|  **65,67** | __Wheelie Matrix Composition I:__ We generate the translation matrix, 'xlat' by starting with the 3 × 3 identity matrix, as furnished by 'eye()'. In an affine transform, elements two and five embody spatial displacement. We set only an _x_ displacement, this the length of the wheelie; what of _y_ ('xlat[5]')? Recall from the main discussion that we view individual wheelies in a relative way, so it suits us to build up the local wheelie transform where the wheelie itself is in a standard orientation: zero degrees, aligned to the _+x_ axis. Thus, in this local space, there is no displacement in _y_.
|  **67,68** |As noted before ( __Wheelie Database I__, **40-53**), 'CPX' just holds _+r_, _±θ_ and _±2πf_; we assemble a new version of 'CPX', one that additionally contains the time-independent "stage 1" wheelie transform matrix; see [Figure 2](#figtwo). We re-compose this new version from a 12 element vector composed of two fields. The first field, elements 0 - 2, is a copy of the initial three fields of 'CPX' and contains _+r_, _±θ_ and _±2πf_, obtained during command line processing; see **40-55**. The matrix multiplication 'mul(orot,xlat,3)' populates the second field, elements 3 – 11; 'mul()' produces a 'vector9', the 3 × 3 "stage 1" wheelie transform.\n\n __Wheelie Matrix Composition II:__ The second field composing the wheelie vector harnesses 'mul()' to multiply together matrices 'orot', the rotation component generated from  _±θ_, and 'xlat' the translation component generated from _+r_.\n\nThe right-to-left multiplication, or _composition_, of the translation and rotation matrices produces the _wheelie matrix_, which transforms a point at the origin of the wheelie to its tip; it reflects the combined operation of displacing the point along the _+x_ axis by distance _+r_, then rotating by _±θ_.\n\n __Matrix Multiplication: Order Matters:__ Care must be taken, for the right-to-left composition of a translation and a rotation is not the same as a left-to-right composition. With the latter, the resulting matrix reflects the combined operation of first rotating the point at the origin, and _then_ translating it. Alas! The rotation of a zero-length position vector — a point — is of no consequence: a point rotating around itself remains unchanged. That leaves a translation without rotation, a less-than-full operation. That is why the composition starts with 'xlat', generating a positive length displacement vector aligned along _+x_, to which we compose 'orot', rotating that displacement vector around the local origin. The non-communicative quality of matrix algebra is a source of many an interesting bug — amusing after the fact, exasperating in the moment.
|  **67** | __Vector Accessor Function:__ 'CPX[0,3,1]' is an example of a _vector accessor function_, which extracts subvectors from source vectors. The present example copies _+r_, _±θ_ and _±2πf_ from 'CPX' to the ''-fill'' return vector.\n\nThe accessor function's three arguments, '[0,3,1]', correspond to '[ <starting index>, <subvector length>, <step> ]'. The first argument marks the index in the source vector where the subvector starts. It is the only required argument and, used in isolation, simply extracts a single element from the source vector. The second argument, if present, sets the subvector's length. Thus 'V=[0,1,2,3,4,5,6,7,8,9]'; 'SV=V[5,3]' sets 'SV' to '[5,6,7]', the three element subvector beginning at index = '5'. The third argument, if present, sets the _step_, and defaults to increments of one element. Thus 'V=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];V[0,4,4]' retrieves the subvector '[0,4,8,12]', the four element subvector starting at index '0' in the source vector and consisting of every fourth element thereafter until a length of four elements is obtained.\n\nA vector accessor function can only read vectors; it cannot write them. This precludes its use on the left hand side of an assignment. For that, consider 'copy()', which can transcribe a subvector from a source to a destination vector, or sequencing a new vector's content within a pair of square brackets, as done in line **67**.
|  **67** | __Implied Assignments:__  As the last statement in the math expression argument to ''-fill'', the re-composed 'vector12', '[CPX[0,3,1],mul(orot,xlat,3)]', undergoes an implicit vector-to-pixel conversion, updating the current "wheelie entry" in the database image 'args'.
|  **71-72** | __Passing Data to Math Expressions:__ Having filled the image-based "wheelie database", we harness [store](https://gmic.eu/tutorial/store.html) to make the wheelie data accessible to any ensuing math environments. These may do so through the 'circles' _image storage variable_. The permutation prior to 'store' reorganizes the 'args' image; the new permutation leaves wheelie components arrayed along the 'arg' image 'x' axis instead of along its spectral axis and make for more straightforward access in the arabesque drawing loop, **92-133**.
|  **74-88** | __Screen space:__ We form another transformation matrix, 'xxsfrm', based on 'specw', a resolution metric. This matrix relates one unit of distance in the wheelie computation space to half of the smaller image dimension. This heuristic anchors computational measure to a definite number. The resolution metrix 'specw' figures in a number of sizing tasks, such as scaling the number of plots necessary to draw an arabesque (**92**). Matrix 'xxsfrm' flips the direction of the 'y' axis and locates the plotting origin in the upper left hand corner, in keeping with pixel images. When all other transforms have been carried out on arabesque plots, 'xxsfrm' situates the plot in a pixel image. See **123-124**.
|  **92-133** | __Animation Loop:__ The arabesque animation loop plots one mark of the arabesque per iteration. **92:** '-repeat 3*$sw k=$> … -done' establishes the number of plots; 'k' grows with larger images. The multiplier, '3', is another heuristic; lower this multiplier for faster, sparser plotting.
|  **110-122** | __Integrated Matrix:__ The 'repeat()' mathematical function carries out the compounding of local matrices into an all-embracing translation from the root of the wheelie chain to its tip. On 'repeat()'s' denouement, 'imat' ( _intergrated matrix_ ) embodies this across-the-board translation. This is the _"…compounding (of) individual circular motions into wider localities"_ described in the text.\n\nThe loop walks from tip to root, 'cc-k-1 ⇒ idx'. For each wheelie, 'idx', in a chain with 'cc' links, the loop '-repeat cc,k, … ' first retrieves wheelie 'idx' rotation rate, _2πf_, via a vector access: 'circs[12*idx+2]' (**67**). To ascertain wheelie 'idx' rotation to the present, we multiply this rotation rate with accumulated time: 'omega', obtaining aggregate rotation _2πft_. We need to embody this rotation in an affine space transform to compound it with the kindred transforms of antecedent wheelies. To this end, we harness 'rot()' to generate a rotation matrix around the affine space _+z_ axis. This pure rotation matrix embodies the time-dependent rotation of wheelie 'idx'. The inner 'mul()' operation, **114-118**, composes this time-based rotation with the wheelie's time-independent displacement and orientation matrix, (_+r, ±θ_), pre-computed back in "stage 1" (**67-68** __Wheelie Matrix Composition II:__), retrieved through 'circs[12*idx+3,9,1]'. The composition of these time-dependent and -independent matrices turns out the dynamic local motion of wheelie 'idx'. The outer 'mul()' expression, spanning **113-121**, rolls this local motion into 'imat'.\n\nDropping out of this 'repeat' loop completes 'imat's' composition, a _grand finale_ matrix that embodies the entire transform of a point from the origin of the wheelie chain up to the tip of the final wheelie.
|  **123-134** |The bottom of the arabesque drawing loop concerns itself with plotting arabesque marks: line segments between adjacent _Δt_ plots and drawn by 'polygon()'. The drawing loop maintains a two-plot window, realized by storage variables 'firstpt' and 'lastpt' These points are in display space, so the matrix responsible for that transform is summoned from storage variable 'ssxform'. Recall **79-88**. 'imat*pp' carries the point 'pp' from the origin to the wheelie tip. It is subsequently transformed by 'ssx' into a display space plot.\n\nTo create a two point plotting window, the drawing loop retains the plot of the previous iteration in 'lastpt' and draws from that to the current plot; before the iteration finishes, the current plot becomes the next inhabitant of 'lastpt', to serve in a similar capacity in the next iteration. That accounts for most drawing activity, excepting the initial and final boundary cases. Nothing is plotted in the first iteration. Instead, the initial plot is stashed to both 'firstpt' and 'lastpt'. Through all remaining iterations, up to the last, 'firstpt' is undisturbed. When the last iteration is realized and plotting has taken place, there remains a gap between 'firstpt' and 'lastpt.' These become plot points for an extra, final call to 'polygon()', which closes the gap between the initial and final plots, finishing the arabesque.

= interpolation
===

|+ **Nearest Neighbor** | %% (255,18^236,134^170,215) =>. yeloblu 16,1,1,3,I(#$yeloblu,x/(w-1),0,0,0) =>. yeloblunearneigh _parse_cli_images r2dx[yeloblu] 27.7%,5 r2dx[yeloblunearneigh] 50%,5 %%
|                       | `gmic                                         \`\n   `-input (255,18^236,134^170,215)             \`\n   `-name. yeloblu                              \`\n   `-input 16,1,1,3,I(#$yeloblu,x/(w-1),0,0,0)  \`\n   `-name. yeloblunearneigh`                                              
|  **Linear**           | %% (255,18^236,134^170,215) =>. yeloblu 16,1,1,3,I(#$yeloblu,x/(w-1),0,0,1) =>. yeloblulinear _parse_cli_images r2dx[yeloblu] 27.7%,5 r2dx[yeloblulinear] 50%,5 %%
|                       | `gmic                                         \`\n   `-input (255,18^236,134^170,215)             \`\n   `-name. yeloblu                              \`\n   `-input 16,1,1,3,I(#$yeloblu,x/(w-1),0,0,1)  \`\n   `-name. yeloblulinear`                                                     
|  **Cubic**            | %% (255,18^236,134^170,215) =>. yeloblu 16,1,1,3,I(#$yeloblu,x/(w-1),0,0,2) =>. yeloblucubic _parse_cli_images r2dx[yeloblu] 27.7%,5 r2dx[yeloblucubic] 50%,5 %%
|                       | `gmic                                         \`\n   `-input (255,18^236,134^170,215)             \`\n   `-name. yeloblu                              \`\n   `-input 16,1,1,3,I(#$yeloblu,x/(w-1),0,0,2)  \`\n   `-name. yeloblucubic`                                                     
*Pixel Accessors: Kinds of interpolation*
With pixel accessor function 'I', sixteen samples are taken between the two pixels constituting `yeloblu`; these populate a sixteen pixel wide image. The three trials employ each interpolation schemes provided by 'I'.
===

???

= interlude
### Interlude
So `gtutor_wheelie` plots the arabesque. Maybe it can do better: meaning faster. Cheaper. But there's no budget for improvements. You've been paid. You're walking down the street, counting your money, thinking: 'Wheelie could be better.' It is the feel-your-way along the curve approach, and the back-and-forth entry-and-exit into 'polygon()' — that smacks of excess overhead. But everyone is happy — or, at least, nobody is unhappy. So there you are, thinking it could be better, should anyone spring for another bid…

So you rework it anyway. That pulls you into the deep dive.

= wheelmath
## Wheelie Math
Draw an arabesque from a chain of wheelies. [Figures 3 through 5](#figfour) shows how it goes, link by link. The first plays a single wheelie and begets the simplest of arabesques. The second — a chord of two spinning wheelies — plays a more involved fioritura. The third lets fly with a three-way fandango. That's been our play up to now: link ever more lengthly wheelie chains to draw ever more labyrinthine arabesques.

But what is beneath this pursuit? Can we devise a math for such pile-ons? Given wheelies, can we derive the arabesque? And, from the arabesque, might we also lay bare wheelies? It's not just curiosity that impels our queries but an aim to draw arabesques more nimbly.

= phaseplot
===
|-![phaseplot](images/phase.mp4)
| *6. Arabesques and Sinusoids*
===

We start with the math. An arabesque at its simplest is no more than an origin-centered wheelie — a circle — plotted over time on the complex plane; see [Figure 6](#phaseplot). It orients along the real axis and rotates counterclockwise at one cycle per period, aka, a "Hertz". "Period" is a relative measure of time that proxies for what could be a microsecond or millenia — who cares? It's the drawing, not the duration of its drafting, that matters.

In a changeover from the complex plane, [Figure 6](#phaseplot) separates this wheelie into real and imaginary time series, a pair of _[sinusoids](https://en.wikipedia.org/wiki/Sine_wave)_. One, _cos(2πft + θ)_, constructs a real axis oscillation at frequency _f_, while its phase-shifted counterpart, _i cos(2πft + θ + π/2) ⇒ i sin(2πft + θ)_ constructs a similar imaginary axis oscillation. The quarter-period phase shift between the two builds a complex plane wheelie-generator in _t_:

===
$$
\begin{matrix}
\psi (t) =  r(\cos {(2\pi f t + \theta)} + i\sin {(2\pi f t + \theta)}) & t \in [0,\dots ,1] & \textsf{E. 1}
\end{matrix}
$$
===

And that's the math, a formulation of [Figure 6](#phaseplot). Sinusoids conjure the wheelie; a point traversing the wheelie conjures the sinusoids. They are cognates, in that sinusoids oscillating through time and wheelies rotating on planes are each, in their own guises, Lego® blocks.

In its guise, the wheelie encapsulates:
| 1.  |a single frequency (_ f _),
| 2.  |its sign ( ± ) — that is, its clockwise ( – ) or counterclockwise ( + ) handedness,
| 3.  |an initial angular offset (_ θ _) and
| 4.  |magnitude (_ r _).

Musicians call such primitives _partials_ — essential harmonic elements. Combine partials to make a pleasant sound. Combine wheelies to make a pleasant arabesque. It is all the same math.

There is an apt — though perplexing — alternative to Equation 1 that facilitates wheelie combinations. Around 1740, [Leonhard Euler](https://en.wikipedia.org/wiki/Euler%27s_formula#Using_power_series) laid bare the wheelie's exponential form:

= eulers
===
$$
\begin{matrix}
\psi (t) = re^{i(2\pi f t + \theta)} = r(\cos ({2\pi f t + \theta}) + i\sin ({2\pi f t + \theta})) & t \in [0,\dots ,1] & \textsf{E. 2}
\end{matrix}
$$
===

It's aptness, however, is obscured. Old-school readers of elementary exponentiation:

===
$$
e^n \Leftrightarrow \underbrace {e \times e \times \cdots \times e}_{\texti{n factors}}
$$
===

can find Equation 2 mysterious. Multiply the number _e_ by itself an — _imaginary_ — number of times??? How does imaginary multiplication differ from the real? The mind boggles.

To get over that, it helps to know that mathematical notation sometimes borrows carelessly from itself. The borrowed notation in this case is exponentiation, and its borrowing obscures an operation with a broader remit, the [exponential function](https://en.wikipedia.org/wiki/Exponential_function):

= taylor
===
$$
\begin{matrix}
e^x \implies \exp(x) = \displaystyle \sum_{k = 0}^{\infty} \frac{x^k}{k!} = 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \frac{x^4}{4!} + \cdots & \textsf{E. 3}
\end{matrix}
$$
===

Rather than indicate the times one multiplies a base, _e_, by _x_ — what Equation 3's left hand side purports — the "exponent" _x_ should be taken as an argument of the exponential function. That is, it is more like the "function call" notation of the second representation. Take the "exponent" as an argument, mentally wrap it in parentheses and, on the right hand side, substitute _x_ with the parenthetically wrapped argument. By such means, we may introduce arguments of many types to the function: integer, real, complex, quaternion, among others, all adding range to our explorations.

And what is the right hand side? It is the [Taylor Series](https://en.wikipedia.org/wiki/Taylor_series) expansion of _eˣ_. Its utility lies in its polynomial representation, from which useful outcomes obtain.

First, this polynomial representation is readily amenable to integration and differentiation — differentiation is especially magical. We can differentiate the right hand polynomial term by term:

===
$$
\begin{array}{ccc}
\textit{x}      & \implies & \textit{dx}    \\
\hline
1               & \implies & 0              \\
x               & \implies & 1              \\[0.5em]
\frac{x^2}{2}   & \implies & x              \\[0.5em]
\frac{x^3}{6}   & \implies & \frac{x^2}{2}  \\[0.5em]
\frac{x^4}{24}  & \implies & \frac{x^3}{6}  \\[0.5em]
\frac{x^5}{120} & \implies & \frac{x^4}{24} \\[0.5em]
\vdots          & \vdots   & \vdots
\end{array}
$$
===

One does not need to work through very many terms before glancing diagonally right and down and recognizing that these differentiations are reproducing the same series — the exponential function in _x_ is its own first derivative. And, by extension, its own second derivative, and its own third derivative… _et sic porro_. Consequently, the exponential function crops up in subjects where the rate of change of a value is proportional to the value itself: exponential growth, radioactive decay and compounding interest.

Second, substituting 0 for _x_ — that is, evaluating _exp(0)_ — finds the entire Taylor series vanishing after the constant term 1. It is the something-from-nothing function, one that leaves the old-schooled wondering again how something that is not even multiplied by itself once! — _e⁰ ⇒ 1_ ! — can ever be anything at all. So, the expotential function for an argument _x_ is unique in that its derivative is the function itself and and whose value at 0 is 1.

Third, scaling this function's argument by a constant, _a_, we have:

===
$$
\begin{array}{l}
\frac{d}{dt}e^{ax} = ae^{ax} \\[0.5em]
\end{array}

$$
===

The derivative of an exponential function with a scaled argument is just the function itself, now scaled by the same magnitude.

This brings us to this guy: _i_, where _i²_ = –1. For many millenia, solutions to:

===
$$

x^2 + 1 = 0

$$
===
seemed void of meaning, as no real number multiplied by itself could result in anything other than a positive number. But that induced some to walk down the street thinking 'there _could_ be a number for that,' and surmised, by fiat, that –1 ≡ _i²_ is a thing. What sort of thing?

Taking the notion that since scaling by –1 reverses a positive quantity's direction, akin to a 180° rotation, and allowing that _i² = –1_, then scaling by _i¹_ is a 90° rotation, consistent with situating _i_ as orthogonal to the real number line. Following that reasoning, _i³ = –i_ and _i⁴ =  1_. Raising _i_ by integral powers is akin to 90° rotations on the complex plane. So if _x_ is a dezinen of the real number line then a scaling by _ix_ leaves it rotated 90° and aligned with the imaginary line. By extension, a number _a + ib_ is situated on the complex number plane at the point _a_ units along the real line and _b_ units along the imaginary line.

What does it mean to evaluate some pure imaginary quantity _iθ_ by the exponential function? Evaluating _exp(iθ)_ through the Taylor series, [Equation 3](#taylor), we uncover similar expansions for the cosine and sine functions. By substitution, we again have what Euler uncovered some two hundred eighty years ago:

===
$$
  \begin{array}{ll}
    e^{i \theta} = \exp(i \theta) = &1 + i \theta + \frac{i^2 \theta^2}{2!} + \frac{i^3 \theta^3}{3!} + \frac{i^4 \theta^4}{4!} + \cdots \\[0.5em]
    &\left( 1-\frac{\theta^2}{2!}+\frac{\theta^4}{4!}-\frac{\theta^6}{6!}+\cdots \right) + i\left(\theta - \frac{\theta^3}{3!} + \frac{\theta^5}{5!} - \frac{\theta^7}{7!}+\cdots\right) \\[0.5em]
    &\cos (\theta) + i\sin (\theta)
  \end{array}
$$
===

That is, _exp(iθ)_ looks like a unit vector rotated counterclockwise by angle θ, leaving projections _cos(θ)_ on the real axis and i•sin(θ) on the imaginary. Additionally, through the [law of exponents](https://en.wikipedia.org/wiki/Exponentiation#Identities_and_properties) expressions:

===
$$
e^ {i \theta} \cdot e^{i \phi} \implies e^{i( \theta + \phi)} 
$$
===
convey a sum of two rotations. Notational discomposures aside, then, expressions like:

= basicwheelie
===
$$
r \cdot e^{i2 \pi f t}
$$
===
are not Old School power raising so much as they are origin-rooted vectors with a length _r_, sweeping out 2π radian angles, counterclockwise, at a rotational frequency of _f_ over the period _t_: the quintessential wheelie.

Likewise, if the position of a complex plane point over time is governed by _d(t) = r·exp(it)_, — such as with the tip of a rotating wheelie, then its velocity over time is its first derivative:

===
$$
\begin{matrix}
v(t) = \frac{d}{dt}re^{ix} = ire^{ix}
\end{matrix}
$$
===
The first derivative scaled by _i_ is tantamount to giving the velocity vector a quarter turn from the displacement vector. Circular motion necessarily ensues, reprising [Figure 6](#phaseplot).

= fromwheelies
### From Wheelies, Arabesques

Let us combine wheelies:

= cesum
===
$$
\begin{matrix}
\psi (t) = 0.375e^{i2\pi t} + 0.3125e^{i2\pi 3t} + 0.25e^{i2\pi 8t} & \textsf{E. 4}
\end{matrix}
$$

= phasesum
|-![phasesum](images/phase_sum.mp4)
| *7. A cardinal sum and the related arabesque*
===

[Equation 4](#cesum) is a _cardinal sum_, an expression whose terms are fundamental wheelies. In isolation, wheelies plot circles, reprising [Figure 6](#phaseplot). In combination, more raveled arabesques ensue, such as [Figure 7](#phasesum).

The three wheelies here are so chosen to reproduce [threewheelie](#wheeliesample), an introductory arabesque. [Figure 7](#phasesum) depicts their complex plane plot. Their real and imaginary oscillations are not sinusoids, but combined partials.

In G'MIC, we write such cardinals sums with [Mathematical Expressions](https://gmic.eu/reference/mathematical_expressions.html), using `cexp()`; see _Threewheelie Redrawn_.

??? Threewheelie Redrawn.

~~~
 1    cexpsum:
 2       size=255
 3       # complex parameter ramp plotted on the imaginary axis
 4       -input 360,1,1,2,'[0,x/(w-1)]'
 5       -name. tau
 6
 7       # evaluate a wheelie-sum
 8       -fill[tau] "0.375*cexp(2*pi*I)+0.3125*cexp(2*3*pi*I)+0.25*cexp(2*8*pi*I)"
 9
10       # transform arabesque plots to a canvas drawing surface
11       -fill[tau] "begin(
12                          sw=get('size');
13                          id=eye(3);
14                          id[0]=sw;
15                          id[2]=sw;
16                          id[4]=-sw;
17                          id[5]=sw
18                        );
19                   (id*[I(x,y),1])[0,2]
20                  "
21       # paint the arabesque plot points on a canvas: white on black
22       -permute[tau] cyzx
23       -input {2*$size},{2*$size},1,1
24       -name. canvas
25       -eval[canvas] "begin(PV=crop(#0);
26                      polygon(#1,
27                              -int(size(PV)/2),
28                              PV,
29                              1,
30                              0xffffffff,
31                              255
32                             )
33                           )
34                     "

~~~

The gist of the computation, plotting an arabesque from three elements, occupies lines 4 and 8 to wit: the construction of a parameter range _t_, line 4, and its subsequent evaluation as [Equation 4](#cesum), line 8. In one fell swoop we obtain the plots the arabesque. The balance of the script concerns presentation housekeeping: setup and plotting.

???

The cardinal sum exposes a conspicuous disconnect _vis-à-vis_ [threewheelie](#threewheelie):

~~~
gmic -command scripts/wheelie_simple.gmic wheelie 512,0.375,0,1,0.3125,0,2,0.25,0,5
~~~

That is, the wheelies in the chain rotate, from root to tip, at frequencies _f_ = {1, 2, 5} Hertz:

= simple02
===
|-![simple_02](img/simple_02.png)
| *7. What gives? This arabesque comes from wheelies with one, two and five rotational rates!*
===

Yet with [Equation 4](#cesum), the frequencies in each term's exponential argument are _f_ ∈ {1, 3, 8}.

Both chain and sum produce the same arabesque, but seemingly from different frequencies. Further, we can reorder the terms of the cardinal sum in any way and the same arabesque obtains. Reorder wheelie chains however and different arabesques ensue.

Clearly, wheelie chains and cardinal sums are different quiddities, though both embody wheelies. Can we fix what one is in relation to the other?

A back-of-the-envelope doodle brings forth a pattern:
===
|1|⇒|1
|1+2|⇒|3
|1+2+5|⇒|8
===
A wheelie's _intrinsic_ orientation and rate of rotation — those measures with respect to its antecedent — do not reconcile with cardinal sums. But _running sums_ do. In particular:

| 1.  |Both the wheelie chain and sum have the same root wheelie.
| 2.  |The second wheelie in the chain exhibits an intrinsic frequency of two Hertz. Its antecedent rotates an additional Hertz. Accounting for both intrinsic and antecedent rotations yields three Hertz: its rotation _with respect to the coordinate frame_. That reconciles with the second term of the cardinal sum.
| 3.  |Similarly, the third wheelie in the chain has an intrinsic frequency of five Hertz and picks up three Hertz from antecedents. That combined frequency of eight Hertz reconciles with the third term of the cardinal sum.

= wheeliechainmap
===
|-![wheeliechainmap](images/wheeliechainmap.svg)
| *8. Walking from root to tip, accumulating rotations and orientations as we go.*
===

Past the root, a wheelie's intrinsic orientation and rotation rate encode a _difference_ — but a difference with what? The back-of-the-envelope doodle demonstrates that recombining wheelies along the chain from root to tip reconstitutes cardinal terms. The differences encoded by such _delta wheelies_ are between pairs of cardinal sum terms when these are ordered in a specific way, say the _Kth_ permutation. Concisely, the _nth_ term of a cardinal sum in permutation _K_ is:

===
$$
\psi_{n} (t) = r_{n} \cdot e^{i(2 \pi (\sum_{k=1}^{n} f_{k})t + (\sum_{k=1}^{n} \theta_{k}))}
$$
===
Put another way, the _nth_ term arises from the first _n_ delta wheelies, counting from the root. See [Figure 8](#wheeliechainmap). In a wheelie walk, not only do we recover the terms of the cardinal sum, we recover them in the order that they have been differenced.

This ordering is as specific to a particular wheelie chain as are the terms themeselves. Since the _N_ terms of some cardinal sum can be ordered in _N_ factorial ( _N!_ ) ways, it follows that there are _N!_ distinct wheelie chains that, when expressing rotational rate and orientation differences in a chain, produce the same arabesque, geometric differences among chains notwithstanding. [Figure 9](#wheeliepaths) classifies these wheelie chains for a four-term cardinal sum: 4! ⇒ 24.

= wheeliepaths
===
|-![wheeliepaths](images/wheeliepaths.svg)
| *9. Twenty Four ways (4!) to permute four cardinal terms*
===

Any one of the _N!_ paths from the cardinal sum to leaf represents both a wheelie chain and a particular permutation of terms, say the _Kth_ one.
= mkwheeliechain
#### Building Wheelie Chains
Starting with the _K_-permuted terms, build the allied wheelie chain by taking rotational rate and orientation differences between paired terms:

| 1.  |Let the initial term in permutation _K_ be the first delta wheelie, dw₀, in the chain.\n\nIn practice, we may not even care about a specific _K_ and choose a random term for the first delta wheelie. One permutation or another is always implicit in the very order that we pick terms for differencing.
| 2.  |For the remaining terms:
| 2a.  | Take the next term in the permutation.
| 2b.  | Subtract from this now-current term the previous term's rotational rate and orientation. These angular differences constitute the arguments to the exponential function of the new delta wheelie.
| 2c.  |Scale the new delta wheelie by the current term's radius.
| 2d.  |Include the now-complete delta wheelie in the chain.
| 3.  |If there are remaining terms, go to __2.__ Otherwise, the wheelie chain allied with permutation _K_ is complete.

= dualwheel
===
|-![dualwheel](images/dual.mp4)
| *10. Two chains, geometrically different, functionally equivalent, plotting the same arabesque*
===

Wheelie chains are just so many alternative ways to generate what _really_ corresponds to arabesques: cardinal sums. The wheelie chain for [threewheelie](#threewheelie), [Figure 7](#phasesum), happens to be just one of the 3! ⇒ 6 wheelie chains that also plot the very same arabesque.

= fromarabesques
### From Arabesques, Wheelies
= simple04
===
|-![simple_04](img/simple_04.png)
| *11.  An Unknown Cardinal Sum*
===
So much for putting things together. Now let's take things apart.

[Figure 11](#simple04) is an arabesque about which we know little. We might suppose that some cardinal sum defines it — but what are the terms? All that we have is a list of plot points. Can we find the cardinal sum that defines it?

The [law of exponents](https://en.wikipedia.org/wiki/Exponentiation#Identities_and_properties) provides a clue. From this law, the multiplication of two wheelies results in a successor rotating at the _sum_ of its antecedents, and starting from an orientation that is also the sum of its antecedents. Should the two antecedents form a _chiral pair_ then they "annihilate" each other in useful ways.

= cemult
===
$$
\begin{matrix}
r_{1}e^{i(2 \pi f_{1} t + \theta_{1})} \times r_{2}e^{i(2 \pi f_{2} t + \theta_{2})} \implies r_{1}r_{2}e^{i(2 \pi (f_{1} + f_{2}) t + (\theta_{1} + \theta_{2}))} & \textsf{E. 5}
\end{matrix}
$$
===

Chiral pairing. That's two wheelies with equal rotational rates but different handedness (or sign). Their radii may differ. So might their initial orientations. But it is the rotational rate that matters. [Figure 12](#wheeliemult) illustrates the case:

= wheeliemult
===
|-![wheeliemult](images/wheelmult.mp4)
| *12. Same rate. Opposite handedness. The wheelies collapse into a single, non-rotating phasor.*
===

|        |_Chiral pairs_, wheelies having like rotational rates but of different handedness, say, _f₁_ = 5 Hertz and _f₂_ = –5 Hertz, produce under multiplication time-invariant [phasors](https://en.wikipedia.org/wiki/Phasor). Under multiplication, the combined rotation rates of the two wheelies cancel, _t_ vanishing. What remains is a "residue" complex number, the phasor. In this example, the phasor's modulus is one and its angular argument is 60°.

= fourieralgol
Vanishing chiral pairs form the pith of an "analytical engine," one that picks out terms of an arabesque's cardinal sum. Here's the key: the product of any two wheelies can lead to only one of two cases:
| 1.  |__Case One: Not Chirals:__ The product wheelie has the same center of gravity as its antecedents. This is so because the product wheelie has _some_ non-zero frequency. Even if it is vanishingly small. Over the interval _t ∈ (–∞ to ∞)_, the _average_ position of of the orbiting point is exactly that of the center of the wheelie, identically with that of its antecedents.
| 2.  |__Case Two: Are Chirals:__ The product is a time-invariant phasor. For any interval _t_, the average position of the immobile phasor remains an offset from the antecedents' centers.

Consider [Figure 11](#simple04) again. Suppose some cardinal sum defines it. That cardinal sum has any number of non-zero terms. Suppose we multiply this sum by a trial unit wheelie: _r = 1, θ = 0°_ and some rotation _f_. By the Distributive Law, this consideration becomes a series of multiplications of the trial unit wheelie over each term of the cardinal sum. That operation gives rise to a new, _product arabesque_. It will have:

| 1.  |the same center of gravity as the unmultiplied arabesque, if all trial multiplications are Case One.
| 2.  |a different center of gravity from the unmultiplied arabesque, if at least one trial multiplication is Case Two.

In the second condition, the offset of the center of gravity stems from trial multiplications of chiral pairs. These generate phasors that skew the product arabesque some distance.
In that condition, the rate of rotation of the trial unit wheelie is the same as some terms of the otherwise unknown cardinal sum, but of opposite sign (handedness). We lose no generality by supposing there is only _one_ such term matching the trial wheelie's rate of rotation, for if it were otherwise then such terms of identical handedness and rates of rotation can be simply added up into one term. The orientation of this aggregate is just the sum of the terms with like rates of rotation.

When the second condition prevails, we may fully identify a term of the cardinal sum. Trivially:
| 1.  |the rate of rotation of the identified term, _f_, is that of the trial wheelie, but of opposite hand.
| 2.  |The orientation of the identified term, _θ_, is the sum of orientations of the identified term and the trial wheelie. Since the trial wheelie has an orientation of zero degrees, the sum of orientations _θ_ is wholly that of the identified term. In fact, this measure equals the orientation of the phasor.
| 3.  |Similarly, the radial length of the identified term, _r_, is the product of radii of the trial wheelie and the identified term. Since the trial unit wheelie has a radius of one, the radial product equals the length of the identified term. The phasor's length, then is _r_.

Recovery of all terms of the unknown cardinal sum follow from multiplying through with a sufficiently large set of trial wheelies, each of different frequency,  but together spanning a frequency range somewhat smaller than _f_ ∈ (–∞ to ∞), and yet "sufficiently large."

There remains one delicate matter. Strictly speaking, the data set making up the arabesque in [Figure 11](#simple04) is _not_ a cardinal sum. It is just a list of samples purporting to be "close" to a cardinal sum.

We concede this. That said, we can still regard these samples as those of a spline approximation of the (purported) cardinal sum. As an approximation, this spline will be as "like" the cardinal sum as the diameter of an error ball qualifies. With more samples — and assuming a sane approximation regimen like [least squares](#https://en.wikipedia.org/wiki/Least_squares) — that error ball gets smaller.

Cautionaries in mind, we then sally forth with a scheme for an "analytical engine:"

|__1.__|Choose a [Nyquist Sampling Rate](https://en.wikipedia.org/wiki/Nyquist_rate), _N_, "sufficiently large" to anticipate the fastest expected rotational rate _f_ — an educated guess to prevent the scheme from running forever.
|__2.__|Introduce a container of _2N + 1_ complex numbers, _S_ (for "spectrum"), initialized to zero.
|__3.__|Regard the arabesque under analysis, _A_, be the multiplicand in a series of trial multiplications with successive unit wheelie multipliers, _exp(–i2πft)_ for _f_ ∈ ( _–N,…, N_ ).
|__4.__|For _A_ and for each integer frequency _f_:
|__5.__|Evaluate the product _A × exp(–i2πft) ⇒ A'_.
|      |We evaluate the unit wheelie, _exp(–i2πft)_ over _t_ ∈ `[0 … 1]` for as many samples as those comprising _A_. This provides the multiplier data set. The pairwise multiplication of the two data sets implements _A × exp(–i2πft) ⇒ A'_.
|__5a.__|Take the difference of the average position of _A_ and _A'_  ⇒ _S[f]_.
|__5b.__|Case 1. _A'_ has a center of gravity unchanged from the multiplicand, _A_. _S[f]_ = 0i.
|__5b.__|Case 2. _A'_ has a center of gravity differing from the multiplicand, _A_. _S[f]_ ≠ 0i.
|__6.__|If _f_ < _N_, go to __4.__, otherwise go to __7.__.
|__7.__|The collection _S_ contains a _frequency domain spectrum_, coefficients approximating the cardinal sum defining arabesque _A_.

So long as the Nyquist Sampling Rate is sufficiently large, the collection _S_ holds the terms of a cardinal sum that approximates _A_. Should _N_ be too small, then the higher frequency terms of the cardinal sum are missing, the results effectively a low-bandpass version of _A_. The solution to that calamity is simple: just pick a higher Nyquist Sampling Rate and re-run the procedure.

Here is the "analytical engine" in operation:

= fmachine
===
|-![sampletester](images/time2freq.mp4)
| *13. Annihilating Wheelies Kicking the Center of Gravity*
===
|__Phase Diagram__| Presents successive _A × exp(–i2πft) ⇒ A'_ as _f_ ranges from –12 to 12 Hertz.\n\nThe effect of multiplying _A_ with successive unit wheelies first "winds" _A_ clockwise, then counterclockwise, around the origin. This effect stems from evaluating unit wheelies at successive time parameters _t_, varying from `[ 0,…, 1 ]`, engendering a unit vector array, each item rotated by an angle commensurate with _2πft_: zero, at _t_ = 0, 2πf at _t_ = 1.0 and proportionate otherwise. The evaluation _A × exp(–i2πft) ⇒ A'_ pairwise multiplies these unit vectors with their counterparty _A_ plots; by the laws of exponents an angular addition. Plots of _A_ displace around the origin at angular amounts equal to the paired unit vector's orientation and proportional to _t_, producing a "radially stretched" _A'_ that looks very different than _A_ — except when f = 0, allowing _A_ = _A`_.\n\nThis winding notwithstanding, the indication of wheelie annihilation is what lays bare a partial coefficient; the frequency _f_ at which annihilation occurs sets the coefficient's frequency domain abscissa; the modulus and angular argument of the partial comes from phasor residue.\n\nA red dot demarks the center of gravity of _A'_. In an ideal world where computation is instantaneous — so that Nyquist Sampling Rates can be infinite — the red dot shift from zero only at the precise frequency _f_ of a wheelie annihilation. Choosing finite Nyquist Sampling Rates inject various boundary conditions, inducing a center of gravity flutter within an error ball. This can certainly obscure small coefficients, rendering this "analytical engine" susceptible to imprecision, but not fatally so. At a frequency of annihilation, when chiral pairs vanish, the "residue" complex number illustrated in [Figure 12](#wheeliemult) appears; it offsets the center of gravity — the red dot — to a point on the complex plane equal to a partial of arabesque _A_.
|__Time Domain__|Draws the real and imaginary components of _A'_ in the time domain as _f_ ranges from –12 to 12 Hertz. The dotted vertical lines demark periods, each of duration _1/f_, and indicates the number of times _A'_ wraps around the origin. Notice that the stretching is very small on the left hand side, but large on the right, reflecting "radial stretching.".
|__Frequency Domain__|Tracks how _S_ fills with coefficients. The tracking does not portray coefficients as complex numbers; the frequency domain window displays their modulii but not their angular arguments. Limited as this presentation may be, non-zero coefficients pop up at abscissae _f_ ∈ {-5, -2, 1} Hertz. These are the coefficients of the cardinal sum which plots [Figure 11](#simple04), at least within the limits of working with an approximate dataset. Here is a table of where centers of gravity were maximally offset during the run of the "analytical engine":
===
|–step|Rectangular C.O.G.|Radial C.O.G.|Hertz
| 616|0.222752 –0.113498j|0.250 ∠ –27°|–5
| 880|0.358614 –0.109639j|0.375 ∠ –17°|–2
|1144|0.358614 –0.109639j|0.375 ∠ –17°| 1
===
The radial centers of gravity may be directly transcribed to a cardinal sum:

===
$$
\begin{matrix}
\psi (t) = 0.375 e^{i(2\pi 1 t + \mathtt{radians}(–17^{\circ}))} + 0.375 e^{i(–2\pi 2 t + \mathtt{radians}(–17^{\circ}))} + 0.25 e^{i(–2\pi 5 t + \mathtt{radians}(–27^{\circ}))} & \textsf{E. 6}
\end{matrix}
$$
===
To confirm that these coefficients hold, we may reverse wheelie walk along this particular permutation of the cardinal sum — it is as good as any of the other five — so as to obtain our delta wheelies: 0.375 ∠ 343° (-17°) @ –5 Hertz, 0.375 ∠ 0° @ -3 Hertz and 0.25 ∠ -10° (350°) @ -3 Hertz, and let them whirl:

= clover
~~~
randomclover:
   -command scripts/wheelie_simple.gmic
   -wheelie 512,0.375,343,1,0.375,0,-3,0.25,350,-3
   -name wheelie
   -dilate[wheelie] 8
   -label[wheelie] 3
   -input 1,10,1,3,u([255,255,255])
   -name palette
   -map[wheelie] [palette]
   -remove[palette]
   -gtutor_tileit[wheelie] 0,0.25,1,1,1,0,8,1
~~~

===
|-![randomclover](img/clover.png)
| *14 Arabesque Dressed in [Tiles](https://gmic.eu/tutorial/tiled_art.html)*
===

There are some of you out there, no doubt in moods admonitory, who would chastise us for this analytic engine foray.

Aye, that we could have applied the tilings and baubles and glitz direct to [Figure 11](#simple04), as it was already in hand, rather than fetch anew by some bonzer [Rube Goldberg apparatus](https://www.youtube.com/watch?v=VpLDfkLBJ0Q) — just the sort of superfluity that one might surmise of a New York City civil servant.

But — Phht! Have you no poetry, no sense of splendor, gracing your jaded soul, dear sir or madam? Have you not _any_ urge, whatsoever, to pass through vales that have no names, cross hither over to some shaded hollow, nestled along an uncharted stream, bird songs of unscored trills crowding the air?

There are things tenanting caves deep in yonder hills that fit no recorded taxonomy, and yet — here in the mysteries there are guises that strike some as familiar. This analytic engine, for instance, first turned its trick back in 1822, with [Jean-Baptiste Joseph Fourier's](https://en.wikipedia.org/wiki/Joseph_Fourier) _Théorie analytique de la chaleur_ ( "The Analytical Theory of Heat" ). It is the well known — celebrated, even — [Discrete Time Fourier Transform](https://en.wikipedia.org/wiki/Discrete-time_Fourier_transform). The collection _S_, the output of this algorithm, is (whimsically) comprised of phasor remnants of annihilated chiral pairs, but more formally constitute the [Fourier series](https://en.wikipedia.org/wiki/Fourier_series) representation of arabesque _A_, which has this general form:

= fseries

===
$$
\begin{matrix}
S_N(t) = \displaystyle\sum_{f = –N}^{N} c_{f} \cdot e^{i(2\pi f t + \theta)} & t \in [0,\dots ,1] & \textsf{E. 6}
\end{matrix}
$$
===
The template part of this summation may not be _quite_ like that of a [basic wheelie](#basicwheelie) — the coefficients are complex — but this is just a matter of notational rearragement. We can write any complex number as a phasor, to wit:

===
$$
\begin{array}{lll}
\text{1.} & c & \implies                                                                                \\
\text{2.} & a + ib & \implies                                                                           \\
\text{3.} & \sqrt{a^2 + b^2} \angle \arctan{ \frac{b}{a} } & \implies                                   \\
\text{4.} & \sqrt{a^2 + b^2} \cdot e^{i( \arctan{ \frac{b}{a}} )} & \therefore                          \\
\text{5.} & \sqrt{a^2 + b^2} \cdot e^{i( \arctan{ \frac{b}{a}} )} \cdot  e^{i(2 \pi f t + \theta )} & = \\
\text{6.} & r \cdot e^{i(2 \pi f t + \theta + \arctan{ \frac{b}{a}})}  & \because                       \\
\text{7.} & \sqrt{a^2 + b^2} = \| c \| = r
\end{array}
$$
===
| 1. |Recall that a complex number, _c_ has real and imaginary parts.
| 2. |Let _a_ represent the real component and _ib_ the imaginary component.
| 3. |Convert to polar form with a radial modulus and angular argument.
| 4. |Polar forms directly translate to phasors. This is _c_, rewritten as an exponential function.
| 5. |The summation's rewritten template stands revealed as a product of two exponential functions.
| 6. |Carrying through the multiplication puts the template part of Equation 6 in wheelie form.
| 7. |The emergence of _r_ may surprise. It's equivalent to the radical expression in _a_ and _b_, also the absolute value of _c_ and the radius of the wheelie.

Wheelies are Lego® blocks encapsulating a signed frequency ( _f_ ) an angular offset ( _θ_ ) and a magnitude ( _r_ ). Singly, they take the form of origin-centered vectors rotating on their tails. In cardinal sum combinations, they chart arabesques ever more sublime. But to chart with a chain of such, head to tail, as with Durga's compasses, then the delta wheelies between paired cardinal terms must be taken, the terms in some permutation.

Having devised a way to separate out heat propagation functions into coefficient terms Fourier could then demonstrate how coefficients proportionate to specific frequencies damp at rates faster than others. Two centuries on, his analytic engine has been applied to matters far beyond a theory of heat transfer, as proceedings from bird song to the dissassembly of arabesques lend themselves to such decompositions. With it, we may readily assay any time-varying dynamic to be an equivalent set of coefficients.

In G'MIC, ''-fft'' embodies this "analytic engine". Going from Arabesques to Wheelies harnesses this [Fast Fourier](https://en.wikipedia.org/wiki/Fast_Fourier_transform) implementation of analytic engine, and its companion sythesizer ''-ifft'' goes from Wheelies to Arabeseques. With these G'MIC commands, we can dissect or integrate arabesques in a straightforward manner. Spectralarabesque.gmic realizes this scheme:

??? spectralarabesque.gmic
~~~
  1 #@cli gtutor_fwheelie : radius₀,angle₀,angular_velocity₀…
  2 #@cli : Plot a two channel discrete frequency domain image corresponding to
  3 #@cli : the supplied wheelie parameters: +r, ±θ and ±f triplet(s) on the command
  4 #@cli : line, one triplet for each wheelie. Image suitable as a gtutor_specplot
  5 #@cli : selection, which generates the arabesque.
  6 #@cli : $ 1024,1024,1,1 gtutor_fwheelie. 0.5,67,1,0.25,0,-3 gtutor_specplot. name. circ_segment_triangle
  7 
  8 gtutor_fwheelie:
  9    # Pseudo assignment expands to command line arguments
 10    $=a
 11 
 12    # Expect data triplets $a1,$a2,$a3…
 13 
 14    -check {!($#%3)}
 15  
 16     $=a
 17     dwheelcnt={$#/3}
 18     -input $dwheelcnt,1,1,3
 19     -name. args
 20     -repeat $# j=$>
 21        if   $j%3==0
 22            -set[args] ${a{$j+1}},{int($j/3)},0,0,0
 23        elif $j%3==1
 24            -set[args] ${a{$j+1}},{int($j/3)},0,0,1
 25        else
 26            -set[args] ${a{$j+1}},{int($j/3)},0,0,2
 27        fi
 28     -done
 29     -store[args] deltawheelies
 30 
 31    foreach {
 32       # For each selected image:
 33       # Fetch and check radius
 34       # velocity parameters. Aggregate Σf ->$accsf; Σθ →$acca
 35       # specw={k=int(min(w,h)/2);!(k%2)?k+1:k}
 36       specw={int(min(w,h)/2)}
 37 
 38       #coeffcient image
 39       -input $specw,1,1,2
 40       -name carray
 41       -store[carray] coefficientarray
 42 
 43       # Iterate over arguments; populate carray and aggregate.
 44    
 45       -eval "const wc=$dwheelcnt;
 46              const sw=$specw;
 47          dw=get('deltawheelies',wc*3);
 48          ca=get('coefficientarray',sw*2);
 49          acca=0;
 50          accsf=0;
 51          repeat(
 52                       wc,
 53                       k,
 54                       r=dw[k];
 55                       acca+=deg2rad(dw[wc+k]);
 56                       accsf=dw[2*wc+k]+accsf;
 57                       aidx=accsf%sw;
 58                       ca[aidx]+=r*cos(acca);
 59                       ca[sw+aidx]+=r*sin(acca);
 60                    );
 61              store('coefficientarray',ca,sw,1,1,2)"
 62    
 63       # Scale freq. dom. by dom. length - for ifft.
 64       # carray: frequency domain image generated from
 65       # the given wheelie chain.
 66       -input $coefficientarray
 67       -name. carray
 68       -mul[carray] $specw
 69       -keep[carray]
 70    }
 71 
 72 #@cli gtutor_specplot : 
 73 #@cli : Generate a phase plot from the selected frequency
 74 #@cli : domain images.
 75 
 76 gtutor_specplot :
 77    -foreach {
 78         # Frequency domain → time domain
 79         -name. carray
 80         -split[carray] c
 81         -ifft[-2,-1]
 82         -append[-2,-1] c
 83         -name. temporal
 84         sw={w#$temporal}
 85      
 86         # Screenspace transform.
 87         -fill[temporal] ">
 88                          begin(
 89                                 specw=w#$temporal;
 90                                 id=eye(3);
 91                                 id[0]=specw;
 92                                 id[2]=specw;
 93                                 id[4]=-specw;
 94                                 id[5]=specw;
 95                               );
 96                          (id*[I(x,y),1])[0,2];
 97                        "
 98         -permute[temporal] cyzx
 99         -input {2*$sw},{2*$sw},1,1
100         -name. canvas
101         -eval[canvas] "begin(
102                               PV=crop(#$temporal);
103                               polygon(
104                                        #$canvas,
105                                        -int(size(PV)/2),
106                                        PV,
107                                        1,
108                                        0xffffffff,
109                                        255
110                                      )
111                             )"
112         -keep[canvas]
113      } #foreach
~~~
???

= spectralannotations
### Spectral Annotations

??? Weeds, for those close to the ground.
|  __Line__  |  __Remark__  
|  **17-61** | Command line management, **34-61**, largely follows from wheelie.gmic; see remarks there. Modularization distinguishes this implementation from that of wheelie_simple_simple.gmic. The plotting of the frequency domain with cardinal sums has been isolated to 'fwheelie'. The frequency domain transforming of the  domain and the subsequent rendering of the arabesque has been isolated to 'specplot.' The two may be invoked independently of one another, convenient for separating parsing from rendering. Emulation of the original 'wheelie' command becomes, then, a two-step affair:

~~~
$ gmic                                                             \
   scripts/spectralarabesque.gmic                                  \
   fwheelie 512,0.5000,30,1,0.2500,60,-2,0.5000,314,4,0.1250,32,-7 \
   specplot.
   …
~~~

|  | 'fwheelie' plots cardinal sums in the spectral domain, leaving its image on the list, while 'specplot' transforms and renders the arabesque in a phase diagram.
|  **31-61** |'carray' is the implementation of the 1-D, finite, circular and discrete frequency domain parameter space. The '-repeat' … '-done' loop, spanning **45,68,** parses wheelie specifications from the command line and and plots them in accordance to [Mapping Wheelies to the Frequency Domain](#mapwheelies); see the main text. 'carray' is the main product of 'fwheelie' and is left on the image list. Typically, 'specplot' uses 'carray' to plot the arabesque in an phase diagram.
|  **45-68** |'acca' implements _Σθ_; 'accsf' implements _Σ2πf_; 'sf' is a convenient pointer into 'carray', the frequency domain buffer. We plot ordinals via '-set', **65,66**. As noted in the prècis, we do not set the ordinal at abscissa coordinate '$sf'; we add to what is already there, for in light of wrap-around arithmetic we may visit a frequency coordinate any number of times.
|  **80-118** |specplot: Producing arabesque plot points is a two-step affair. The first step encompasses the transformation of the frequency domain image into its temporal counterpart; that is the nub of **83-89**; '-ifft' effects the inverse discrete Fourier transformation. This leaves temporal complex ordinals plotted along a temporal abscissa: this is the arabesque — but not in presentation form. The second step, **92-102,** makes it so. We harness the '-fill' command to rescale the ordinals to display dimensions based upon the pixel dimensional scaler '$sw'. [-fill](https://gmic.eu/tutorial/fill.html#math_expressions) takes a math expression argument which executes on every pixel. The math expression itself has two parts. The math expression function 'begin()' schedules run-once expressions before per-pixel iterations, ideal for setup. It has a counterpart, 'end()' which similarly schedules run-once expressions after per-pixel iterations, ideal for clean up. In this case, 'begin()' formulates a [homogeneous transform](https://gmic.eu/tutorial/tiled_art.html#affinetransform) for projecting ordinals into a display square. The body of the expression, **101**, applies this matrix to every pixel in the 'temporal' image, which, hitherto, were suitable for a 2 × 2 image centered on the complex plane origin; they are translated and scaled to plot on a '2·$sw' × '2·$sw' range with the coordinate in the upper left corner. Expression '(id*[I(x,y),1])[0,2]' may leave a first-time reader breathless. Within parentheses, matrix 'id', defined in the 'begin()' function, operates on homogeneous position coordinates, which have three elements. Trailing the parentheses, an accessor operator. This accessor extracts the first two elements of the three-element homogeneous position. The last line in the math expression, the '-fill' operator assigns this 2-vector to the current pixel, by the last statement returns values convention.
|  **75-87** |This final set of expressions renders the scaled and translated arabesque on a complex plane, 'canvas'.
|  **75** | Arabesque plots are permuted to lie along the spectral axis so that when they are imported into a math expression vector, the layout can be directly used by 'polygon()' See **79**.
|  **76-77** |'canvas' represents a 2·$sw × 2·$sw drawing space for 'polygon()'.
|  **78-87 **|The math expression function 'crop()' conveniently crops an image list item, organizing its pixels into a vector accessible by math expression functions. Referencing only an image, without crop limit parameters, transfers the image in its entirety into the math environment. 'PV', acquires the arabesque plot points and becomes a plotting source parameter to 'polygon().'

???

= totherebackagain
## To There And Back Again
Suppose we already have an arabesque, or, more broadly, an arbitrary shape topologically equivalent to a circle, but which has been suitably worked over by an Old School ash, 18 inch Louisville Slugger® so as to appear, say, like a 1911 Goudy Bookletter ampersand, over which some tutorial writers appear to be obsessed. Are there wheelies that could generate it?
= goudyampersand
===
| ![goudyampersand](images/ampersand_circ.svg)
|*14. Circle ~~slightly~~ ~~somewhat~~ substantially dented into the shape of a 1911 Goudy Bookletter ampersand*
===

To start, let an "arabesque" be any path that is topologically equivalent to a circle. Hijack the measure of angular displacement along a circle's circumference to also appraise the relative travel along a circle-like path. 180° (née π) is relatively half way around, whether in millimeters or miles.


Our overall game then runs along these lines:

|      1.  |Digitize the path: obtain discrete samples of the path at (presumably) equal time steps.
|      2.  |Find the frequency domain image of these samples through the discrete forward Fourier transform.
|      3.  |Compute the wheelies through any pair-wise differencing chain of some permutation _a_ of the non-zero ordinals in the frequency domain image.

While, in principle, we could use any permutation of non-zero ordinals, there are both whimsical and practical aspects of differencing "from the origin to the Nyquist rate."

= spectralpermutation
===
| ![spectralpermutation](images/spectralpermutation.svg)
|*15. Selection order for alternate clockwise and counterclockwise wheelies, large to small magnitude (usually...)*
===

In the vast majority of transformed digitized paths, the ordinals near the origin _2πf₀_ have the largest magnitudes; these decrease in progression along the abscissa to the Nyquist Rate. In accordance with the permutation of [Figure 14](#goudyampersand), we walk this progression down the abscissa, selecting first large, low-frequency ordinals, then the smaller, high-frequency ones. Whimsically we also alternately select clockwise and counterclockwise ordinals.

Next, we take differences in cardinal terms, these separate out the wheelie chain encoded by the permutation, one that reproduces the input path, following the pair-wise differencing scheme discussed before in [building wheelie chains](#mkwheeliechain).

'mkwheelielist', found in 'svgtowheelie.gmic', follows the pairwise-differencing scheme of a permutation that approaches the Nyquist Rate from both ends of the frequency domain. Details may be found in the script comments below and in [Path To Wheelie Annotations](#pathtowheelie). 'mkwheelielist' develops a text string of trios _r_, _θ_ and  _±2πf_, one for each ordinal difference, returning it in status.


??? svgtowheelie.gmic
~~~
  1 #@cli svg2wheelie : "file",_density,_wheeliecount
  2 #@cli : Generate wheelie triplets from samples of an SVG path. Requires
  3 #@cli : Python 3.x and python module svgpathtools by Andrew Port
  4 #@cli : (mathandy) et al. https://github.com/mathandy/svgpathtools.
  5 svg2wheelie:
  6 # Sample a closed Structured Vector Graphics (SVG) path at regular
  7 # intervals and from that, estimate the orientations, revolutions and
  8 # radii of a chain of wheelies, a.k.a. "epicycles" required to trace
  9 # that path. (1) path to an SVG file. Currently expects one defined
 10 # path, others are ignored. (2) Resolution sets the number of samples at
 11 # powers of two. Resolution → 8 → 2⁸ → 256 samples. Defaults to 10
 12 # (1,204 samples) (3) Limit the number of wheelies to the given
 13 # number. Defaults to 16.
 14
 15    check "isfile('${1}') &&
 16           isint(${2=10}) &&
 17           ${2}>0         &&
 18           isint(${3=16}) &&
 19           ${3}>2
 20          "
 21    fname=$1
 22    res=$2
 23    wcnt=$3
 24    normdiv=1
 25    svg2plots $fname,$res
 26    split. y
 27    fft[-2,-1]
 28    append[-2,-1] c
 29    name. spectral
 30    div[spectral] {w#$spectral}
 31    mkwheelielist[spectral] $wcnt
 32    wlist=${}
 33    rm.
 34
 35 #@cli mkwheelielist : wheelie_count
 36 #@cli : Selected image is a 2n,1,1,2 frequency domain map
 37 #@cli : ('spectral') for a Nyquist Sampling rate of n, a
 38 #@cli : count of pixels. Image from an forward discrete
 39 #@cli : Fourier transform of path samples (fft) with reals
 40 #@cli : occupying channel 0 and imaginaries occupying
 41 #@cli : channel 1. (1) wheelie_count: Limit the number of
 42 #@cli : wheelies to the given number. Defaults to 16.
 43 mkwheelielist :
 44    name. spectral
 45    check isint(${1=16})" && "${1}>2
 46    wcnt=$1
 47
 48 # Clear zero frequency, eliding any offset from
 49 # the complex plane origin. As a consequence, the
 50 # root wheelie originates at the origin.
 51
 52
 53    -set[spectral] 0,0,0,0,0
 54    -set[spectral] 0,0,0,0,1
 55
 56    # Image for dynamic array (da) storage of frequency
 57    # domain ordinals
 58
 59    -input 0
 60    -name. coefficients
 61
 62    # Scan spectral image for non-zero ordinals, as many
 63    # can be zero-length and have no bearing on the
 64    # arabesque. Setting wfound to the count of
 65    # non-zero, meaningful coeffiecients; the
 66    # coefficient image acquires the meaningful
 67    # coefficients, in polar form. Scan alternately down
 68    # the counterclockwise (m%2==0) and clockwise
 69    # (m%2!=0) portions of the frequency axis, toward
 70    # the Nyquist Sampling Rate mid-point. 'o' obtains
 71    # the rotational rate in each loop; 'j' is the index
 72    # to the currently assayed ordinal — it alternates
 73    # between clockwise and counterclockwise indices;
 74    # 'm' is the loopcounter.
 75
 76    wfound={">
 77             wc=get('wcnt',0,0);
 78             sz=0;
 79             repeat(2*wc,m,
 80                 sw=w#$spectral;
 81                 if(
 82                       m%2==0,
 83                       j=int(m/2)+1;
 84                       o=j,
 85                       j=sw-(int(m/2)+1);
 86                       o=-(int(m/2)+1)
 87                   );
 88                 rad=norm2(I(#$spectral,j,0));
 89                 if(rad>0,
 90                       ang=atan2(
 91                                  i(#$spectral,j,0,0,1),
 92                                  i(#$spectral,j,0,0,0)
 93                                );
 94                       ang=rad2deg(ang);
 95                       ang<0?ang=ang+360;
 96                       da_push(#$coefficients,[rad,ang,o])
 97                   );
 98                   );
 99             da_size(#$coefficients)
100            "}
101    -if $wfound
102
103    # The coefficient image may be manipulated as an
104    # image as well as a dynamic array; crop the
105    # penultimate and last pixel, containing the array
106    # length counter. The remainder of the array
107    # contains a permutation of non-zero
108    # coefficients. In this fill operation, we pair-wise
109    # difference them to separate out wheelies. By
110    # virtue of our "ends-to-the-middle" scan, we have
111    # prepared a permutation from which the slowest
112    # rotating wheelies are on the root end of the
113    # chain, alternating clockwise and counterclockwise
114    # rotating wheelies.
115
116       -crop[coefficients] 0,0,0,{$wfound-1}
117       -fill[coefficients] "<
118                              y==0?I:
119                              [
120                               i(0,y,0,0),
121                               i(0,y,0,1)-i(0,y-1,0,1),
122                               i(0,y,0,2)-i(0,y-1,0,2)
123                              ]
124                           "
125
126    # Turn negative angle orientations 360° to situate
127    # them between zero and three-sixty degrees.
128
129    -fill[coefficients] ">if(c==1,if(i<0,i+360,i),i)"
130    -fi
131
132    # Permute coefficient image in such a way as to
133    # order the data stream in magnitude, orientation
134    # and rotational rate triplets, as expected by
135    # wheelie plotters. Returned as a status string.
136
137    permute[coefficients] xczy
138
139    wheelie={crop(#$coefficients)}
140    -remove[coefficients]
141    -status $wheelie
142
143 #@cli svg2plots : "file",_resolution
144 #@cli (1) Retrieve the first path in the SVG 1.1 $file
145 #@cli argument and render it (2) at the indicated
146 #@cli resolution, a power of 2: $_resolution = 8 → 2⁸ → 256.
147 #@cli Resolution defaults to 10; paths are plotted
148 #@cli with 1,204 points.
149 svg2plots:
150    check "isfile('${1}') && isint(${2=10}) && ${2}>0"
151
152    # Python helper writes plots to a text file.
153    # We furnish a temporary file to receive its
154    # output.
155
156    -file_rand
157    outfile=${}
158    fname=$1
159    res=$2
160
161    # Assume a script subdirectory containing python helper
162    # See svghelper.py for details.
163
164    helpercommand="python scripts/svghelper.py \
165                   --normalize                 \
166                   --density "$res"            \
167                   --output "$outfile" "$fname
168
169    -exec $helpercommand
170    -if !isfile('$outfile')
171       error "Could not process "$outfile"!"
172    -fi
173    -input_csv $outfile,0
174    -delete $outfile
175    -permute. yxzc
~~~

???

= pathtowheelie
### Path To Wheelie Annotations

??? Path-to-Wheelie Annotations
|  __Line__  |  __Remark__  
|  **5-35** |'svg2wheelie' is a wrapper script that invokes, in succession, 'svg2plots', see **143,** and 'mkwheelielist', see **35**. Its arguments are (1) a path to an '.svg' file, (2) a plotting density and (3) a wheelie count. Plotting density is taken as a a power of two and resolves to the number of plotting points: 'density' → 9 → 2⁹ → 512 requests a path rendering of five hundred and twelve plots. The next number up, 10, requests 1,024 plots, and so on. 'wheeliecount' limits the number of computed wheelies. In effect, this argument acts as a lowpass filter, eliding the smaller, faster rotating wheelies toward the tip, retaining the larger, slower wheelies toward the root. A limit to sixteen wheelies can still give rise to output paths that are recognizably like the input path. The command returns a parameter list of wheelie triplets: _r_, _θ_, _±2πf_, as its status; Creating a pipeline variable from status substitution 'wlist=${}' is the typical next step. Being a wrapper, 'svg2wheelie' prepares arguments for 'svg2plots' and 'mkwheelielist.' It's main internal activity, **26-30**, entails transforming spatial plot points to a frequency domain image, from which 'mkwheelielist' generates a wheelie chain.
|  **35-141** |The 'mkwheelielist' selection decorator should reference a one dimensional frequency domain image of complex coordinates, typically a product of ''-fft'' that has been appended along the spectral axis. First, it clears 2πf₀ explicity to ensure that the arabesque is origin-centered. Second, it constructs a permutation where low rotational rate, likely large modulii, ordinals precede smaller and faster elements, culling any with a modulus of exactly zero, and alternately selecting ordinals from the counter-clockwise and clockwise regions of the image. See **76-100**. Finally, 'mkwheelielist'  pair-wise differences the ordinals, separating out the wheelies; see **103-141**.
|  **76-100** |'mkwheelielist' accumulates non-zero ordinals in a [dynamic array](https://gmic.eu/reference/mathematical_expressions.html#dynamic_arrays), backed by the 'coefficients' image, created for this purpose at **59-60**. This work takes place in the context of a math expression nominally designed to report on the number of non-zero ordinals found in the frequency domain image. The first part of the expression derives a frequency domain index, 'j' from loop counter 'm' that alternately selects from counterclockwise or clockwise regions of the frequency domain image. If the currently indexed ordinal has a non-zero modulus, _r_, the second part of the expression computes the argument angle, _θ_. The third piece of data needed to specify a wheelie, rotational rate, _±2πf_, derives in a fashion similar to the frequency domain index; as indexing proceeds from the the ends of the frequency domain image to the middle, '±(m/2)+1' increments through rotational rates _±2πf_. 'da_push()' inserts the _r_, _θ_ and _±2πf_ components into the dynamic array. These data do not yet identify a wheelie in the chain; differencing the angular components, _θ_ and _±2πf_ of this and adjacent ordinals in the permutation separate out those wheelies constituting the chain. See **103-141**.
|  **103-141** |The third section of the math expression separates out the wheelies constituting the chain, this through a pair-wise differencing iteration as discussed in [building wheelie chains](#mkwheeliechain). Though the 'coefficients' image serves as a backing store for dynamic arrays, it remains on the image list and assessible to ''-fill'' math expression arguments; it is through a ''-fill'' math expression argument that coefficients placed on the dynamic array stack are pair-wise differenced, separating out the wheelie chain. A second ''-fill'' command takes another math expression argument to ensure that all wheelie orientations fall in the range '[ 0,…,360° ]'. Having served its purpose as a container, 'mkwheelielist' removes the 'coefficients' image.
|  **143-175** |'svg2plots' is a path digitizer. Its particular approach, digitizing Structured Vector Graphics (SVG) paths, relies on a helper script, 'svghelper.py' to process '.svg' files. That helper script should reside in a directory on your 'PATH'. The care and feeding of shell paths are operating system dependent and off-topic here, but details may be found in [Exec Cheat](https://gmic.eu/tutorial/exec_cheat.html), which walks through 'svghelper.py' in its role as a G'MIC helper file. 'svg2plots' remit is to set up the helper script: creating a temporary file to receive digitized points from the helper, setting the plotting density and requesting scale-independent, normalized plot points. 'svg2plots' confines error checking to whether the requested temporary file exists, aborting if it does not. ''-exec'' furnishes its own error message as well. With success, the temporary file has numeric text strings, each plot datum represented with an floating point x-coordinate, a separating comma, a floating point y-coordinate and a terminating line feed.This layout is intended for G'MIC's ''-input_csv'' command. When its '_read_data_as' parameter is set to zero, that command produces a 2 × _<plot count>_ × 1 x 1 image which ''-permute'' "lays it on its side": a _<plot count>_ × 2 × 1 x 1 image. Row zero of this image consists of the real components of the plots, row one consists of the imaginary components. Typically, subsequent pipeline commands ''-split'' this image on the y axis; the two resulting images become inputs to the forward discrete Fourier transform: ''-fft'' to obtain frequency domain ordinals expressing the frequency distribution of the data set.

???

= wheelieanimations
## Wheelie Animations

In principle, the status string generated by 'svg2wheelie' may be passed to plotters like [wheelie](#wheelielist), but such would underwhelm. That plotter's remit is to draw arabesques from whimsically chosen wheelies. From wheelies derived from arabesques that look like ampersands it draws ampersands, which is imperfectly astounding, as the outcome looks like the given, unchanged.

What is missing, of course, are the gyrations of the wheelies themselves, so seemingly chaotic but, in fact, a choreographed ballet laid out with rocket-launch precision. The frequency domain of ordinals constitutes the master plan. Each pair-wise difference between ordinals dictates to wheelies but three things: length (_r_), orientation (_θ_), and rotational rate (_2πf_), a one-time decree that fully determines how the wheelie is to turn just so through time. This may be unremarkable in itself, but a long chain of wheelies, each programmed in such an unremarkable way, can collectively give rise to a wholly remarkable pirouetting, from which a 1911 Goudy Bookletter Ampersand emerges, perhaps, or an _art nouveau_ spectacular. So we need a wheelie plotter that illuminates this dance. 'wheelie_anim', found in 'wheelie_anim.gmic' module, takes a list of wheelie trios, either written by hand or generated by 'svg2wheelie', and plots both the arabesque and the wheelie chain generating it.

= genarabesque
===
![genarabesque](images/ampersand_anim.mp4)
|*16. 1911 Goudy Bookletter Ampersand via 1,024 wheelies*
===

 Unlike 'wheelie', 'wheelie_anim' works with a selection decorator so that certain features of the animation may be set '[ <drawingcanvas>, <multiplier>, <background> ]' images set the animation image size, fader rates and a predrawn backplate. A typical animation pipeline follows:
~~~
$ gmic                                                                       \
    -command svgtowheelie.gmic                                               \
    -command wheelie_anim.gmic                                               \
    -svg2wheelie "ampersand_circ.svg",9,256                                  \
    wlist=\${}                                                               \
    -input 600,600,1,3,'lerp([220,220,233,255],[160,240,255,255],y/(h-1))'   \
    -name. background                                                        \
    -input[-2] '(0.92^0.92^0.92^0.995)'                                      \
    -name.. multiplier                                                       \
    -input[-3] [background],[background],[background],4                      \
    -name... arabesque                                                       \
    -wheelie_anim[arabesque,multiplier,background] 300,0.5,\$wlist           \
    -remove.                                                                 \
    -resize 50%,50%,1,3,5                                                    \
    -output ampersand_anim.mp4,30,H264
~~~

??? wheelie_anim
~~~
  1 #@cli wheelie_anim : frames-per-rev,scale,r_0,phase_0,rot_rate_0,…
  2 #@cli : Compose arabesque rotational animation using a three image
  3 #@cli : selection: [-3] Transparent, optionally pre-drawn, image for
  4 #@cli : the arabesque. [-2]: four channel fader multiplier and [-1]:
  5 #@cli : background image. The number of wheelies follows from the
  6 #@cli : argument triplet count following "scale". A single triplet
  7 #@cli : of three arguments specifies length, r, orientation θ and
  8 #@cli : rotational rate of one wheelie. It is an error if the argument
  9 #@cli : list, "less frames-per-rev" and "scale" is not divisible by
 10 #@cli : three. Replaces selection with (1) an animation image
 11 #@cli : sequence of a length equal to the frames_per_revolution
 12 #@cli : argument, and (2) the arabesque transparency reflecting the
 13 #@cli : last frame state, suitable for use as a pre-drawn image for
 14 #@cli : successor arabesque animations.
 15
 16 wheelie_anim:
 17    # wheelie: a segment of a particular (1) radius, (2) phase
 18    # angle (orientation) and (3) discrete angular velocity - a
 19    # relative integral number of revolutions per some unspecified
 20    # base interval, perhaps however long one revolution
 21    # takes. Wheelies chain together, the tail of one situated at
 22    # the head of its antecedent. The first wheelie of the chain
 23    # centers at the origin and the last has, instead of another
 24    # wheelie, an attached marking pen. Thus, the entire chain
 25    # draws an "arabesque" as the individual wheelies rotate at
 26    # their respective angular velocities from their initial
 27    # orientations. This script animates such.
 28    #
 29    # This script renders arabesques "traditionally": Each wheelie
 30    # has radial, phase and angular velocity components.  For each
 31    # increment, and, for each wheelie, apply the angular velocity
 32    # increment, rotating the wheelie, then, with all wheelies
 33    # rotated, plot the endpoint.
 34
 35    emsg="
 36       Select three images, to wit: [-3]: Transparent, optionally
 37       pre-drawn, image for the arabesque. [-2]: four channel fader
 38       multiplier and [-1]: three channel background image; 1:1
 39       aspect ratio works best."
 40
 41    -if size([$[]])!=3
 42       -error $emsg
 43    -fi
 44    -name... arabesque
 45    -name..  multiplier
 46    -name.   background
 47    -resize[multiplier] [arabesque],[arabesque],[arabesque],[arabesque],1
 48    -remove_opacity[background]
 49    -store[multiplier] multiplerimage
 50    -local[arabesque,background]
 51       # Fetch an arbitrarily long argument list to $a0, $a1, …, $an
 52       $=a
 53
 54       # Expect argument one as initial frames per revolution,
 55       # Expect argument two as canvas image scaler
 56       # followed by data triplets: radius, r, phase angle, θ,
 57       # angular velocity, 2πf.
 58
 59       -check {!(($#-2)%3)}
 60
 61       # Initial argument: frame count per revolution
 62       -check "isint($a1) && $a1>0"
 63       frames_per_rev=$a1
 64       -check isnum($a2)" && "$a2>0
 65       scaler=$a2
 66
 67       # scaling width is the smallest dimension
 68       sw={min(w,h)/2}
 69       -if $sw%2==0
 70          sw+=1
 71       -fi
 72
 73       # Circles argument vector: For each wheelie, compose
 74       # radius and phase arguments into a homogeneous
 75       # transform. In the animation loop, we compose this
 76       # with the "angular tick dependent" (atk) rotational
 77       # transform to plot the wheelie in an generic
 78       # plotting space.
 79
 80       wcnt={round(($#-2)/3,1,-1)}
 81       -input $wcnt,1,1,12
 82       -name. args
 83
 84       # Iterate over argument vector. For each triplet –
 85       # representing a wheelie circle – Fetch radius (rad:
 86       # r), phase angle (ang: θ) and angular velocity (sf:
 87       # ±2πf) parameters.
 88
 89       -repeat $#-2 j=$>
 90          -if   $j%3==0 # get radius
 91             rad=${a{3+$j}}
 92             -check isnum($rad)" && "$rad>=0
 93             -set[args] $rad,{round($j/3,1,-1)},0,0,0
 94          -elif $j%3==1 # get angle, degrees
 95             ang=${a{3+$j}}
 96             -check isnum($ang)" && "$ang>=0" && "$ang<=360
 97             -set[args] $ang,{round($j/3,1,-1)},0,0,1
 98          -else         # get 2πf and set spectral coefficient
 99             sf=${a{3+$j}}
100             -set[args] $sf,{round($j/3,1,-1)},0,0,2
101          -fi
102       -done
103
104       # Iterate over argument image, each 12 channel pixel
105       # representing one wheelie. The first three channels
106       # contain wheelie radius, phase angle and radial
107       # velocity. Compose a homogeneous matrix
108       # transforming the origin to the tip of the wheelie
109       # radius, a radial translation and phase
110       # rotation. Populate the nine remaining channels
111       # with this matrix.
112
113       -fill[args] ">
114                      CPX=I;
115                      orot=rot(          # phase rotation
116                                [0,0,1],
117                                deg2rad(CPX[1])
118                              );
119                      xlat=eye(3);
120                      xlat[2]=CPX[0];    # translation
121                      [                  # args+rot & xlation
122                        CPX[0,3,1],      # arguments
123                        mul(orot,xlat,3) # time-independent
124                      ]                  # matrix
125                   "
126       -permute[args] cyzx
127       -store[args] circles
128
129       # Partial screenspace transform.
130       ssxfrm={">
131                  specw=get('sw',0,0);
132                  scaler=get('scaler',0,0);
133                  id=eye(3);
134                  id[0]=specw/scaler;
135                  id[2]=specw;
136                  id[4]=-specw/scaler;
137                  id[5]=specw;
138                  id"}
139
140       # Homogeneous position vectors for plotting
141       # initial/final segments
142       tracerim={vector3([0,0,1])}
143       firstpt={vector3([0,0,1])}
144
145       # Transparent image to plot wheelies themselves
146       -input [arabesque],[arabesque],[arabesque],[arabesque]
147       -name. wheelplot
148
149       # Stash background for duplication in loop
150       +store[background] back
151
152       # Animate arabesque: 'angular tick dependent' → atk
153       atk=0
154       -repeat $frames_per_rev k=$>
155          atk={2*pi*($k/($frames_per_rev-1))}
156          -local[arabesque,background,wheelplot]
157              -input $multiplerimage
158              -mul[arabesque,multiplier]
159
160              # Plot wheelie indicators: rotate wheelies
161              # by their respective angular velocity
162              # increments, compose this rotation into
163              # the pre-computed phase,
164              # radial-displacement transform from the
165              # argument image, compose with screenspace
166              # transform and plot via polygon()
167
168              -eval[wheelplot] ">
169              begin(
170                 wcnt=get('wcnt',0,0);
171                 omega=get('atk',0,0);
172                 fpr=get('frames_per_rev',0,0);
173                 ik=get('k',0,0);
174                 fpt=get('firstpt',3,0);
175                 trc=get('tracerim',3,0);
176                 pp=vector"{3*($wcnt+1)}"([0,0,1]);
177                 circs=get('circles',"{12*$wcnt}",0);
178                 repeat(
179                      wcnt,k,
180                      idx=wcnt-k-1;
181                      rbradx=mul(
182                                  rot(
183                                      [0,0,1],
184                                      circs[12*idx+2]*omega
185                                     ),
186                                  circs[12*idx+3,9,1],
187                                  3
188                                );
189                      repeat(
190                              k+1,j,
191                              foo=rbradx*pp[3*(k-j),3];
192                              pp[3*(k-j)]=foo[0];
193                              pp[3*(k-j)+1]=foo[1];
194                              pp[3*(k-j)+2]=foo[2];
195                            )
196                       );
197                 ssx=get('ssxfrm',9,0);
198                 repeat(
199                        wcnt,k,
200                        p0=ssx*pp[3*(k),3];
201                        p1=ssx*pp[3*(k+1),3];
202                        polygon(#$wheelplot,
203                                 -2,
204                                 [p0[0,2],p1[0,2]],
205                                 1,
206                                 0xffffffff,
207                                 [115,160,205,255]
208                               );
209                        ellipse(#$wheelplot,
210                                p0[0,2],
211                                1,
212                                1,
213                                0,
214                                1,
215                                [230,90,45,255]
216                               );
217                      );
218                 plt=ssx*pp[0,3];
219                 ik>0?
220                    polygon(#$arabesque,
221                            -2,
222                            [plt[0,2],trc[0,2]],
223                            1,
224                            0xffffffff,
225                            [255,200,100,255]
226                           ):
227                    store(plt,'firstpt',3,1,1,1);
228                 store(plt,'tracerim',3,1,1,1);
229                 ellipse(#$wheelplot,
230                         plt[0,2],
231                         2,
232                         2,
233                         0,
234                         1,
235                         [230,90,45,255]
236                        );
237                 ik==(fpr-1)?
238                    polygon(#$arabesque,
239                            -2,
240                            [fpt[0,2],plt[0,2]],
241                            1,
242                            0xffffffff,
243                            [255,200,100,255]
244                           )
245                   )
246                               " # end of eval
247              -blend[background] [arabesque],alpha
248              -blend[background] [wheelplot],alpha
249              -mul[wheelplot] 0
250              -mv[background] 0
251              -name[background] frame-$k
252          -done # local environment
253          -input[-2] $back
254       -done # repeat frames per 360° revolution
255       -rm[wheelplot,background]
256    -done # local argument environment of [arabesque,background]
257
258 #@cli durga : _radius_0,_phase_0,_angular_velocity_0,…
259 #@cli : Sequence a series of animations by successively adding
260 #@cli : wheelies, one at a time, starting with the initial wheelie
261 #@cli : that just generates a circular arabesque. Furnish any number
262 #@cli : of wheelie triplets in the argument list, or leave that list
263 #@cli : empty; durga will generate a list of five randomly composed
264 #@cli : wheelies. Selected image sets the animation size and
265 #@cli : background composition. Framerate is fixed at 24
266 #@cli : frames/second. Select the background image to set animation
267 #@cli : frame size. Arguments should be in groups of three: radius,
268 #@cli : phase, angular velocity.
269
270 durga : -skip "${1=}"
271    emsg="Select the background image to set animation frame size.
272          Arguments should be in groups of three: radius, phase,
273          angular velocity."
274    frames={24*6}
275    -local[]
276       is_arg={isnum("$1")}
277    -onfail
278       is_arg=0
279    -done
280    -if size([$[]])==0
281       -input 300,300,1,3,lerp([200,200,230],
282                               [230,200,200],
283                   y/(h-1)
284                  )
285    -fi
286
287    # Create, get construction images
288    -name. background
289    -remove_opacity[background]
290    -input[-2] (0.99^0.94^0.92^0.998)
291    -name.. multiplier
292    -input[-3] [background],[background],[background],4
293    -name... arabesque
294
295    # Wheelie arguments?
296    -if $is_arg>0
297       -if $#%3==0
298          $=a
299          wcnt={$#/3}
300          ra=''
301          ph=''
302          av=''
303          -repeat $# j=$>
304             -if $j%3==0 # get radius
305                    rad=${a{1+$j}}
306                -check isnum($rad)" && "$rad>=0
307                ra={[[$ra],[$rad]]}
308             -elif $j%3==1 # get angle, degrees
309                ang=${a{1+$j}}
310                -check isnum($ang)" && "$ang>=0" && "$ang<=360
311                ph={[[$ph],[$ang]]}
312             -else         # get 2πf and set spectral coefficient
313                sf=${a{1+$j}}
314                -check isint($sf)
315                av={[[$av],[$sf]]}
316             -fi
317          -done
318          ra={[$ra][1,size([$ra])-1,1]}
319          ph={[$ph][1,size([$ph])-1,1]}
320          av={[$av][1,size([$av])-1,1]}
321       -else
322          -error $emsg
323       -fi
324    # No arguments. Make up our own. Fixed at
325    # 5 wheelies, no phase displacement.
326    -else
327       wcnt=5
328       ra={u(vector$wcnt(1))}
329       ph={vector$wcnt(0)}
330       av={"
331              rad=u(k=vector$wcnt(1.5))-0.75;
332              sgn=2*round(rad,1,1)-1;
333              mag=sort(abs(5*rad),1);
334              rmag=round(mag/min(mag),1,1);
335              rmag*sgn
336          "}
337    -fi
338
339    args=""
340    +store[multiplier,background] animback
341    -repeat {$wcnt} i=$>
342       -local[arabesque,multiplier,background]
343          acnt={size([$args])}
344          wcount={$acnt/3}
345          newargsz={$acnt+3}
346          args={"
347                  RA=get('ra',$wcnt,0);
348                  PH=get('ph',$wcnt,0);
349                  AV=get('av',$wcnt,0);
350                  RL=RA[0,$wcount+1,1];
351                  scale= 1.0/sum(RL);
352                  RL=round(RL*scale,0.01,0);
353                  NAR=vector$newargsz(0);
354                  repeat($wcnt+1,k,
355                         NAR[3*k]=RL[k];
356                         NAR[3*k+1]=PH[k];
357                         NAR[3*k+2]=AV[k]
358                        );
359                  NAR
360               "}
361          -wheelie_anim[arabesque,multiplier,background] $frames,1.125,$args
362          -input $animback
363       -done
364    -done
365    -remove[arabesque,multiplier,background]

~~~

???

Alas, the primary difference between 'wheelie_simple.gmic' and 'wheelie_anim.gmic' are the inclusion of animation loops. G'MIC animation is worth a Cookbook article or more in its own right, and should we persue it in detail here we will wander too far into the weeds.

In broad strokes, the animation loop technique harnessed in 'wheelie_anim.gmic' is a frame generator that draws a time-slice frame for each loop iteration. Frame generators leave a large sequence of images on the list — but not a single image composed of a lot of slices. the ''-output'' command is sensitive to file extensions for video formats. Depending on particular video formats, the video format file name given as an argument to '-output' can take a list of comma separated qualifiers; you could manage specifics of the output such as the video frame rate or compression format. For example, this undecorated '-output' command:

~~~
 -output ampersand_anim.mp4,30,H264
~~~

will incorporate _every_ image on the list into a thirty frame-per-second animation, the video following the [H264 video compression standard](https://en.wikipedia.org/wiki/Advanced_Video_Coding). See [Input/Output Properties](https://gmic.eu/reference/input_output_properties.html#top) for the qualifiers appropriate for each video format.

= postscript
## PostScript
When finding wheelies to plot various dented circles, our feet land on a well-trodden path. Going back a decade or more, there have been eruptions of [fantastic constructions](https://www.youtube.com/watch?v=-qgreAUpPwM) of gyrating arrows that do etch-a-sketch things: drawing birds, flowers, even portraits of Jean-Baptiste Joseph Fourier or Santiago Ginnobili's [Homer Simpson](https://www.youtube.com/watch?v=QVuU2YCwHjw).

Probably the best adjunct to this Beginner's Cookbook is two Grant Sanderson (3blue1brown) videos [But what is the Fourier Transform? A visual introduction.](https://www.youtube.com/watch?v=spUNpyF58BY) and its companion [But what is a Fourier series? From heat flow to drawing with circles](https://www.youtube.com/watch?v=r6sGWTCMz2k).

Our wheelie is a pseudonym for an _epicycle_ in these other ouvres. If you wish to google your way to other approaches, the search terms [epicycle fourier](https://www.google.com/search?q=fourier+epicycles&client=firefox-b-1-e&sxsrf=APq-WBsmUcpj0VazeDX0ypEoGPIb0xKX3w%3A1649089042403&ei=EhpLYvShGOukptQPhKqAuAE&ved=0ahUKEwj08sy05_r2AhVrkokEHQQVABcQ4dUDCA0&uact=5&oq=fourier+epicycles&gs_lcp=Cgdnd3Mtd2l6EAMyBAgjECcyBAgAEEMyBQgAEIAEMgUIABCGAzIFCAAQhgMyBQgAEIYDMgUIABCGAzIFCCEQoAE6BwgjELADECc6BwgAEEcQsANKBAhBGABKBAhGGABQuglYuglglBtoAXABeACAAeoBiAHqAZIBAzItMZgBAKABAcgBCcABAQ&sclient=gws-wiz#bsht=CgRmYnNtEgIIBA) provides a nice survey. In [ Epicycles, complex Fourier series and Homer Simpson's orbit ](https://www.youtube.com/watch?v=qS4H6PEcCCA) [Burkard Polster](https://en.wikipedia.org/wiki/Burkard_Polster) ( "Mathologer" ) uses Santiago Ginnobili's epicyclic rendering of Homer Simpson as a jumping off point as to what may be going on with all of those circles. [Daniel Shiffman ( aka Coding Train )](https://www.youtube.com/watch?v=MY4luNgGfms) runs through a JavaScript implementation; other implementations in other languages abound. But this is G'MIC's very own way. Enjoy.

