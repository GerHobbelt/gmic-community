# Arabesques
%% x "mkdir -p img" %%
%% -m scripts/wheelie_anim.gmic input 600,600,1,3,lerp([219,214,233],[219,187,91],y/(h-1)) durga. 1,0,1,0.5,0,-3,0.5,0,-2,1,0,1 [-1]x48 erode_circ 2 -resize 50%,50%,1,3,5 o img/arabesque.mp4,24,H264 rm %%
|![Arabesque](img/arabesque.mp4)\n               *"Durga's idle arabesques"*|During brief interludes when tranquility prevails and the peoples of the world are in complete accord, Durga might take ease from her duties and find serenity through simple pursuits.\n\nIt is a small pleasure to swing a compass marker around its anchor leg, and if hands quop or quave, arcs still run true — not that palsy ever troubles Durga, master as she is of the _chakra_ and _trishul_. And so it is hardly burdensome for her to take up compass after compass, anchor to marker, twirling each at speeds, directions and separations sought through whimsy.\n\nSuch a flurry of hands and arms may strike mortals dumb with astonishment, but for the slayer of the abominable Mahishasura it is just so many twirlings. With each added compass, the culminating marker traces ways ever more sublime, awarding Durga escalating delights. And so it goes — until demons arise. Durga must then put away her compasses and take up her arrows and bow.
= wheelie
### Wheelies
Deficient as we are in arms, it is only through _wheelies_ that we might do what hands cannot. A wheelie models a compass pair: one end is an anchorage and the other swings free. We emulate Durga's trivial pursuit through a chain of such, anchor to marker, drawing arabesques of ever more intriguing complexity.

With each we may:

|      1.  |set a particular radius:|      _r_
|      2.  |pick a starting orientation:|      _θ_
|      3.  |choose a signed, clockwise or counterclockwise, rotational rate:|     _±ω_

A one-wheelie chain holds little fascination — it draws a circle — but is instructive nonetheless. Absolutes do not matter. A revolution may draw a circle in a microsecond or a millenium, but the time so taken does not alter the outcome. It is the drawing, and not the duration of its drafting, that matters.

While wheelies may be divorced from absolutes, relatives matter. A wheelie rotating at three times the rate of its antecedent will plot a track differing from one rotating twice as much. Ditto with lengths. Centimeters or kilometers do not matter. It is that one wheelie is two-thirds the length of the other and necessarily will trace a path that differs from one at a ratio of three quarters. Ratios matter more than measures. Taking wheelies two-by-two and determining the shift from one to the other is the work put out for us.

Here then is the outline of our play:

|      1.  |root the first wheelie at the origin.
|      2a.  |root the other wheelies at successive free end points, perhaps setting their orientation differently or aligning them all. Do that any number of times, _or_
|      2b.  |attach a marker to the rim of a terminal wheelie and be done.

Circular motion is easy to fathom, but not too many wheelies in and complexity strikes us dumb. The remedy for that is patterns which, in recurrence, divide and conquer.

Paired wheelies provide the unit pattern. We can, in a relative world, choose whatever coordinate system that pleases us. So we first regard one wheelie in isolation and decide that it has an orientation of zero degrees and is aligned with the _x_ axis. Now bring in the antecedent, whose tip coincides with the origin of our wheelie. Our wheelie's length, _r_, and its orientation _θ + ωt_, informs us how the tip of our wheelie sits in relation to its antecedent, where the latter angle term of orientation, _ωt_, arises from the product of angular velocity multiplied with the accumulation of successive ticks: _ωt = ω(Δt₀ + Δt₁ + … )_. We can write an affine matrix describing how a point starting at the origin — also the tip of the antecedent — translates by _r_ and rotates by _θ + ωt_ to arrive at our wheelie's tip.

===
![wheeliediagram](images/wheeliewalk.svg)
*Walking from marker tip to the origin*
===

In the spirit of divide-and-conquer, we may start with the terminal wheelie and write an [affine matrix](https://gmic.eu/tutorial/tiled_art.html#affinetransform) that describes how it sits in relation to its antecedent:

===
$$
\begin{bmatrix} m_x \\ m_y \\ 1 \end{bmatrix} =
\begin{bmatrix}
\-cos (\theta + \omega t) & -\-sin (\theta + \omega t) & r_x \\
\-sin (\theta + \omega t) & \-cos (\theta + \omega t) & r_y \\
0 & 0 & 1
\end{bmatrix}
\begin{bmatrix} o_x \\ o_y \\ 1 \end{bmatrix}
$$
*Wheelie matrices*
===

Over time, as _Δt_ accumulate and _ωt_ changes, we expect the tip of the wheelie to plot a circle of radius _r_; not very interesting, but something we can readily grasp. Now we shift our attention to the antecedent wheelie and write a second matrix that describes how its tip sits in relation to its antecedent. Another circular track. So, to characterize _both_ tracks, how the tip of the terminal wheelie sits in relation to the penultimate's origin, we composite the two matrices from right to left.

In the algebra of matrices, multiplication does not commute. Order matters. So we compose matrices in the same order that we walk. Along we go, walking from wheelie to wheelie, compounding individual circular motions as we go, obtaining the composite motion of the tip. That stepwise writing of matrices and their aggregation into one is our divide-and-conquer play. The arabesque of the whole arises from the plots of the parts. This is not too far removed from what a rigger would set up in character animation: composing the transform of the finger, the wrist, the forearm, the upper arm. Each have their own local transforms that can be animated locally, then consolidated into aggregated motion. 

And with that, we\'re done. The composite matrix transforms the origin of the entire ensemble to the marker of the final wheelie, accounting for all intermediary rotations and translations. Plot the mark. Then, on the next tick, account for the effects of _Δt_ on all the orientations and walk the wheelie chain again.

That's the game — and our play. All we have to do is code.

??? wheelie.gmic
~~~
   1 wheelie :
   2    # wheelie: a circle of a particular (1) radius, (2) phase angle
   3    # (orientation) and (3) discrete angular velocity - a relative
   4    # integral number of revolutions per however long one revolution
   5    # takes. Wheelies chain together, the center of one situated at 0°
   6    # on the rim of its predecessor. The first wheelie of the chain
   7    # centers at the origin and the last has, instead of another
   8    # wheelie, an attached marking pen. Thus, the entire ensemble draws an
   9    # "arabesque" as the individual wheelies rotate at their respective
  10    # angular velocities from their initial orientations.
  11 
  12    # Fetch an arbitrarily long argument list to $a0, $a1, …, $an
  13 
  14    $=a
  15 
  16    # Expect data triplets: radius, phase angle, angular velocity.
  17 
  18    -check "isint($a1) && !(($#-1)%3)"
  19 
  20    # Initial argument: side width (sw)
  21 
  22    sw={$a1/2}
  23 
  24    # Argument image 'args': For each wheelie, compose radius and phase
  25    # arguments into a transformation matrix. In the generation loop, we
  26    # compose this with the angle resulting from one angular velocity
  27    # step.
  28 
  29    ccnt={int(($#-1)/3)}
  30    -input $ccnt,1,1,12
  31    -name  args
  32 
  33    # Iterate over argument vector. For each triplet – representing a
  34    # wheelie – Fetch radius (rad), phase angle (ang) and angular
  35    # velocity (sf) parameters.
  36 
  37    -repeat $#-1,j
  38       -if   $j%3==0 # get radius
  39          rad=${a{2+$j}}
  40          -check isnum($rad)" && "$rad>=0" && "$rad<=1
  41          -set[args] $rad,{round($j/3,1,-1)},0,0,0
  42       -elif $j%3==1 # get angle, degrees
  43          ang=${a{2+$j}}
  44          -check isnum($ang)" && "$ang>=0" && "$ang<=360
  45          -set[args] $ang,{round($j/3,1,-1)},0,0,1
  46       -else         # get ω and set spectral coefficient
  47          sf=${a{2+$j}}
  48          -check isint($sf)" && "abs($sf)<=0.1*$sw
  49          -set[args] $sf,{round($j/3,1,-1)},0,0,2
  50       -fi
  51    -done
  52 
  53    # Iterate over argument image, each 12 channel pixel representing
  54    # one wheelie. The first three channels contain wheelie radius,
  55    # phase angle and radial velocity. Compose a matrix transforming
  56    # the origin to the tip of the wheelie, a radial translation and
  57    # phase rotation. Populate the nine remaining channels with this
  58    # matrix.
  59 
  60    -fill[args] ">
  61                   CPX=I;
  62                   orot=rot([0,0,1],deg2rad(CPX[1])); # phase rotation
  63                   xlat=eye(3);
  64                   xlat[2]=CPX[0];                    # translation origin
  65                   FIN=[CPX[0,3,1],mul(orot,xlat,3)]; # -to-rim, i.e.
  66                   FIN                                # 'rotation & xlat'
  67                "                                     # store above in
  68                                                      # 12-channel pixel
  69    -permute[args] cyzx
  70    -store[args] circles
  71 
  72    # Screenspace transform.
  73    ssxfrm={"
  74             specw=get('sw',0,0);
  75             id=eye(3);
  76             id[0]=0;
  77             id[1]=specw/2;
  78             id[2]=specw;
  79             id[3]=-specw/2;
  80             id[4]=0;
  81             id[5]=specw;
  82             id
  83            "}
  84 
  85    # Draw arabesques on this image
  86    -input {2*$sw},{2*$sw},1,1
  87    -name. canvas
  88 
  89    atk=0
  90    lastpt={vector3([0,0,1])}
  91    firstpt={vector3([0,0,1])}
  92    -repeat 3*$sw,k
  93        # For each wheelie:
  94        # increment by angular velocity
  95        # find corresponding rotation matrix
  96        # compose with radial argument image, compose
  97        # with screenspace transform and plot via polygon().
  98 
  99        -eval ">
 100               const cc=$ccnt;
 101               fpt=get('firstpt',3,0);
 102               ik=get('k',0,0);
 103               lpt=get('lastpt',3,0);
 104               omega=get('atk',0,0);
 105               specw=get('sw',0,0);
 106               circs=get('circles',12*cc,0);
 107               pp=vector3([0,0,1]);
 108               imat=eye(3);
 109               repeat(
 110                        cc,k,
 111                        idx=cc-k-1;
 112                        imat=mul(
 113                                    mul(
 114                                         rot([0,0,1],circs[12*idx+2]*omega),
 115                                         circs[12*idx+3,9,1],
 116                                         3
 117                                       ),
 118                                    imat,
 119                                    3
 120                                );
 121                     );
 122               ssx=get('ssxfrm',9,0);
 123               plt=ssx*(imat*pp);
 124               ik>0?
 125                   polygon(#-1,-2,[plt[0,2],lpt[0,2]],1,0xffffffff,255):
 126                   store(plt,'firstpt',3,1,1,1);
 127               store(plt,'lastpt',3,1,1,1);
 128               ik==(3*specw-1)?
 129                   polygon(#-1,-2,[fpt[0,2],plt[0,2]],1,0xffffffff,255)
 130              "
 131        atk={2*pi*($k/(3*$sw-1))}
 132    -done
~~~
???

= annotations
### Notations and Annotations
For those of you wishing to go into the weeds, herewith are the weeds:
??? Line-by-line Remarks
|  __Line__  |  __Remark__  
|  **14** | '$=a' A pseudo assignment. G'MIC transforms this into a series of actual assignments. This _'$-expression'_ generates an assignment sequence with the base name 'a' for however many elements on the command line there may be. '$a0' identifies the name of the script, so one could alter script behavior based on the script name. '$a1…' onward are the arguments. See [Adding Custom Commands](https://gmic.eu/reference/adding_custom_commands.html#top), ninth and last sub-bullet. There is nothing special about the base name _a_, by the way, and could be anything: '$=fruitloops' initializes command line variables '$fruitloops0, …, $fruitloops < _n_ > '.
|  **19** |Sanity-check the arguments. 'wheelie' expects '$a1' to specify the length of one side of a square drawing canvas, so anticipates that the first argument is an integer. '$#' is another _'$-expression'_; this one resolves to the number of comma-separated arguments given to 'wheelie'. Wheelie specifications occur in groups of three, _r_, _θ_ and _±ω_ so '!(($#-1)%3)' enforces arguments in triplets; it is _False_ if the number of arguments, less the first, is not evenly divisable by three. Thus, the user specifies the image size with the first argument and employs triplets of successive arguments to specify wheelies, one triplet for each. Order matters. The first triplet specifies the root wheelie, the last designates the terminal marker wheelie.
|  **20,29** |Curly brace pairs indicate a number of possible substitutions, see [Substitution Rules](https://gmic.eu/reference/substitution_rules.html#top), and if the contents of curley braces cannot be attributed to requests for some image feature, it bottoms out to a math expression. For those new to math expressions, the encounter is a bit like falling into a rabbit hole, left-and-right curley braces ideographic of the impending cavity. Take a deep breath, grasp something solid, and remember that, above all, some kind of substitution is going on, and the source of it is the results of the math computation. In the present cases, they are the right hand sides of assignment operators that initialize pipeline variables. [Mathematical Expressions](https://gmic.eu/reference/mathematical_expressions.html#top) furnishes a complete, if terse, set of objects that make up mathematical expressions. Of the present cases, the first sets a resolution metric. '$sw' associates one unit of distance in the computation space of wheelies to a particular number of pixels, thus anchoring our relative lengths to something definite: the screen space of pixels. This resolution metric figures in a number of sizing tasks, such as scaling the number of plots necessary to draw an arabesque. Not so many for small pixel dimensions; a lot otherwise. The second derives 'circle count' – aka, the number of wheelies specified in the argument list. This is just the number of arguments dedicated to wheelie specifications, '$#-1', divided by three, because each wheelie consists of three arguments.
|  **30-51** |The 'args' image is not for display; it is an argument database. Each pixel specifies aspects of one wheelie. Elements 0-2 hold _r_, _θ_ and _±ω_ and this first 'repeat'…'done' loop saves them for future reference, elements 3-11 are reserved for the wheelie-specific affine transforms, but these are not computed here. See the following annotations.
|  **53-70** |'fill' iterates over the 'args' image, computing "stage 1" affine transformations for each wheelie. Storage for each wheelie occupies a twelve channel pixel of the image; In each step of the fill, the current pixel, 'I', represents all that is known about one wheelie **61** aliases 'I' to 'CPX' for convenience. At the outset, these pixel vectors just hold  _r_, _θ_ and _±ω_. Over the course of iteration, we compute and store a pre-computed "stage 1" transform matrix, the static transform encapulating only _r_, the wheelie length translation, and  _θ_, its time-independent initial rotation about the origin. Downstream, in the arabesque drawing loop, we compute a "stage 2" matrix, to wit: we composite each stage 1 wheelie transform with an additional pure rotation derived from _±ωt_, applying the time-varying change to wheelie orientation. When done with filling this "wheelie database", we harness [store](https://gmic.eu/tutorial/store.html) to make the wheelie vectors accessible to the math expression parser; it may do so through the 'circles' _image storage variable_. The permutation prior to 'store' is for convenience. The reorganizing of the 'args' image through this permutation leaves wheelie components arrayed along the 'arg' image 'x' axis instead of along its spectral axis. The wheelie vectors contiguous along the 'x' axis make for more straightforward access in the arabesque loop.
|  **62** | 'rot()' generates pure rotational matrices: 2 × 2 for two dimensional work and 3 × 3 for three dimensional. In the latter form, one provides the axis of rotation to complete the specification. That we are operating in three dimensions may give one reason to pause. Recall our preference for working with homogeneous points, inhabitants of a three dimensional projective space, so that we can encapsulate both rotation and translation in one transform — as well as diambiguate points from vectors. In this case, the axis of choice is the z axis, perpendicular to the canvas, so that when we rotate points they stay in the canvas plane. The first use of this function gives us 'orot', _origin rotation_ derived from _θ_, the second element of the wheelie vector. 'deg2rad()' conveniently converts this element from degrees to radians.
|  **63,64** |We generate the translation matrix, 'xlat' by starting with the 3 × 3 identity matrix, as furnished by 'eye()'. Elements two and five of this matrix embodies translations. Curiously, we set only an _x_ translation, this the length of the wheelie occupying channel zero of the database pixel 'CPX'. What of _y_? Recall from the main discussion that we view individual wheelies in a relative way, so it suits us to build up the local wheelie transform where the wheelie itself is in a standard orientation, to wit: of zero degrees orientation with the wheelie aligned to the _x_ axis. Thus, in this most local of spaces, there is no translation in _y_.
|  **65,65** |Overall, we re-compose the 12 element wheelie vector from two fields. The first, elements 0 - 2, copies _r_, _θ_ and _±ω_. This copy makes use of the _accessor_ operator, a pair of open-and-close square brackets, which takes as many as three arguments: _'[<starting index>, <subvector length>, <stride> ]'_; the accessor operator extracts subvectors from source vectors. The first argument marks the index in the source vector where the subvector starts. It is the only required argument and, used in isolation, simply extracts a single element from the source vector. The second argument, if present, sets the length of the subvector. Thus 'V=[0,1,2,3,4,5,6,7,8,9]'; 'SV=V[5,3]' sets 'SV' to '[5,6,7]', the three element subvector beginning at index='5'. The third argument, if present, sets the _stride_, and defaults to increments of one element. Thus 'V=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];V[0,4,4]' retrieves the subvector '[0,4,8,12]', the four element subvector starting at index 0 in the source and consisting of every fourth element. Accessing a subvector through the square bracket operator is a read-only operation; one cannot use it on the left hand side of an assignment operator and expect to set the values of left hand side subvectors. For that, use 'copy()', which can copy a subvector to a source.\n\nThe second field harnesses 'mul()' to compose the two matrices: 'orot', the rotation component generated from  _θ_, and 'xlat' the translation component generated from _r_. The right-to-left multiplication, or _composition_, of the pure translation and rotation matrices produces the matrix that transforms the point at the origin of the wheelie to the tip. This matrix reflects the combined operation of sliding the point along the _x_ axis by a distance equal to the length of the wheelie, _r_, then rotating this position vector by _θ_. Care must be taken, for the right-to-left composition of a translation and a rotation is not the same as a left-to-right composition of a rotation and a translation. With the latter, the resulting matrix reflects the combined operation of rotating the point at the origin, and _then_ translating it. The rotation is an operation of no consequence, as a point rotating around itself changes nothing at all. The translation still carries a point at the origin five units along the _x_ axis, the only consequential action; the rotation was meaningless. That is why the composition starts with 'xlat', to which we compose 'orot', and not the other way around. The non-communicative quality of matrix multiplation is a source of many an interesting bug — amusing after the fact; annoying during its commission.\n\nWe form a new wheellie vector, FIN (final). FIN contains, front-to-back, the three- and nine-element fields consisting of the wheelie triplet and its allied affine transform. FIN by itself on the final line of the math expression is an implicit assignment to a "target." What that target may be depends on command line context in which the math expression was invoke. In the context of the [fill](https://gmic.eu/tutorial/fill.html) command, that target is the current pixel in the fill iteration.
|  **72-84** |This screenspace transform is an aside-on-an-envelope calculation and composites a right hand 270° rotation matrix with a lefthand scaling matrix. Both the scaling and the rotation stem from artistic whimsy, shrinking the arabesque by 50% for generous margins and orienting the _+x_ axis to align with screen space _+y_, so that the drawing of arabesques in animation start from 12 o'clock. One could also have written 'V=eye(3);V[0]=specw/2;V[2]=specw;V[4]=specw/2;V[5]=specw;mul(V,rot([0,0,1],270°),3)' to produce the same screen space transform. The scaling maps a unit distance in our computational space to one quarter of the canvas height (or width), a definite number of pixels: '$sw/4'. Adjust the denominators of 'V[0]=specw/2; V[4]=specw/2' downward to one for larger arabesques; upward for smaller arabesques.    
|  **85-132** |The arabesque drawing loop draws one mark of the arabesque per iteration. '-repeat 3*$sw,k … -done' establishes the number of plots, 'k' grows with larger images. The multiplier of '3' also stems from artistic whimsy; lower this multiplier for faster, sparser plotting.\n\nThe loop operates once for each _Δt_ tick; the wheelie walk discussed in the main article is realized through the '-repeat cc,k … -done' loop from **109-121** and, among other chores, it retrieve the stage 1 transform from 'circs', **114**, performs the "stage 2" composition with a pure rotation matrix derived from  _ωt_, **113-117**, and accumulates the composites in 'imat' **112-120**. 
   
???

= inversefourier
## Postscript: Inverse Fourier
The foregoing discourse is exemplary of design by following one's nose. That is, designing by observing what's there. It is a respectable, though possibly pedestrian, pursuit, but in many quadrants it is a disparaging slant. The chattering classes may pronounce such when regarding the artlessness of some poor sod's code. It entails the crime of taking what's more-or-less in front of you and coding a functional, straightforward and unimaginative design.\n\nDenigrations aside, there is much straightfoward and commonplace work to be found in The Making of Things: yeoman efforts, useful if not exceptional, built along obvious — if not optimal — lines.\n\nEventually somebody comes along with an arch, but until then, post-and-lintel serves just fine, thank you, in all the necessities that doors may require in the letting of people go from room to room.\n\n
None of this is worth mentioning, perhaps, but for the arch hidden in the wheelies' post-and-lintel world.\n\n
A few years ago, Grant Sanderson (3blue1brown) wished to impart the _feel_
 Consider [wheelies](https://www.youtube.com/watch?v=-qgreAUpPwM): fantastic constructions of gyrating arrows, erupting on YouTube and the like, that do etch-a-sketch things: drawing birds, flowers, even portraits of Jean-Baptiste Joseph Fourier. Follow your nose and find just line segments — _wheelies_ — each with one rooted and one free endpoint. If making arabesques is your order, then look no further than a chain of wheelies.

[](https://www.youtube.com/watch?v=s_L-fp8gDzY) entered the expository fray with [But what is the Fourier Transform? A visual introduction.](https://www.youtube.com/watch?v=spUNpyF58BY) favoring illustrative animations over notational expository. Just a few wheels occasion arabesques, our jumping off point.
