# Arabesques
%% x "mkdir -p img" %%
%% -m scripts/wheelie_anim.gmic input 600,600,1,3,lerp([219,214,233],[219,187,91],y/(h-1)) durga. 1,0,1,0.5,0,-3,0.5,0,-2,1,0,1 [-1]x48 erode_circ 2 -resize 50%,50%,1,3,5 o img/arabesque.mp4,24,H264 rm %%
|![Arabesque](img/arabesque.mp4)\n               *"Durga's idle arabesques"*|During brief interludes, when tranquility prevails and the peoples of the world are in complete accord, Durga might take ease from her duties and find serenity through simple pursuits.\n\nIt is a small pleasure to swing a compass marker around its anchor leg, and if hands quop or quave, arcs still run true — not that palsy ever troubles Durga, master as she is of the _chakra_ and _trishul_. And so it is hardly burdensome for her to take up compass after compass, anchor to marker, twirling each at speeds, directions and separations sought through whimsy.\n\nSuch a flurry of hands and arms may strike mortals dumb with astonishment, but for the slayer of the abominable Mahishasura it is just so many twirlings. With each added compass, the culminating marker traces ways ever more sublime, awarding Durga escalating delights. And so it goes — until demons arise. Durga must then put away her compasses and take up her arrows and bow.
= wheelie
### Wheelies
Deficient as we are in arms, it is only through _wheelies_ that we might do what Durga does in seeking enchantment. A wheelie models a compass pair: one end is an anchorage and the other swings free. We emulate Durga's trivial pursuit through a chain of such, anchor to marker, drawing arabesques of ever more intriguing complexity.

With each we may:

|      1.  |set a particular radius:|      _r_
|      2.  |pick a starting orientation:|      _θ_
|      3.  |choose a signed, clockwise or counterclockwise, rotation:|     _±ω_

A one-wheelie chain holds little fascination — it draws a circle — but is instructive nonetheless. Absolutes do not matter. A revolution may draw a circle in a microsecond or a millenium, but the time so taken does not alter the outcome. It is the drawing, and not the duration of its drafting, that matters.

Relatives, though, still matter. A wheelie rotating at three times the rate of its antecedent will plot a track differing from one rotating twice as much. Ditto with lengths. Centimeters or kilometers do not matter. It is that one wheelie is two-thirds the length of the other and necessarily will trace a path that differs from one at a ratio of three quarters. Ratios matter more than measures. Taking wheelies two-by-two and determining the shift from one to the other is the work put out for us.

Here then is the outline of our play:

|      1.  |root the first wheelie at the origin.
|      2a.  |root the other wheelies at successive free end points, perhaps setting their orientation differently or aligning them all. Do that any number of times, _or_
|      2b.  |attach a marker to the rim of a terminal wheelie and be done.

Circular motion is easy to fathom, but not too many wheelies in and complexity strikes us dumb. The remedy for that is patterns which, in recurrence, divide and conquer.

Paired wheelies provide the unit pattern. We can, in a relative world, choose whatever coordinate system that pleases us. So we first regard one wheelie in isolation and decide that it has an orientation of zero degrees and is aligned with the _x_ axis. Now bring in the antecedent, whose tip coincides with the origin of our wheelie. Our wheelie's length, _r_, and its orientation _θ + ωt_, informs us how the tip of our wheelie sits in relation to its antecedent, where the latter orientation term, _ωt_, arises from the product of angular velocity multiplied with the accumulation of successive ticks: _ωt = ω(Δt₀ + Δt₁ + … )_. We can write an affine matrix describing how a point starting at the origin — also the tip of the antecedent — translates by _r_ and rotates by _θ + ωt_ to arrive at our wheelie's tip: the _wheelie transform_.

===
![wheeliediagram](images/wheeliewalk.svg)
*Walking from marker tip to the origin*
===

In the spirit of divide-and-conquer, we may start with the terminal wheelie and write an [affine matrix](https://gmic.eu/tutorial/tiled_art.html#affinetransform) that describes how it sits in relation to its antecedent:

===
$$
\begin{bmatrix} m_x \\ m_y \\ 1 \end{bmatrix} =
\begin{bmatrix}
\-cos (\theta + \omega t) & -\-sin (\theta + \omega t) & r_x \\
\-sin (\theta + \omega t) & \-cos (\theta + \omega t) & r_y \\
0 & 0 & 1
\end{bmatrix}
\begin{bmatrix} o_x \\ o_y \\ 1 \end{bmatrix}
$$
*Wheelie matrices*
===

Over time, as _Δt_ accumulate and _ωt_ changes, we expect the tip of the wheelie to plot a circle of radius _r_; not very interesting, but something we can readily grasp. Now we shift our attention to the antecedent wheelie and write a second matrix that describes how its tip sits in relation to its antecedent. Another circular track. So, to characterize _both_ tracks, how the tip of the terminal wheelie sits in relation to the penultimate's origin, we composite the two matrices from right to left.

In the algebra of matrices, multiplication does not commute. Order matters. So we compose matrices in the same order that we walk. Along we go, walking from wheelie to wheelie, compounding individual circular motions as we go, obtaining the composite motion of the tip. That stepwise writing of matrices and their aggregation into one is our divide-and-conquer play. The arabesque of the whole arises from the plots of the parts. This is not too far removed from what a rigger would set up in character animation: composing the transform of the finger, the wrist, the forearm, the upper arm. Each have their own local transforms that can be animated locally, then consolidated into aggregated motion.

And with that, we\'re done. The composite matrix transforms the origin of the entire ensemble to the marker of the final wheelie, accounting for all intermediary rotations and translations. Plot the mark. Then, on the next tick, account for the effects of _Δt_ on all the orientations and walk the wheelie chain again.

That's the game — and our play. All we have to do is code.

??? wheelie.gmic
~~~
   1 wheelie :
   2    # wheelie: a circle of a particular (1) radius, (2) phase angle
   3    # (orientation) and (3) discrete angular velocity - a relative
   4    # integral number of revolutions per however long one revolution
   5    # takes. Wheelies chain together, the center of one situated at 0°
   6    # on the rim of its predecessor. The first wheelie of the chain
   7    # centers at the origin and the last has, instead of another
   8    # wheelie, an attached marking pen. Thus, the entire ensemble draws an
   9    # "arabesque" as the individual wheelies rotate at their respective
  10    # angular velocities from their initial orientations.
  11
  12    # Fetch an arbitrarily long argument list to $a0, $a1, …, $an
  13
  14    $=a
  15
  16    # Expect data triplets: radius, phase angle, angular velocity.
  17
  18    -check "isint($a1) && !(($#-1)%3)"
  19
  20    # Initial argument: side width (sw)
  21
  22    sw={$a1/2}
  23
  24    # Argument image 'args': For each wheelie, compose radius and phase
  25    # arguments into a transformation matrix. In the drawing loop, we
  26    # compose this with the angle resulting from one angular velocity
  27    # step.
  28
  29    ccnt={int(($#-1)/3)}
  30    -input $ccnt,1,1,12
  31    -name  args
  32
  33    # Iterate over argument vector. For each triplet – representing a
  34    # wheelie – Fetch radius (rad), phase angle (ang) and angular
  35    # velocity (sf) parameters.
  36
  37    -repeat $#-1,j
  38       -if   $j%3==0 # get radius
  39          rad=${a{2+$j}}
  40          -check isnum($rad)" && "$rad>=0" && "$rad<=1
  41          -set[args] $rad,{round($j/3,1,-1)},0,0,0
  42       -elif $j%3==1 # get angle, degrees
  43          ang=${a{2+$j}}
  44          -check isnum($ang)" && "$ang>=0" && "$ang<=360
  45          -set[args] $ang,{round($j/3,1,-1)},0,0,1
  46       -else         # get ω and set spectral coefficient
  47          sf=${a{2+$j}}
  48          -check isint($sf)" && "abs($sf)<=0.1*$sw
  49          -set[args] $sf,{round($j/3,1,-1)},0,0,2
  50       -fi
  51    -done
  52
  53    # Iterate over argument image, each 12 channel pixel representing
  54    # one wheelie. The first three channels contain wheelie radius,
  55    # phase angle and radial velocity. Compose a matrix transforming
  56    # the origin to the tip of the wheelie, a radial translation and
  57    # phase rotation. Populate the nine remaining channels with this
  58    # matrix.
  59
  60    -fill[args] ">
  61                   CPX=I;
  62                   orot=rot([0,0,1],deg2rad(CPX[1])); # phase rotation
  63                   xlat=eye(3);
  64                   xlat[2]=CPX[0];                    # translation origin
  65                   FIN=[CPX[0,3,1],mul(orot,xlat,3)]; # -to-rim, i.e.
  66                   FIN                                # 'rotation & xlat'
  67                "                                     # store above in
  68                                                      # 12-channel pixel
  69    -permute[args] cyzx
  70    -store[args] circles
  71
  72    # Screenspace transform.
  73    ssxfrm={"
  74             specw=get('sw',0,0);
  75             id=eye(3);
  76             id[0]=0;
  77             id[1]=specw/2;
  78             id[2]=specw;
  79             id[3]=-specw/2;
  80             id[4]=0;
  81             id[5]=specw;
  82             id
  83            "}
  84
  85    # Draw arabesques on this image
  86    -input {2*$sw},{2*$sw},1,1
  87    -name. canvas
  88
  89    atk=0
  90    lastpt={vector3([0,0,1])}
  91    firstpt={vector3([0,0,1])}
  92    -repeat 3*$sw,k
  93        # For each wheelie:
  94        # increment by angular velocity
  95        # find corresponding rotation matrix
  96        # compose with radial argument image, compose
  97        # with screenspace transform and plot via polygon().
  98
  99        -eval ">
 100               const cc=$ccnt;
 101               fpt=get('firstpt',3,0);
 102               ik=get('k',0,0);
 103               lpt=get('lastpt',3,0);
 104               omega=get('atk',0,0);
 105               specw=get('sw',0,0);
 106               circs=get('circles',12*cc,0);
 107               pp=vector3([0,0,1]);
 108               imat=eye(3);
 109               repeat(
 110                        cc,k,
 111                        idx=cc-k-1;
 112                        imat=mul(
 113                                    mul(
 114                                         rot([0,0,1],circs[12*idx+2]*omega),
 115                                         circs[12*idx+3,9,1],
 116                                         3
 117                                       ),
 118                                    imat,
 119                                    3
 120                                );
 121                     );
 122               ssx=get('ssxfrm',9,0);
 123               plt=ssx*(imat*pp);
 124               ik>0?
 125                   polygon(#$canvas,-2,[plt[0,2],lpt[0,2]],1,0xffffffff,255):
 126                   store(plt,'firstpt',3,1,1,1);
 127               store(plt,'lastpt',3,1,1,1);
 128               ik==(3*specw-1)?
 129                   polygon(#$canvas,-2,[fpt[0,2],plt[0,2]],1,0xffffffff,255)
 130              "
 131        atk={2*pi*($k/(3*$sw-1))}
 132    -done
~~~
???

= annotations
### Notations and Annotations
For those of you wishing to go into the weeds, herewith are the weeds:
??? Line-by-line Remarks
|  __Line__  |  __Remark__  
|  **14** | '$=a' A pseudo assignment. G'MIC transforms this into a series of actual assignments. This _'$-expression'_ generates an assignment sequence with the base name 'a' for however many elements on the command line there may be. '$a0' identifies the name of the script, so one could alter script behavior based on the script name. '$a1…' onward are the arguments. See [Adding Custom Commands](https://gmic.eu/reference/adding_custom_commands.html#top). There is nothing special about the base name 'a'. It could be anything: '$=fruitloops' initializes command line variables '$fruitloops0, …, $fruitloops<n>'.
|  **16-29** |We sanity-check the arguments. 'wheelie' expects '$a1' to specify the length of one side of a square drawing canvas, so anticipates that the first argument is an integer. '$#' is another _'$-expression'_; this one resolves to the number of comma-separated arguments given to 'wheelie'. Wheelie specifications occur in groups of three, _r_, _θ_ and _±ω_ so '!(($#-1)%3)' enforces arguments in triplets; it is _False_ if the number of arguments, less the first, is not evenly divisable by three. Thus, the user specifies the image size with the first argument and employs triplets of successive arguments to specify wheelies, one triplet for each. Order matters. The first triplet specifies the root wheelie, the last designates the terminal marker wheelie.
|  **22,29** |Curly brace pairs indicate a number of possible substitutions, see [Substitution Rules](https://gmic.eu/reference/substitution_rules.html#top), and if the contents of curly braces cannot be attributed to requests for some image feature, it bottoms out to a math expression. For those new to math expressions, the encounter is a bit like falling into a rabbit hole, left-and-right curly braces ideographic of the impending cavity. Take a deep breath, grasp something solid, and remember that, above all, some kind of substitution is going on, and the source of it is the results of the math computation. In the present cases, they are the right hand sides of assignment operators that initialize pipeline variables. [Mathematical Expressions](https://gmic.eu/reference/mathematical_expressions.html#top) furnishes a complete, if terse, set of objects that make up mathematical expressions. Of the present cases, the first sets a resolution metric. '$sw' associates one unit of distance in the computation space of wheelies to a particular number of pixels, thus anchoring our relative lengths to something definite: the screen space of pixels. This resolution metric figures in a number of sizing tasks, such as scaling the number of plots necessary to draw an arabesque. Not so many for small pixel dimensions; a lot otherwise. The second derives 'circle count' – aka, the number of wheelies specified in the argument list. This is just the number of arguments dedicated to wheelie specifications, '$#-1', divided by three, because each wheelie consists of three arguments.
|  **29-51** |The 'args' image is not for display; it is an argument database. Each pixel specifies aspects of one wheelie. Elements 0-2 hold _r_, _θ_ and _±ω_ and this first 'repeat'…'done' loop saves them for future reference, elements 3-11 are reserved for the wheelie-specific affine transforms, but these are not computed here. See the following annotations.
|  **53-70** |'fill' iterates over the 'args' image, computing "stage 1" affine transformations for each wheelie. Storage for each wheelie occupies a twelve channel pixel of the image; In each step of the fill, the current pixel, 'I', represents all that is known about one wheelie **61** aliases 'I' to 'CPX' for convenience. At the outset, these pixel vectors just hold  _r_, _θ_ and _±ω_. Over the course of iteration, we compute and store a pre-computed "stage 1" transform matrix, the static transform encapulating only _r_, the wheelie length translation, and  _θ_, its time-independent initial rotation about the origin. Downstream, in the arabesque drawing loop, we compute a "stage 2" matrix, to wit: we composite each stage 1 wheelie transform with an additional pure rotation derived from _±ωt_, applying the time-varying change to wheelie orientation. When done with filling this "wheelie database", we harness [store](https://gmic.eu/tutorial/store.html) to make the wheelie vectors accessible to the math expression parser; it may do so through the 'circles' _image storage variable_. The permutation prior to 'store' is for convenience. The reorganizing of the 'args' image through this permutation leaves wheelie components arrayed along the 'arg' image 'x' axis instead of along its spectral axis. The wheelie vectors contiguous along the 'x' axis make for more straightforward access in the arabesque drawing loop.
|  **62** | 'rot()' generates pure rotational matrices: 2 × 2 for two dimensional work and 3 × 3 for three dimensional. In the latter form, one provides the axis of rotation to complete the specification: '[0,0,1]' identifies the three-space _+z_ unit axis.\n\nThat we are operating in three dimensions may give one reason to pause. Recall our preference for working with [homogeneous points](https://gmic.eu/tutorial/tiled_art.html#affinetransform), inhabitants of a three dimensional projective space, so that we can encapsulate both rotation and translation in one transform — as well as diambiguate points from vectors. In this case, the axis of choice is the _+z_ axis, perpendicular to the canvas, so that when we rotate points in the canvas plane, they stay in the canvas plane. The first use of this function gives us 'orot', _origin rotation_ derived from _θ_, the second element of the wheelie vector. 'deg2rad()' conveniently converts this element from degrees to radians. So does the ° operator — the degree symbol. Thus 45.739° in a G'MIC math expression quietly transforms itself into ≈ 0.798296 radians. Consult your operating system manual on how to obtain off-keyboard characters if you cannot find the ° sign on it. 
|  **63,64** |We generate the translation matrix, 'xlat' by starting with the 3 × 3 identity matrix, as furnished by 'eye()'. In an affine transform, elements two and five embody spatial displacement. Curiously, we set only an _x_ displacement, this the length of the wheelie. What of _y_? Recall from the main discussion that we view individual wheelies in a relative way, so it suits us to build up the local wheelie transform where the wheelie itself is in a standard orientation, to wit: of zero degrees orientation with the wheelie aligned to the _+x_ axis. Thus, in this most local of spaces, there is no displacement in _y_.
|  **65,66** |Overall, we re-compose the 12 element wheelie vector from two fields. The first, elements 0 - 2, copies _r_, _θ_ and _±ω_.\n\nThis copy makes use of the _accessor_ operator, a pair of open-and-close square brackets, which takes as many as three arguments: `[<starting index>, <subvector length>, <stride>]`; the accessor operator extracts subvectors from source vectors. The first argument marks the index in the source vector where the subvector starts. It is the only required argument and, used in isolation, simply extracts a single element from the source vector. The second argument, if present, sets the length of the subvector. Thus 'V=[0,1,2,3,4,5,6,7,8,9]'; 'SV=V[5,3]' sets 'SV' to '[5,6,7]', the three element subvector beginning at index = '5'. The third argument, if present, sets the _stride_, and defaults to increments of one element. Thus 'V=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];V[0,4,4]' retrieves the subvector '[0,4,8,12]', the four element subvector starting at index '0' in the source and consisting of every fourth element. Extracting a subvector through the accessor operator is a read-only operation; one cannot use it on the left hand side of an assignment and expect to set the values of a left hand subvector. For that, consider 'copy()', which can transcribe a subvector to a source.\n\nThe second field composing the wheelie vector harnesses 'mul()' to compose the two matrices: 'orot', the rotation component generated from  _θ_, and 'xlat' the translation component generated from _r_. The right-to-left multiplication, or _composition_, of the translation and rotation matrices produces the _wheelie matrix_. This matrix transforms a point at the origin of the wheelie to its tip and reflects the combined operation of displacing the point along the _+x_ axis by a distance equal to the length of the wheelie (_r_) then rotating this position vector by _θ_. Care must be taken, for the right-to-left composition of a translation and a rotation is not the same as a left-to-right composition of a rotation and a translation. With the latter, the resulting matrix reflects the combined operation of first rotating the point at the origin, and _then_ translating it. Alas! The rotation of a zero-length position vector is of no consequence. A point rotating around itself remains unchanged. That leaves just the translation, not a full characteration of the transform. That is why the composition starts with 'xlat', generating a positive length displacement, to which we compose 'orot', the displacement vector rotated, and not the other way around. The non-communicative quality of matrix algebra is a source of many an interesting bug — amusing after the fact, exasperating in the moment.\n\nWe form a new wheellie vector, 'FIN' (final). 'FIN' contains, front-to-back, the three- and nine-element fields consisting of the wheelie triplet and its allied affine transform. 'FIN' by itself on the final line of the math expression is an implicit assignment to some "target." What that target may be depends on command line context in which the math expression was invoked. In the context of the [fill](https://gmic.eu/tutorial/fill.html) command, that target is the current pixel in the fill image iteration.
|  **72-84** |This screenspace transform is an off-to-one-side calculation and composites a right hand 270° rotation matrix with a lefthand scaling matrix. Both the scaling and the rotation stem from artistic whimsy, shrinking the arabesque by 50% for generous margins and orienting the _+x_ axis to align with screen space _+y_, so that the drawing of arabesques in start from 12 o'clock. Why 12 o'clock? Clients of this script generate animations, and 12 o'clock is deemed a pleasing place to start such — whimsy again. One could also have written 'V=eye(3);V[0]=specw/2;V[2]=specw;V[4]=specw/2;V[5]=specw;mul(V,rot([0,0,1],270°),3)' to produce the same screen space transform. The scaling maps a unit distance in our computational space to one quarter of the canvas height (or width), a definite number of pixels: '$sw/4'. Adjust the denominators of 'V[0]=specw/2; V[4]=specw/2' downward toward one for larger arabesques; upward to infinity for smaller arabesques.
|  **85-121** |The arabesque drawing loop draws one mark of the arabesque per iteration. '-repeat 3*$sw,k … -done' establishes the number of plots; 'k' grows with larger images. The multiplier, '3', also stems from artistic whimsy; lower this multiplier for faster, sparser plotting. The loop operates once for each _Δt_.\n\nThe wheelie walk discussed in the main article is realized through the '-repeat cc,k … -done' loop from **109-121** and, among other chores, it retrieves the stage 1 time-independent transform from 'circs', the wheelie database, and composites it with the rotation matrix for _ωt_. The inner 'mul()' expression spanning **113-117**, performs this composition. The rotation matrix for _ωt_ is the first term of 'mul()': 'circs[12*idx+2]' retrieves the wheelie-specific angular velocity, _ω_, from the wheelie database; 'omega' holds accumulated "time", a whimsical proxy for travelling through parameter space. 'Omega' is a math expression alias for the command line analog, '$atk'. See **131** and **104**, which brings the command line variable '$atk' into the math expression. Rotation around the _+z_ projection space axis produces the rotation matrix for _ωt_. The second term of 'mul()' is the stage 1 time-independent transform, the composition of _r_ and _θ_. The composition of these two terms produces the dynamic version of the wheelie matrix.\n\nThe outer 'mul()' expression spanning **112-120**,accumulates the dynamic wheelie matrices into imat — this, the realization of the tip-to-origin walk. Dropping out of the 'repeat' loop spanning **109-121** delivers 'imat'. It embodies the entire transform of a point at the origin of the entire ensemble up to the tip of the final wheelie.
|  **122-130** |The bottom of the arabesque drawing loop concerns itself with plotting arabesque marks: line segments between adjacent _Δt_ plots and drawn by 'polygon()'. The drawing loop maintains a two-plot window, realized by storage variables 'firstpt' and 'lastpt' These points are in screen space, so the matrix responsible for that transform is summoned from storage variable 'ssxform'. Recall **72-84**. Referring to **123**, 'imat*pp' carries a point from the origin to the wheelie tip and is subsequently transformed by 'ssx' into a screen space plot.\n\nTo create a two point plotting window, the drawing loop retains the plot of the previous iteration in 'lastpt' and draws from that to the current plot; before the iteration finishes, the current plot becomes the next inhabitant of 'lastpt', to serve in a similar capacity in the next iteration. That accounts for most drawing activity, excepting the initial and final boundary cases. Nothing is plotted in the first iteration. Instead, the initial plot is stashed to both 'firstpt' and 'lastpt'. Through all remaining iterations, up to the last, 'firstpt' is undisturbed. When the last iteration is realized and plotting has taken place, there remains a gap between 'firstpt' and 'lastpt.' These become plot points for an extra, final call to 'polygon()', which closes the gap between the initial and final plots, finishing the arabesque.

???

= inversefourier
## Postscript:
Drawing arabesques through wheelie chains exemplifies the follow one's nose approach: its central object, the wheelie, is not far removed from a pair of drawing compasses. Following one's nose is a respectable, if pedestrian, pursuit, taking what's more-or-less there and coding a straightforward, if unimaginative, design. It is evolution: the yeoman's effort, useful, if not exceptional, extending ideas along obvious — if not optimal — lines. Following one's nose poses few mysteries, only a dash of spelunking might be needed, so one may land a project on time and within budget. Those who habitually do that get re-hired. Eventually somebody comes along with an arch — Revolution! — but until then, post-and-lintel serves just fine, thank you, in all that doors need for letting people go to and thro. None of this is worth mentioning, perhaps, but for the arch hidden in the wheelies' post-and-lintel slant. The key disruptor is the inverse Fourier transform. The key disruption to the settled approach is a wholesale ditching of these step-and-repeat wheelie walks: the inverse Fourier transform can generate the entire arabesque in one throw.

===
![spectralspace](images/spectralspace.svg)
*The wheelie as a spectral space point*
===

This new slant for plotting arabesques opens up with what the circular motion of a wheelie represents. Comprised of a length _r_ at an initial orientation _θ_, and rotating at an angular velocity of _±ω_, a spinning wheelie finds representation as a _spectral space_ point. One axis of this spectral space embodies rotation, _±ω_. The other axis embodies the length of the wheelie _r_ at an orientaton _θ_ — a complex number _r(cos θ + isin θ)_. A composition of these spectral space "wheelie plots", analogous to the wheelie walk of matrix compositions done before, can — in some fashion — constitute an arabesque.

===
|- ![wheeliespatial](images/wheeliespatial.svg)
|* Spatial plots over slices of time *
| ![wheeliespectral](images/wheeliespectral.svg)
|* Spectral plots over slices of angular velocity * 
===

Language such as "in some fashion" calls for grounding the discussion in some concrete manner. The arabesques we generate now are datasets of _x_ and _y_ plots computed at _Δt_ slices, a discrete, spatial dataset. The discrete Fourier transform of these plots should produce some sort of spectral fingerprint of the spectral space composition of these wheelie plots.

This brings to mind that one may regard varying phenomena over intervals of time or at frequencies of alterationwo viewpoints. First, discrete quantities sampled at constant intervals capture change from one interval to the next. Positions at _x_ and _y_ of wheelie tips taken over time, _t_, fall to this class. Second

And with any periodic data set, there is a corresponding _spectral_ set which can be found through the Fourier transform. The results chart the distribution of signal strength across the spectral axis and can illustrate how specific frequencies contribute to a signal. Without too much of a stretch, successive plots of a wheelie's marker may be construed as a time series for which its Fourier transform can indicate how path gyrations at particular scales establish the overall twistiness of a path. Wheelie angular velocities, _±ω_, correspond to particular plots along the spectral axis.    

---

Consider the root wheelie. Whatever its absolute rotational period, microseconds or millenia, in a relative viewpoint it is one revolution. In the spaces we feed to the discrete inverse Fourier transform, this spectral frequency of one revolution per period, _ω_ is a _spectral coordindate_. The rotation of the root wheelie addresses the coordinate one step away from the spectral origin, 0×ω, representing signals which never vary at all.

Consider the next wheelie. It too is rotating at a rate relative to the root, perhaps an integral number of times faster — the discrete spectral space does not accommodate the continuum of fractional rotations. If the next wheelie up the chain is rotating in the same direction as the root wheelie, it has a positive 'local' frequency. If it rotates contrary to the root wheelie, it has a negative 'local' frequency. The phrase 'local' designates its own rotation; to this one adds the rotations of the antecedent wheelies to arrive at the aggregate rotation of the wheelie's tip. And so we go, to each wheelie tip we can assign an aggregate rotational frequency, the sum of prior rotation rates and its own.

What if the aggregate rotational frequency is negative? The spaces we feed to the discrete inverse Fourier transform are modular as well as discrete. That is, we do clock arithmetic. Values that sweep below the origin — that could be negative in the space of integers — wrap around instead, like the hands of a clock. One adds a specific value, the _modulus_ of the space, to deal with what otherwise might be negative values. Set a clock two hours back from one in the afternoon and it points to eleven AM — the modulus of clock time is 12. 1 - 2 equals -1 with integers, and 11 for the discrete space that is modulus 12: clock time.

The modulus is closely related to the idea of sampling: it is the highest frequency a process might use to sample a continuum. It can be related to the mechanics of particular circumstances — sampling devices fail to register data beyond a certain frequency. In the world of bitmap images, pixels themselves sample an image continuum. For an image 2,000 pixels on a side, the sampling frequency is 1,000, as two distinct, adjacent pixels have a wavelength of two pixels and a thousand such cycles fit exactly into a length of two thousand pixels;the modulus of such a discrete sampling space is, in this case, 1,000 and this quantity is added to "negative" rotational frequencies.

So, directly, for positive angular velocities, and by adding moduli to wrap negative angular velocities, we can establish the coordinate of a wheelie in the descrete, modular spectral space. What is the magnitude that we plot there? This: the complex number _r·cos(θ) + ir·sin(θ)_, for the length of the wheelie _r_ and its orientation _θ_.



A few years ago, Grant Sanderson (3blue1brown) wished to impart the _feel_
 Consider [wheelies](https://www.youtube.com/watch?v=-qgreAUpPwM): fantastic constructions of gyrating arrows, erupting on YouTube and the like, that do etch-a-sketch things: drawing birds, flowers, even portraits of Jean-Baptiste Joseph Fourier. Follow your nose and find just line segments — _wheelies_ — each with one rooted and one free endpoint. If making arabesques is your order, then look no further than a chain of wheelies.

[](https://www.youtube.com/watch?v=s_L-fp8gDzY) entered the expository fray with [But what is the Fourier Transform? A visual introduction.](https://www.youtube.com/watch?v=spUNpyF58BY) favoring illustrative animations over notational expository. Just a few wheels occasion arabesques, our jumping off point.

# gmic spectralarabesque.gmic spectralarabesque 512,0.5,20,1,0.5,45,-3,0.5,60,-7
#   1  0.469846, 0.171010
# 248 -0.286788, 0.409576
# 255  0.211309, 0.453140

