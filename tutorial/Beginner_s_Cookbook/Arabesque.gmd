# Arabesques
%% x "mkdir -p img" %%
%% -m scripts/wheelie_anim.gmic input 600,600,1,3,lerp([200,200,230],[200,175,100],y/(h-1)) durga. 1,0,1,0.5,0,-3,0.5,0,-2,1,0,1 [-1]x48 erode_circ 2 -resize 50%,50%,1,3,5 o img/arabesque.mp4,24,H264 rm %%
|![Arabesque](img/arabesque.mp4)\n               *"Durga's idle arabesques"*|During brief interludes when tranquility prevails and the peoples of the world are in complete accord, Durga might take ease from her duties and find serenity through simple pursuits.\n\nIt is a small pleasure to swing a compass marker around its anchor leg, and if hands quop and quave, arcs still run true — not that palsy ever troubles Durga, master as she is of the _chakra_ and _trishul_. And so it is hardly burdensome for her to take up compass after compass, anchor to marker, twirling each at speeds, directions and separations sought through whimsy.\n\nSuch a flurry of hands and arms may strike mortals dumb with astonishment, but for the slayer of the abominable Mahishasura it is just so many twirlings. With each added compass, the culminating marker traces ways ever more sublime, awarding Durga escalating delights. And so it goes — until demons arise. Durga must then put away her compasses and take up her arrows and bow.
= wheelie
### Wheelies
Deficient as we are in arms, \'tis only through _wheelies_ that we can spin what our hands cannot. A wheelie models a compass pair in that one end is an anchorage and the other swings free. We may emulate Durga's trivial pursuit by chaining together wheelies, anchor to marker, and drawing arabesques of ever more intriguing complexity.

With each we may:

|      1.  |set a particular radius.| _r_
|      2.  |pick a starting orientation.| _θ_
|      3.  |choose a signed, clockwise or counterclockwise, rotational rate.|±ω

A one-wheelie chain holds little fascination — it draws a circle — but is instructive nonetheless. Absolute rates do not matter. A revolution may draw a circle in a microsecond or millenia, but the time occupied in such does not matter to the outcome. It is the drawing, and not the duration of its drafting, that matters.

In and of themselves,  wheelies rotate at rates divorced from absolute durations. But relative rates between paired wheelies _do_ matter, for a wheelie rotating at three times the rate of its antecedent will plot a culminating track that differs with one rotating at twice the rate. Similarly, the clockwise or counterclockwise sense of consecutive wheelies also matters, as reflected in the positive or negative sign of angular velocity, ±ω. Finally, the relative length of a wheelie, radius _r_ in relation to its antecedent or successor matters more than any specific measure.

Here then is the outline of the game:

|      1.  |rooting the first wheelie at the origin.
|      2.  |rooting other wheelies at successive free end points, perhaps setting their orientation or aligning them all along a single line. Do that any number of times, _or_
|      3.  |attach a marker to the rim of a terminal wheelie. Do that once.

How might we plot such gyrations?

Circular motion is easy enough to fathom, but when not too many wheelies get into the game, we become struck dumb with complexity. The remedy for that is intelligence, in noticing patterns that, in recurrence, divides and conquers complexity into simple units.

The isolated wheelie provides the simple unit. It has a specific length, an initial orientation and a rotational rate in one or another direction.

===
![wheeliediagram](images/wheelieset.svg)
*Walking from marker tip to the origin*
===

The first piece is to write an [affine transform matrix](https://gmic.eu/tutorial/tiled_art.html#affinetransform) to encapsulate this unit simplicity. For each wheelie, the transform takes a point at the anchor end and carries it to the marker end, a displacement in _x_ and _y_, The transform also captures the wheelie\'s orientation, _θ_. Finally, for each time step _Δt_ add a smidgen angle _±ωΔt_ to the base orientation _θ_. We have everything we need to write a matrix for each wheelie:

===
$$
\begin{bmatrix} m_x \\ m_y \\ 1 \end{bmatrix} =
\begin{bmatrix}
\-cos (\theta + \omega \Delta t) & \-sin (\theta + \omega \Delta t) & r_x \\
-\-sin (\theta + \omega \Delta t) & \-cos (\theta + \omega \Delta t) & r_y \\
0 & 0 & 1
\end{bmatrix}
\begin{bmatrix} o_x \\ o_y \\ 1 \end{bmatrix}
$$
*Wheelie matrices*
===

The only remaining piece of this play is the walk. These individual matrices describe each wheelie in isolation, as if their anchor ends are rooted, motionless. But that is true only for the initial wheelie. The motion of the second wheelie is its own circular motion compounded with that of its antecedent, and the third wheelie's motion is its own circular motion composited with both antecedents, and for the tip marker, in general, it is its own circular motion composited with _all_ antecedents. That is the basis for the walk. We start from the tip end, where the marker is, and compose its own simple rotation about its root. Then we step down to the penultimate wheelie, record its own local transform matrix and compose it with that of its successor. And along we go, walking from wheelie to wheelie, recording and compositing matrices as we go, until we arrive at the root. And we're done. The composite matrix will position the marker with respect to the origin, accounting for all intermediary rotations and translations. And we do it again on the next tick, when _±ωΔt_ smidgens have shifted all the orientations.

That's the game. That's our play. All we have to do is code:

??? wheelie.gmic
~~~
wheelie :
   # wheelie: a circle of a particular (1) radius, (2) phase angle
   # (orientation) and (3) discrete angular velocity - a relative
   # integral number of revolutions per however long one revolution
   # takes. Wheelies chain together, the center of one situated at 0°
   # on the rim of its predecessor. The first wheelie of the chain
   # centers at the origin and the last has, instead of another
   # wheelie, an attached marking pen. Thus, the entire ensemble draws an
   # "arabesque" as the individual wheelies rotate at their respective
   # angular velocities from their initial orientations. This script
   # animates such.

   # Fetch an arbitrarily long argument list to $a0, $a1, …, $an

   $=a

   # Expect data triplets: radius, phase angle, angular velocity.

   -check "isint($a1) && !(($#-1)%3)"

   # Initial argument: side width (sw)

   sw={$a1/2}

   # Argument image: For each wheelie, compose radius and phase
   # arguments into a transformation matrix. In the generation loop, we
   # compose this with the angle resulting from one angular velocity
   # step.

   ccnt={round(($#-1)/3,1,-1)}
   -input $ccnt,1,1,12
   -name  args

   # Iterate over argument vector. For each triplet – representing a
   # wheelie – Fetch radius (rad), phase angle (ang) and angular
   # velocity (sf) parameters.

   -repeat $#-1,j
      -if   $j%3==0 # get radius
         rad=${a{2+$j}}
         -check isnum($rad)" && "$rad>=0" && "$rad<=1
         -set[args] $rad,{round($j/3,1,-1)},0,0,0
      -elif $j%3==1 # get angle, degrees
         ang=${a{2+$j}}
         -check isnum($ang)" && "$ang>=0" && "$ang<=360
         -set[args] $ang,{round($j/3,1,-1)},0,0,1
      -else         # get ω and set spectral coefficient
         sf=${a{2+$j}}
         -check isint($sf)" && "abs($sf)<=0.1*$sw
         -set[args] $sf,{round($j/3,1,-1)},0,0,2
      -fi
   -done

   # Iterate over argument image, each 12 channel pixel representing
   # one wheelie. The first three channels contain wheelie radius,
   # phase angle and radial velocity. Compose a matrix transforming
   # the origin to the tip of the wheelie, a radial translation and
   # phase rotation. Populate the nine remaining channels with this
   # matrix.

   -fill[args] ">
                  CPX=I;
                  orot=rot([0,0,1],deg2rad(CPX[1])); # phase rotation
                  xlat=eye(3);
                  xlat[2]=CPX[0];                    # translation origin-to-rim
                  FIN=[CPX[0,3,1],mul(orot,xlat,3)]; # args+"RADX" i.e. 'rotation & xlation'
                  FIN                                # store above in 12-channel pixel
               "
   -permute[args] cyzx
   -store[args] circles

   # Screenspace transform.
   ssxfrm={specw=get('sw',1,0);id=eye(3);id[0]=0;id[1]=specw[0]/2;id[2]=specw[0];id[3]=-specw[0]/2;id[4]=0;id[5]=specw[0];id}

   # Draw arabesques on this image
   -input {2*$sw},{2*$sw},1,1
   -name. canvas

   atk=0
   lastpt={vector3([0,0,1])}
   firstpt={vector3([0,0,1])}
   -repeat 3*$sw,k
       # For each wheelie:
       #    increment by angular velocity
       #    find corresponding rotation matrix
       #    compose with radial argument image, compose
       #    with screenspace transform and plot via polygon().

       -eval ">
                ccnt="$ccnt";
                fpt=get('firstpt',3,0);
                ik=get('k',0,0);
                lpt=get('lastpt',3,0);
                omega=get('atk',0,0);
                specw=get('sw',0,0);
                pp=vector"{3*($ccnt+1)}"([0,0,1]);
                circs=get('circles',"{12*$ccnt}",0);
                repeat(
                         ccnt,k,
                         idx=ccnt-k-1;
                         rbradx=mul(
                                     rot([0,0,1],circs[12*idx+2]*omega),
                                     circs[12*idx+3,9,1],
                                     3
                                   );
                         repeat(
                                 k+1,j,
                                 px=rbradx*pp[3*(k-j),3];
                                 pp[3*(k-j)]=px[0];
                                 pp[3*(k-j)+1]=px[1];
                                 pp[3*(k-j)+2]=px[2];
                               )
                      );
               ssx=get('ssxfrm',9,0);
               plt=ssx*pp[0,3];
               ik>0?
                   polygon(#-1,-2,[plt[0,2],lpt[0,2]],1,0xffffffff,255):
                   store(plt,'firstpt',3,1,1,1);
               store(plt,'lastpt',3,1,1,1);
               ik==(3*specw-1)?
                   polygon(#-1,-2,[fpt[0,2],plt[0,2]],1,0xffffffff,255)
              "
       atk={2*pi*($k/(3*$sw-1))}
   -done
~~~
???

= inversefourier
## Postscript: Inverse Fourier
||"Follow your nose" is a disparaging slant. The chattering classes may pronounce such when obsessed with the artlessness of some poor sod's code. It entails the crime of taking what's more-or-less in front of one's nose and coding a functional, straightforward and unimaginative design.\n\nDenigrations aside, there is much straightfoward and unimaginative work to be found in The Making of Things: yeoman efforts, useful if not exceptional, built along obvious — if not optimal — lines.\n\nEventually, somebody comes along with an arch, but until then, post-and-lintel serves just fine, thank you, in all the necessities that doors may have.\n\n

 Consider [wheelies](https://www.youtube.com/watch?v=-qgreAUpPwM): fantastic constructions of gyrating arrows, erupting on YouTube and the like, that do etch-a-sketch things: drawing birds, flowers, even portraits of Jean-Baptiste Joseph Fourier. Follow your nose and find just line segments — _wheelies_ — each with one rooted and one free endpoint. If making arabesques is your order, then look no further than a chain of wheelies.

[3blue1brown](https://www.youtube.com/watch?v=s_L-fp8gDzY) entered the expository fray with [But what is the Fourier Transform? A visual introduction.](https://www.youtube.com/watch?v=spUNpyF58BY) favoring illustrative animations over notational expository. Just a few wheels occasion arabesques, our jumping off point.

