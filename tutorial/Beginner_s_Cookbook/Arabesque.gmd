# Arabesques
%% x "mkdir -p img" %%
%% -m scripts/wheelie_anim.gmic input 600,600,1,3,lerp([200,200,230],[200,175,100],y/(h-1)) durga. 1,0,1,0.5,0,-3,0.5,0,-2,1,0,1 [-1]x48 erode_circ 2 -resize 50%,50%,1,3,5 o img/arabesque.mp4,24,H264 rm %%
|![Arabesque](img/arabesque.mp4)\n               *"Durga's idle arabesques"*|During brief interludes when tranquility prevails and the peoples of the world are in complete accord, Durga might take ease from her duties and find serenity through simple pursuits.\n\nIt is a small pleasure to swing a compass marker around its anchor leg, and if hands quop or quave, arcs still run true — not that palsy ever troubles Durga, master as she is of the _chakra_ and _trishul_. And so it is hardly burdensome for her to take up compass after compass, anchor to marker, twirling each at speeds, directions and separations sought through whimsy.\n\nSuch a flurry of hands and arms may strike mortals dumb with astonishment, but for the slayer of the abominable Mahishasura it is just so many twirlings. With each added compass, the culminating marker traces ways ever more sublime, awarding Durga escalating delights. And so it goes — until demons arise. Durga must then put away her compasses and take up her arrows and bow.
= wheelie
### Wheelies
Deficient as we are in arms, \'tis only through _wheelies_ that we might do what hands cannot. A wheelie models a compass pair: one end is an anchorage and the other swings free. We emulate Durga's trivial pursuit through a chain of such, anchor to marker, drawing arabesques of ever more intriguing complexity.

With each we may:

|      1.  |set a particular radius:|      _r_
|      2.  |pick a starting orientation:|      _θ_
|      3.  |choose a signed, clockwise or counterclockwise, rotational rate:|     _±ω_

A one-wheelie chain holds little fascination — it draws a circle — but is instructive nonetheless. Absolutes do not matter. A revolution may draw a circle in a microsecond or a millenium, but the time so taken does not alter the outcome. It is the drawing, and not the duration of its drafting, that matters.

While wheelies may be divorced from absolutes, relatives matter. A wheelie rotating at three times the rate of its antecedent will plot a track differing from one rotating twice as much. Ditto with lengths. Centimeters or kilometers do not matter. It is that one wheelie is two-thirds the length of the other and traces a path that differs from a ratio of three quarters. Ratios matter more than measures. Taking wheelies two-by-two and determining the shift from one to the other is the work put out for us.

Here then is the outline of our play:

|      1.  |root the first wheelie at the origin.
|      2a.  |root the other wheelies at successive free end points, perhaps setting their orientation differently or aligning them all. Do that any number of times, _or_
|      2b.  |attach a marker to the rim of a terminal wheelie and be done.

Circular motion is easy to fathom, but not too many wheelies in and complexity strikes us dumb. The remedy for that is patterns which, in recurrence, divide and conquer.

Two wheelies paired provide the unit pattern. Regard one as motionless; we can in a relative world. The other differs in length, _r_, or orientation  _θ_. With successive additions of _Δt_, _θ + ωt_ changes orientation, but, tick-for-tick, we can encapsulate in a single affine matrix how an anchor point translates and rotates to the space of the marker — and, in aggregate, how the origin of the entire ensemble transforms to the tip of the ultimate wheelie. That stepwise writing of matrices and their aggregation into one is our play. The arabesque of the whole arises from the plots of the parts, one for each _Δt_.

===
![wheeliediagram](images/wheeliewalk.svg)
*Walking from marker tip to the origin*
===

Now to particulars. The first piece is to write an [affine transform matrix](https://gmic.eu/tutorial/tiled_art.html#affinetransform) to encapsulate this unit pattern. For each wheelie, the transform takes a point at the anchor end and carries it to the marker, a displacement in _x_ and _y_, The transform also captures the wheelie\'s orientation of the moment: _θ + ωt_. We have everything we need to write a unit matrix:

===
$$
\begin{bmatrix} m_x \\ m_y \\ 1 \end{bmatrix} =
\begin{bmatrix}
\-cos (\theta + \omega t) & -\-sin (\theta + \omega t) & r_x \\
\-sin (\theta + \omega t) & \-cos (\theta + \omega t) & r_y \\
0 & 0 & 1
\end{bmatrix}
\begin{bmatrix} o_x \\ o_y \\ 1 \end{bmatrix}
$$
*Wheelie matrices*
===

The only remaining piece is the walk: that is, the aggregation of these particular wheelie matrices into one. The individual wheelie matrices describe each pseudo compass in isolation, as if the anchor ends are motionless. But that is true only for the initial wheelie. The motion of the second wheelie is its own circular motion compounded with that of its antecedent, and the third wheelie's motion is its own circular motion compounded with _both_ antecedents, and, in general, it is the wheelie's displacement along its length, coupled with its rotation, this compounded with _all_ antecedents. We might start from the tip and write the transform of its own simple rotation about its root and at the wheelie's length. Then we step down to the penultimate, record its own local transform and compose that with its successor. And along we go, walking from wheelie to wheelie, recording and compositing matrices as we go, until we arrive at the root.

And with that, we\'re done. The composite matrix transforms the origin of the entire ensemble to the marker of the final wheelie, accounting for all intermediary rotations and translations. Plot the mark. Then, on the next tick, account for the effects of _Δt_ and walk the walk again.

That's the game — and our play. All we have to do is code.

??? wheelie.gmic
~~~
  1wheelie :
  2
  3   # wheelie: a circle of a particular (1) radius, (2) phase angle
  4   # (orientation) and (3) discrete angular velocity - a relative integral
  5   # number of revolutions per however long one revolution takes. Wheelies
  6   # chain together, the center of one situated at 0° on the rim of its
  7   # predecessor. The first wheelie of the chain centers at the origin and
  8   # the last has, instead of another wheelie, an attached marking
  9   # pen. Thus, the entire ensemble draws an "arabesque" as the individual
 10   # wheelies rotate at their respective angular velocities from their
 11   # initial orientations.
 12   #   
 13   # Fetch an arbitrarily long argument list to $a0, $a1, …, $an
 14
 15   $=a
 16
 17   # Expect data triplets: radius, phase angle, angular velocity.
 18
 19   -check "isint($a1) && !(($#-1)%3)"
 20
 21   # Initial argument: side width (sw)
 22
 23   sw={$a1/2}
 24
 25   # Argument image: For each wheelie, compose radius and phase
 26   # arguments into a transformation matrix. In the generation loop, we
 27   # compose this with the angle resulting from one angular velocity
 28   # step.
 29
 30   ccnt={int($#-1/3)}
 31   -input $ccnt,1,1,12
 32   -name  args
 33
 34   # Iterate over argument vector. For each triplet – representing a
 35   # wheelie – Fetch radius (rad), phase angle (ang) and angular
 36   # velocity (sf) parameters.
 37
 38   -repeat $#-1,j
 39      -if   $j%3==0 # get radius
 40         rad=${a{2+$j}}
 41         -check isnum($rad)" && "$rad>=0" && "$rad<=1
 42         -set[args] $rad,{round($j/3,1,-1)},0,0,0
 43      -elif $j%3==1 # get angle, degrees
 44         ang=${a{2+$j}}
 45         -check isnum($ang)" && "$ang>=0" && "$ang<=360
 46         -set[args] $ang,{round($j/3,1,-1)},0,0,1
 47      -else         # get ω and set spectral coefficient
 48         sf=${a{2+$j}}
 49         -check isint($sf)" && "abs($sf)<=0.1*$sw
 50         -set[args] $sf,{round($j/3,1,-1)},0,0,2
 51      -fi
 52   -done
 53
 54   # Iterate over argument image, each 12 channel pixel representing
 55   # one wheelie. The first three channels contain wheelie radius,
 56   # phase angle and radial velocity. Compose a matrix transforming
 57   # the origin to the tip of the wheelie, a radial translation and
 58   # phase rotation. Populate the nine remaining channels with this
 59   # matrix.
 60
 61   -fill[args] ">
 62                  CPX=I;
 63                  orot=rot([0,0,1],deg2rad(CPX[1])); # phase rotation
 64                  xlat=eye(3);
 65                  xlat[2]=CPX[0];                    # translation origin-to-rim
 66                  FIN=[CPX[0,3,1],mul(orot,xlat,3)]; # phase rotation & translation
 67                  FIN                                # store above in 12-channel pixel
 68               "
 69   -permute[args] cyzx
 70   -store[args] circles
 71
 72   # Screenspace transform.
 73   ssxfrm={specw=get('sw',1,0);id=eye(3);id[0]=0;id[1]=specw[0]/2;id[2]=specw[0];id[3]=-specw[0]/2;id[4]=0;id[5]=specw[0];id}
 74
 75   # Draw arabesques on this image
 76   -input {2*$sw},{2*$sw},1,1
 77   -name. canvas
 78
 79   atk=0
 80   lastpt={vector3([0,0,1])}
 81   firstpt={vector3([0,0,1])}
 82   -repeat 3*$sw,k
 83       # For each wheelie:
 84       #    increment by angular velocity
 85       #    find corresponding rotation matrix
 86       #    compose with radial argument image, compose
 87       #    with screenspace transform and plot via polygon().
 88
 89       -eval ">
 90                const cc=$ccnt;
 91                fpt=get('firstpt',3,0);
 92                ik=get('k',0,0);
 93                lpt=get('lastpt',3,0);
 94                omega=get('atk',0,0);
 95                specw=get('sw',0,0);
 96                circs=get('circles',12*cc,0);
 97                const VLEN=3*cc+1;
 98                pp=vectorVLEN([0,0,1]);
 99                repeat(
100                         cc,k,
101                         idx=cc-k-1;
102                         rbradx=mul(
103                                     rot([0,0,1],circs[12*idx+2]*omega),
104                                     circs[12*idx+3,9,1],
105                                     3
106                                   );
107                         repeat(
108                                 k+1,j,
109                                 px=rbradx*pp[3*(k-j),3];
110                                 pp[3*(k-j)]=px[0];
111                                 pp[3*(k-j)+1]=px[1];
112                                 pp[3*(k-j)+2]=px[2];
113                               )
114                      );
115               ssx=get('ssxfrm',9,0);
116               plt=ssx*pp[0,3];
117               ik>0?
118                   polygon(#-1,-2,[plt[0,2],lpt[0,2]],1,0xffffffff,255):
119                   store(plt,'firstpt',3,1,1,1);
120               store(plt,'lastpt',3,1,1,1);
121               ik==(3*specw-1)?
122                   polygon(#-1,-2,[fpt[0,2],plt[0,2]],1,0xffffffff,255)
123              "
124       atk={2*pi*($k/(3*$sw-1))}
125   -done
~~~
???
= annotations
### Annotations
For those of you wishing to go into the weeds, here are the weeds:
??? Line-by-line Remarks
|  __Line__  |  __Remark__  
|  **15** | '$=a' A pseudo assignment. G'MIC transforms this into a series of actual assignments. This _'$-expression'_ generates an assignment sequence with the base name 'a' for however many elements on the command line there may be. '$a0' identifies the name of the script, so one could alter script behavior based on the script name. '$a1…' onward are the arguments. See [Adding Custom Commands](https://gmic.eu/reference/adding_custom_commands.html#top), ninth and last sub-bullet. There is nothing special about the base name _a_, by the way, and could be anything: '$=fruitloops_' initializes command line variables '$fruitloops_0, …, $fruitloops_'< _n_ >.
|  **19** |Sanity-check the arguments. 'wheelie' expects '$a1' to specify the length of one side of a square drawing canvas, so anticipates that the first argument is an integer. '$#' is another _'$-expression'_; this one resolves to the number of comma-separated arguments given 'wheelie'. Wheelie specifications occur in groups of three, _r_, _θ_ and _±ω_ so '!(($#-1)%3)' enforces arguments in triplets; it is *False* if the number of arguments, less the first, is not evenly divisable by three. Thus, the user specifies the image size with the first argument and employs triplets of successive arguments to specify wheelies, one triplet for each. Order matters. The first triplet specifies the root wheelie, the last designates the terminal marker wheelie.
|  **23,30** |Curly brace pairs indicate a number of possible substitutions, see [Substitution Rules](https://gmic.eu/reference/substitution_rules.html#top), and if the contents of curley braces cannot be attributed to requests for some image feature, it bottoms out to a math expression. For those new to math expressions, the encounter is a bit like falling into a rabbit hole, left-and-right curley braces ideographic of the impending cavity. Take a deep breath, grasp something solid, and remember that, above all, some kind of substitution is going on, and the source of it is the results of the math computation. In the present cases, they are the right hand sides of assignment operators that initialize pipeline variables. [Mathematical Expressions](https://gmic.eu/reference/mathematical_expressions.html#top) furnishes a complete, if terse, set of objects that make up mathematical expressions. Of the present cases, the first sets a resolution metric. '$sw' associates one unit of distance in the computation space of wheelies to a particular number of pixels, thus anchoring our relative lengths to something definite: the screen space of pixels. This resolution metric figures in a number of sizing tasks, such as scaling the number of plots necessary to draw an arabesque. Not so many for small pixel dimensions; a lot otherwise. The second derives 'circle count' – aka, the number of wheelies specified in the argument list. This is just the number of arguments dedicated to wheelie specifications, '$#-1', divided by three, because each wheelie consists of three arguments.
|  **30-53** |The 'args' image is not for display; it is an argument database. each pixel specifies aspects of one wheelie. Channels 0-2 hold _r_, _θ_ and _±ω_ and this first 'repeat'…'done' loop saves them for future reference, channels 3-11 are reserved for the wheelie-specific affine transforms, but these are not computed here. See the following annotations.
|  **54-71** |'fill' iterates over the 'args' image, computing "stage 1" affine transformations for each wheelie. Storage for each wheelie occupies a twelve channel pixel of the image; In each step in the fill, the current pixel, 'I', represents all that is known about one wheelie '**62**' aliases 'I' to 'CPX' for convenience. At present, these pixel vectors only hold  _r_, _θ_ and _±ω_. In this fill iteration, we compute and store a pre-computed "stage 1" matrix, the static transform encapulating only _r_, the wheelie length translation, and  _θ_, its rotation about the origin. Downstream, in the arabesque drawing loop, we do "stage 2": composite each "static" wheelie transform with an additional pure rotation derived from _±ωt_, accounting for the time-varying change in orientation. When done with filling this wheelie database, we harness [store](https://gmic.eu/tutorial/store.html) to make it accessible to the math expression parser. Math parsers downstream access the database through the 'circles' _image storage variable_.
|  **63** | 'rot()' generates pure rotational matrices: 2 × 2 for two dimensional work and 3 × 3 for three dimensional. In the latter form, one provides the axis of rotation to complete the specification. That we are operating in three dimensions may give one reason to pause. Recall our preference for working with homogeneous points, inhabitants of a three dimensional projective space, so that we can encapsulate both rotation and translation in one transform — as well as diambiguate points from vectors. In this case, the axis of choice is the z axis, perpendicular to the canvas, so that when we rotate points they stay in the canvas. The first use of this function gives us 'orot', _origin rotation_ derived from _θ_, inhabiting the second channel of the database image 'args'. 'deg2rad()' conveniently converts degree-based data into radians.   
|  **64,65** |We compose the translation matrix, 'xlat' by starting with the 3 × 3 identity matrix, as furnished by 'eye()'. Elements two and five of this matrix embodies translations. Curiously, we set only an _x_ translation, this the length of the wheelie occupying channel zero of the database pixel 'CPX'. What of _y_? Recall from the main discussion that we view individual wheelies in a relative way, so it suits us to build up the local wheelie transform where the wheelie itself is in a standard orientation, to wit: of zero degrees orientation with the wheelie length aligned to the _x_ axis. 
|  **66,67** |Overall, we re-compose the current pixel in a new 12 channel vector comprised of two fields. The first field, comprised of channels 0 - 2, is a copy of _r_, _θ_ and _±ω_ unchanged. This copy operation makes use of the _accessor_ operator, a pair of open-and-close square brackets, which takes as many as three arguments: \[ < _starting index_ >, < _subvector length_ >, < _stride_ > ]; the accessor operator extracts subvectors from source vectors. The first argument marks the index in the source vector where the subvector starts. It is the only required argument and, used in isolation, simply extracts a single element from the source vector. The second argument, if present, sets the length of the subvector. Thus V=[0,1,2,3,4,5,6,7,8,9]; SV=V[5,3] sets SV to [5,6,7], the three element subvector beginning at index=5. The third argument, if present, sets the _stride_, and defaults to increments of one element. Thus V=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];V[0,4,4] retrieves the subvector [0,4,8,12], the four element subvector starting at index 0 in the source and consisting of every fourth element. Accessing a subvector through the square bracket operator is a read-only operation; one cannot use it on the left hand side of an assignment operator and expect to set the values of left hand side subvectors. For that, use 'copy()', which can copy a subvector to a source.\n\nThe second field harnesses 'mul()' to compose two matrices: 'orot', the rotation component generated by  _θ_, and 'xlat' the translation component generated by _r_. The right-to-left multiplication, or _composition_, of the pure translation and rotation matrices produces the matrix that transforms the origin of the wheelie to the tip. This matrix reflects the combined operation of sliding a point positioned at the origin along the _x_ axis by a distance equal to the length of the wheelie, _r_, then rotating the position, now radially displaced from the origin, by _θ_. Care must be taken at this juncture, for the right-to-left composition of a translation and a rotation is not the same as a left-to-right composition of a rotation and a translation. With the latter, a matrix arises that reflects the combined operation of rotating a point at the origin, and _then_ translating it. The rotation is an operation of no consequence, as a point rotating around itself changes nothing at all. The translation simply carries the origin five units along the _x_ axis, the only consequece of this left-to-right composition. It is not mathematically "wrong"; it simply does not reflect the wheelie model we have in mind: a rotation of some point after a prior translation. The non-communicative quality of matrix multiplation is a source of many an interesting bug — amusing after the fact; annoying during its commission.\n\nWe form a new vector, FIN (final). FIN contains, front-to-back, the three- and nine-element fields consisting of the wheelie triplet and its allied affine transform. FIN by itself on the final line of the math expression is an implicit assignment to the current pixel in the iteration that the [fill]()          
|  **80-124** |The arabesque drawing loop operates once for each _±ωΔt_ angle tick, and, among other chores, it performs the "stage 2" matrix compositions. These, when complete, locate the marker position in relation to the origin. To peform this composition, the arabesque drawing loop first retrieves the pre-computed static wheelie transforms from 'circles' database, **97**: ' and applies the loop-specific _±ωΔt_ rotations to them. 

???

= inversefourier
## Postscript: Inverse Fourier
The foregoing discourse is exemplary of design by following one's nose. That is, designing by observing what's there. It is a respectable, though possibly pedestrian, pursuit, but in many quadrants it is a disparaging slant. The chattering classes may pronounce such when regarding the artlessness of some poor sod's code. It entails the crime of taking what's more-or-less in front of you and coding a functional, straightforward and unimaginative design.\n\nDenigrations aside, there is much straightfoward and commonplace work to be found in The Making of Things: yeoman efforts, useful if not exceptional, built along obvious — if not optimal — lines.\n\nEventually somebody comes along with an arch, but until then, post-and-lintel serves just fine, thank you, in all the necessities that doors may require in the letting of people go from room to room.\n\n
None of this is worth mentioning, perhaps, but for the arch hidden in the wheelies' post-and-lintel world.\n\n
A few years ago, Grant Sanderson (3blue1brown) wished to impart the _feel_
 Consider [wheelies](https://www.youtube.com/watch?v=-qgreAUpPwM): fantastic constructions of gyrating arrows, erupting on YouTube and the like, that do etch-a-sketch things: drawing birds, flowers, even portraits of Jean-Baptiste Joseph Fourier. Follow your nose and find just line segments — _wheelies_ — each with one rooted and one free endpoint. If making arabesques is your order, then look no further than a chain of wheelies.

[](https://www.youtube.com/watch?v=s_L-fp8gDzY) entered the expository fray with [But what is the Fourier Transform? A visual introduction.](https://www.youtube.com/watch?v=spUNpyF58BY) favoring illustrative animations over notational expository. Just a few wheels occasion arabesques, our jumping off point.

