# Arabesques
%% x "mkdir -p img" %%
%% -m scripts/wheelie_anim.gmic input 600,600,1,3,lerp([219,214,233],[219,187,91],y/(h-1)) durga. 1,0,1,0.125,0,7,0.5,0,-3,0.5,0,5 [-1]x48 erode_circ 2 -resize 50%,50%,1,3,5 o img/arabesque.mp4,24,H264 rm %%
|![Arabesque](img/arabesque.mp4)\n               *"Durga's idle arabesques"*|During brief interludes, when tranquility prevails and the peoples of the world are in complete accord, Durga might take ease from her duties and find serenity through simple pursuits.\n\nIt is a small pleasure to swing a compass marker around its anchor leg, and if hands might quave arcs still run true — not that palsy ever troubles Durga, master as she is of the _chakra_ and _trishul_. And so it is hardly burdensome for her to take up compass after compass, anchor to marker, twirling each at rates, revolutions and spreads picked through whimsy.\n\nSuch a flurry of hands and arms might astonish mortals, but for the slayer of the abominable Mahishasura it is just so many twirlings. With each added compass, the culminating marker traces ways ever more sublime, awarding Durga escalating delights. And so it goes — until demons arise. Durga must then put away her compasses and take up her arrows and bow.
= wheelie
### Wheelies
Deficient as we are in arms, we seek a computerized recompense. Accordingly, let _wheelies_ model compass pairs: one end of a segment is an anchorage and the other swings free. Chains of such then emulate Durga's compass-upon-compass pile-ons, drawing arabesques of ever more intriguing complexity.

With each wheelie we may:

|      1.  |set a particular radius:|      _r_
|      2.  |pick a starting orientation:|      _θ_
|      3.  |choose a signed, clockwise or counterclockwise, rotational rate:|     _±ω_

A one-wheelie chain holds little fascination — it draws a circle — but is instructive nonetheless. Absolutes do not matter. A revolution may draw a circle in a microsecond or a millenium, but the time so taken does not alter the outcome. It is the drawing, and not the duration of its drafting, that matters.

Likewise, a wheelie rotating at three times the rate of its antecedent traces different curlicues from one rotating at twice the rate. Differences in rotational rates matter over absolute rates. Ditto with lengths: one wheelie being two-thirds the length of its antecedent lays down epicycloids differing from that of a wheelie at three-quarters length.

Here then is the play:

|      1.  |root the first wheelie at the origin.
|      2a.  |root the other wheelies at successive free end points, perhaps setting their orientation differently or aligning them all. Do that any number of times, _or_
|      2b.  |attach a marker to the rim of a terminal wheelie and be done.

Circular motion is easy to fathom, but with just a few more wheelies, complexity strikes us dumb. The remedy for that is patterns. These, in recurrence, divide and conquer.

===
![wheeliediagram](images/wheeliewalk.svg)
*Walking from marker tip to the origin*
===

Paired wheelies provide the pattern. The game is to characterize motion in the locality of a wheelie pair, which is simple, circular motion. Then aggregate motions of pairs into the motion of the whole.

To that end, we may, in a relative way, choose for one wheelie in the pair a coordinate system that best suits simplicity. So place one of the pair coincident to zero degrees, aligned with the _x_ axis. Now bring in its successor. It's origin attaches to the antecedent's tip and its own tip swings free. The elements that account for the successor's motion in relation to its antecedent are its length, _r_, and its orientation _θ + ωt_. Here, _ωt_ may be regarded as the time-varying part of the successor's orientation; it is the product of the successor's rotational rate and accumulated time ticks: _t = (Δt₀ + Δt₁ + … )_. Overall, these elements fix where the successor's tip lies in relation to its origin — which is also the tip of its antecedent.

These elements may be organized into an [affine matrix](https://gmic.eu/tutorial/tiled_art.html#affinetransform) relating the successor's tip to its origin. Such a matrix can take a point in the neighborhood of the successor's origin (née antecedent's tip) through a translation by _r_ and a rotation by _θ + ωt_, placing them in the neighborhood of successor's tip:

===

$$
\begin{bmatrix} m_x \\ m_y \\ 1 \end{bmatrix} =
\begin{bmatrix}
\-cos (\theta + \omega t) & -\-sin (\theta + \omega t) & r_x \\
\-sin (\theta + \omega t) & \-cos (\theta + \omega t) & r_y \\
0 & 0 & 1
\end{bmatrix}
\begin{bmatrix} o_x \\ o_y \\ 1 \end{bmatrix}
$$
*A Wheelie transform taking a point at _o_ (origin) to _m_ (tip)*
===

As _Δt_ accumulates and _ωt_ changes, the tip plots a circle of radius _r_; not very interesting but readily grasped. Shift to the antecedent. Write a second transform that describes how the antecedent's tip's moves in relation to _its_ antecedent: a second circular plot. To characterize both motions we composite the two matrices from right to left. Shift again. Write a third transform and composite that with the prior two.

And so we go, from wheelie to wheelie, compounding individual circular motions and eventually obtaining the composite of the final tip to the initial root. That stepwise writing of matrices and their aggregation into one is our divide-and-conquer play. The arabesque of the whole arises from the actions of the parts.

And we\'re done. The composite matrix transforms the origin of the entire ensemble to the marker of the final wheelie, accounting for all intermediary rotations and translations. Plot the mark. Then, on the next tick _Δt_, orientations change by _ω(t+Δt)_; we recomposite matrices and plot again. And so on. And so forth.

That's our play. All that's left is to code.

??? wheelie.gmic
~~~
  1 wheelie :
  2    # wheelie: a circle of a particular (1) radius, (2) phase angle
  3    # (orientation) and (3) discrete angular velocity - a relative
  4    # integral number of revolutions per however long one revolution
  5    # takes. Wheelies chain together, the center of one situated at 0°
  6    # on the rim of its predecessor. The first wheelie of the chain
  7    # centers at the origin and the last has, instead of another
  8    # wheelie, an attached marking pen. Thus, the entire ensemble draws an
  9    # "arabesque" as the individual wheelies rotate at their respective
 10    # angular velocities from their initial orientations.
 11
 12    # Fetch an arbitrarily long argument list to $a0, $a1, …, $an
 13
 14    $=a
 15
 16    # Expect data triplets: radius, phase angle, angular velocity.
 17
 18    -check "isint($a1) && !(($#-1)%3)"
 19
 20    # Initial argument: side width (sw)
 21
 22    sw={$a1/2}
 23
 24    # Argument image: For each wheelie, compose radius and phase
 25    # arguments into a transformation matrix. In the generation loop, we
 26    # compose this with the angle resulting from one angular velocity
 27    # step.
 28
 29    wcnt={int(($#-1)/3)}
 30    -input $wcnt,1,1,12
 31    -name.  args
 32
 33    # Iterate over argument vector. For each triplet – representing a
 34    # wheelie – Fetch radius (rad), phase angle (ang) and angular
 35    # velocity (sf) parameters.
 36
 37    -repeat $#-1,j
 38       -if   $j%3==0 # get radius
 39          rad=${a{2+$j}}
 40          -check isnum($rad)" && "$rad>=0
 41          -set[args] $rad,{round($j/3,1,-1)},0,0,0
 42       -elif $j%3==1 # get angle, degrees
 43          ang=${a{2+$j}}
 44          -check isnum($ang)" && "$ang>=0" && "$ang<=360
 45          -set[args] $ang,{round($j/3,1,-1)},0,0,1
 46       -else         # get ω and set spectral coefficient
 47          sf=${a{2+$j}}
 48          -check isint($sf)" && "abs($sf)<=0.1*$sw
 49          -set[args] $sf,{round($j/3,1,-1)},0,0,2
 50       -fi
 51    -done
 52
 53    # Iterate over argument image, each 12 channel pixel representing
 54    # one wheelie. The first three channels contain wheelie radius,
 55    # phase angle and radial velocity. Compose a matrix transforming
 56    # the origin to the tip of the wheelie, a radial translation and
 57    # phase rotation. Populate the nine remaining channels with this
 58    # matrix.
 59
 60    -fill[args] ">
 61                   CPX=I;
 62                   orot=rot([0,0,1],deg2rad(CPX[1])); # phase rotation
 63                   xlat=eye(3);
 64                   xlat[2]=CPX[0];                    # translation origin
 65                   FIN=[CPX[0,3,1],mul(orot,xlat,3)]; # -to-rim, i.e.
 66                   FIN                                # 'rotation & xlation'
 67                "                                     # store above in
 68                                                      # 12-channel pixel
 69    -permute[args] cyzx
 70    -store[args] circles
 71
 72    # Screenspace transform.
 73    ssxfrm={"
 74             specw=get('sw',0,0);
 75             id=eye(3);
 76             id[0]=0;
 77             id[1]=specw/2;
 78             id[2]=specw;
 79             id[3]=-specw/2;
 80             id[4]=0;
 81             id[5]=specw;
 82             id
 83            "}
 84
 85    # Draw arabesques on this image
 86    -input {2*$sw},{2*$sw},1,1
 87    -name. canvas
 88
 89    atk=0
 90    lastpt={vector3([0,0,1])}
 91    firstpt={vector3([0,0,1])}
 92    -repeat 3*$sw,k
 93        # For each wheelie:
 94        # increment by angular velocity
 95        # find corresponding rotation matrix
 96        # compose with radial argument image, compose
 97        # with screenspace transform and plot via polygon().
 98
 99        -eval ">
100                 const cc=$wcnt;
101                 fpt=get('firstpt',3,0);
102                 ik=get('k',0,0);
103                 lpt=get('lastpt',3,0);
104                 omega=get('atk',0,0);
105                 specw=get('sw',0,0);
106                 circs=get('circles',12*cc,0);
107                 pp=vector3([0,0,1]);
108                 imat=eye(3);
109                 repeat(
110                          cc,k,
111                          idx=cc-k-1;
112                          imat=mul(
113                                      mul(
114                                           rot([0,0,1],circs[12*idx+2]*omega),
115                                           circs[12*idx+3,9,1],
116                                           3
117                                         ),
118                                      imat,
119                                      3
120                                  );
121                       );
122                ssx=get('ssxfrm',9,0);
123                plt=ssx*(imat*pp);
124                ik>0?
125                    polygon(#$canvas,-2,[plt[0,2],lpt[0,2]],1,0xffffffff,255):
126                    store(plt,'firstpt',3,1,1,1);
127                store(plt,'lastpt',3,1,1,1);
128                ik==(3*specw-1)?
129                    polygon(#$canvas,-2,[fpt[0,2],plt[0,2]],1,0xffffffff,255)
130               "
131        atk={2*pi*($k/(3*$sw-1))}
132    -done
~~~
???

= annotations
### Notations and Annotations
For those of you wishing to go into the weeds, here be the weeds:
??? Line-by-line Remarks
|  __Line__  |  __Remark__  
|  **14** | '$=a' A pseudo assignment. G'MIC transforms this into a series of actual assignments. This _'$-expression'_ generates an assignment sequence with the base name 'a' for however many elements on the command line there may be. '$a0' identifies the name of the script, so one could alter script behavior based on the script name. '$a1…' onward are the arguments. See [Adding Custom Commands](https://gmic.eu/reference/adding_custom_commands.html#top). There is nothing special about the base name 'a'. It could be anything: '$=fruitloops' initializes command line variables '$fruitloops0, …, $fruitloops<n>'.
|  **16-27** |We sanity-check the arguments. 'wheelie' expects '$a1' to specify the length of one side of a square drawing canvas, so anticipates that the first argument is an integer. '$#' is another _'$-expression'_; this one resolves to the number of comma-separated arguments given to 'wheelie'. Wheelie specifications occur in groups of three, _r_, _θ_ and _±ω_ so '!(($#-1)%3)' enforces arguments in triplets; it is _False_ if the number of arguments, less the first, is not evenly divisable by three. Thus, the user specifies the image size with the first argument and employs triplets of successive arguments to specify wheelies, one triplet for each.
|  **22,29** |Curly brace pairs indicate a number of possible substitutions, see [Substitution Rules](https://gmic.eu/reference/substitution_rules.html#top), and if the contents of curly braces cannot be attributed to requests for some image feature, it bottoms out to a math expression. For those new to math expressions, the encounter is a bit like falling into a rabbit hole, left-and-right curly braces ideographic of the impending cavity. Take a deep breath, grasp something solid, and remember that, above all, some kind of substitution is going on, and the source of it is the results of the math computation. In the present cases, they are the right hand sides of assignment operators that initialize pipeline variables. [Mathematical Expressions](https://gmic.eu/reference/mathematical_expressions.html#top) furnishes a complete, if terse, set of objects that make up mathematical expressions. Of the present cases, the first sets a resolution metric. '$sw' associates one unit of distance in the computation space of wheelies to a particular number of pixels, thus anchoring our relative lengths to something definite: the screen space of pixels. This resolution metric figures in a number of sizing tasks, such as scaling the number of plots necessary to draw an arabesque. Not so many for small pixel dimensions; a lot otherwise. The second derives 'circle count' – aka, the number of wheelies specified in the argument list. This is just the number of arguments dedicated to wheelie specifications, '$#-1', divided by three, because each wheelie consists of three arguments.
|  **29-51** |The 'args' image is not for display; it is an argument database. Each pixel specifies aspects of one wheelie. Elements 0-2 hold _r_, _θ_ and _±ω_ and this first 'repeat'…'done' loop saves them for future reference, elements 3-11 are reserved for the wheelie-specific affine transforms, but these are not computed here. See the following annotations.
|  **53-70** |'fill' iterates over the 'args' image, computing "stage 1" affine transformations for each wheelie. Storage for each wheelie occupies a twelve channel pixel of the image; In each step of the fill, the current pixel, 'I', represents all that is known about one wheelie **61** aliases 'I' to 'CPX' for convenience. At the outset, these pixel vectors just hold  _r_, _θ_ and _±ω_. Over the course of iteration, we compute and store a pre-computed "stage 1" transform matrix, the static transform encapulating only _r_, the wheelie length translation, and  _θ_, its time-independent initial rotation about the origin. Downstream, in the arabesque drawing loop, we compute a "stage 2" matrix, to wit: we composite each stage 1 wheelie transform with an additional pure rotation derived from _±ωt_, applying the time-varying change to wheelie orientation. When done with filling this "wheelie database", we harness [store](https://gmic.eu/tutorial/store.html) to make the wheelie vectors accessible to the math expression parser; it may do so through the 'circles' _image storage variable_. The permutation prior to 'store' is for convenience. The reorganizing of the 'args' image through this permutation leaves wheelie components arrayed along the 'arg' image 'x' axis instead of along its spectral axis. The wheelie vectors contiguous along the 'x' axis make for more straightforward access in the arabesque drawing loop.
|  **62** | 'rot()' generates pure rotational matrices: 2 × 2 for two dimensional work and 3 × 3 for three dimensional. In the latter form, one provides the axis of rotation to complete the specification: '[0,0,1]' identifies the three-space _+z_ unit axis.\n\nThat we are operating in three dimensions may give one reason to pause. Recall our preference for working with [homogeneous points](https://gmic.eu/tutorial/tiled_art.html#affinetransform), inhabitants of a three dimensional projective space, so that we can encapsulate both rotation and translation in one transform — as well as diambiguate points from vectors. In this case, the axis of choice is the _+z_ axis, perpendicular to the canvas, so that when we rotate points in the canvas plane, they stay in the canvas plane. The first use of this function gives us 'orot', _origin rotation_ derived from _θ_, the second element of the wheelie vector. 'deg2rad()' conveniently converts this element from degrees to radians. So does the ° operator — the degree symbol. Thus 45.739° in a G'MIC math expression quietly transforms itself into ≈ 0.798296 radians. Consult your operating system manual on how to obtain off-keyboard characters if you cannot find the ° sign on it. 
|  **63,64** |We generate the translation matrix, 'xlat' by starting with the 3 × 3 identity matrix, as furnished by 'eye()'. In an affine transform, elements two and five embody spatial displacement. We set only an _x_ displacement, this the length of the wheelie; what of _y_? Recall from the main discussion that we view individual wheelies in a relative way, so it suits us to build up the local wheelie transform where the wheelie itself is in a standard orientation: zero degrees orientation with the wheelie aligned to the _+x_ axis. Thus, in this most local of spaces, there is no displacement in _y_.
|  **65,66** |Overall, we re-compose the 12 element wheelie vector from two fields. The first, elements 0 - 2, copies _r_, _θ_ and _±ω_.\n\nThis copy makes use of the _accessor_ operator, a pair of open-and-close square brackets, which takes as many as three arguments: `[<starting index>, <subvector length>, <stride>]`; the accessor operator extracts subvectors from source vectors. The first argument marks the index in the source vector where the subvector starts. It is the only required argument and, used in isolation, simply extracts a single element from the source vector. The second argument, if present, sets the length of the subvector. Thus 'V=[0,1,2,3,4,5,6,7,8,9]'; 'SV=V[5,3]' sets 'SV' to '[5,6,7]', the three element subvector beginning at index = '5'. The third argument, if present, sets the _stride_, and defaults to increments of one element. Thus 'V=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];V[0,4,4]' retrieves the subvector '[0,4,8,12]', the four element subvector starting at index '0' in the source and consisting of every fourth element. Extracting a subvector through the accessor operator is a read-only operation; one cannot use it on the left hand side of an assignment and expect to set the values of a left hand subvector. For that, consider 'copy()', which can transcribe a subvector to a source.\n\nThe second field composing the wheelie vector harnesses 'mul()' to compose the two matrices: 'orot', the rotation component generated from  _θ_, and 'xlat' the translation component generated from _r_. The right-to-left multiplication, or _composition_, of the translation and rotation matrices produces the _wheelie matrix_. This matrix transforms a point at the origin of the wheelie to its tip and reflects the combined operation of displacing the point along the _+x_ axis by a distance equal to the length of the wheelie (_r_) then rotating this position vector by _θ_. Care must be taken, for the right-to-left composition of a translation and a rotation is not the same as a left-to-right composition of a rotation and a translation. With the latter, the resulting matrix reflects the combined operation of first rotating the point at the origin, and _then_ translating it. Alas! The rotation of a zero-length position vector is of no consequence. A point rotating around itself remains unchanged. That leaves just the translation, not a full characteration of the transform. That is why the composition starts with 'xlat', generating a positive length displacement, to which we compose 'orot', the displacement vector rotated, and not the other way around. The non-communicative quality of matrix algebra is a source of many an interesting bug — amusing after the fact, exasperating in the moment.\n\nWe form a new wheellie vector, 'FIN' (final). 'FIN' contains, front-to-back, the three- and nine-element fields consisting of the wheelie triplet and its allied affine transform. 'FIN' by itself on the final line of the math expression is an implicit assignment to some "target." What that target may be depends on command line context in which the math expression was invoked. In the context of the [fill](https://gmic.eu/tutorial/fill.html) command, that target is the current pixel in the fill image iteration.
|  **72-84** |This screenspace transform is an off-to-one-side calculation and composites a right hand 270° rotation matrix with a lefthand scaling matrix. Both the scaling and the rotation stem from artistic whimsy, shrinking the arabesque by 50% for generous margins and orienting the _+x_ axis to align with screen space _+y_, so that the drawing of arabesques in start from 12 o'clock. Why 12 o'clock? Clients of this script generate animations, and 12 o'clock is deemed a pleasing place to start such — whimsy again. One could also have written 'V=eye(3);V[0]=specw/2;V[2]=specw;V[4]=specw/2;V[5]=specw;mul(V,rot([0,0,1],270°),3)' to produce the same screen space transform. The scaling maps a unit distance in our computational space to one quarter of the canvas height (or width), a definite number of pixels: '$sw/4'. Adjust the denominators of 'V[0]=specw/2; V[4]=specw/2' downward toward one for larger arabesques; upward to infinity for smaller arabesques.
|  **85-121** |The arabesque drawing loop draws one mark of the arabesque per iteration. '-repeat 3*$sw,k … -done' establishes the number of plots; 'k' grows with larger images. The multiplier, '3', also stems from artistic whimsy; lower this multiplier for faster, sparser plotting. The loop operates once for each _Δt_.\n\nThe wheelie walk discussed in the main article is realized through the '-repeat cc,k … -done' loop from **109-121** and, among other chores, it retrieves the stage 1 time-independent transform from 'circs', the wheelie database, and composites it with the rotation matrix for _ωt_. The inner 'mul()' expression spanning **113-117**, performs this composition. The rotation matrix for _ωt_ is the first term of 'mul()': 'circs[12*idx+2]' retrieves the wheelie-specific angular velocity, _ω_, from the wheelie database; 'omega' holds accumulated "time", a whimsical proxy for travelling through parameter space. 'Omega' is a math expression alias for the command line analog, '$atk'. See **131** and **104**, which brings the command line variable '$atk' into the math expression. Rotation around the _+z_ projection space axis produces the rotation matrix for _ωt_. The second term of 'mul()' is the stage 1 time-independent transform, the composition of _r_ and _θ_. The composition of these two terms produces the dynamic version of the wheelie matrix.\n\nThe outer 'mul()' expression spanning **112-120**,accumulates the dynamic wheelie matrices into imat — this, the realization of the tip-to-origin walk. Dropping out of the 'repeat' loop spanning **109-121** delivers 'imat'. It embodies the entire transform of a point at the origin of the entire ensemble up to the tip of the final wheelie.
|  **122-130** |The bottom of the arabesque drawing loop concerns itself with plotting arabesque marks: line segments between adjacent _Δt_ plots and drawn by 'polygon()'. The drawing loop maintains a two-plot window, realized by storage variables 'firstpt' and 'lastpt' These points are in screen space, so the matrix responsible for that transform is summoned from storage variable 'ssxform'. Recall **72-84**. Referring to **123**, 'imat*pp' carries a point from the origin to the wheelie tip and is subsequently transformed by 'ssx' into a screen space plot.\n\nTo create a two point plotting window, the drawing loop retains the plot of the previous iteration in 'lastpt' and draws from that to the current plot; before the iteration finishes, the current plot becomes the next inhabitant of 'lastpt', to serve in a similar capacity in the next iteration. That accounts for most drawing activity, excepting the initial and final boundary cases. Nothing is plotted in the first iteration. Instead, the initial plot is stashed to both 'firstpt' and 'lastpt'. Through all remaining iterations, up to the last, 'firstpt' is undisturbed. When the last iteration is realized and plotting has taken place, there remains a gap between 'firstpt' and 'lastpt.' These become plot points for an extra, final call to 'polygon()', which closes the gap between the initial and final plots, finishing the arabesque.

???

= inversefourier
## Postscript:
Drawing arabesques through wheelies exemplifies the art of following one's nose, a respectable, if pedestrian, approach, artless more than artful. Following one's nose entails building what's in front of you, more-or-less.

Take our central construct. A wheelie is not far removed from a pair of drawing compasses — by design. This transcription poses few mysteries, few pauses to re-consider, and a concomitant increased liklihood of getting the job done on time and in budget. Those who habitually do that get re-hired. It's post-and-lintel work, to be sure, but serves just fine, thank you, in all that doors require for letting people get around walls.

===
![spectralspace](images/spectralspace.svg)
*The wheelie as a spectral space point*
===

But along comes an arch, a disruptive technology. For wheelies, such disruption stems from inverse Fourier transforms, with which step-and-repeat plotting can be ditched, as the transform generates the entire arabesque in just one throw.

To ease into how so, let's take the new play at its face:
|      1.  | Regard every wheelie as a complex number. Orientation, _θ_, separates _r_ into real and imaginary parts.
|      2.  | So written, plot these in a _spectral space_ Plot wheelie sums in a discrete, circular spectral space graduated in integral rotational rates from _-(n-1)ω_, … _0ω_, … _nω_, _n_ a rotation rate of our choosing and called the _folding_ or [Nyquist rate](https://en.wikipedia.org/wiki/Nyquist_rate).
|      2a.  |Folding rate ties to the idea of sampling. The more samples — the larger folding rate — the better, insofar as reproduction goes, but more expensive insofar as processing.
|      2b.  |As a rough rule of thumb, the folding rate should be at least as large as twice the sum of the absolute values of all wheelie rotational rates.V
|      2c.  |The values assumed by coordinates along the _ω_ axis, spectral samples, are complex numbers. Nominally one dimensional, spectral space values may be plotted in the complex plane, (_r_ × _i_), without loss of generality. 
|      3.  | Wheelie sumnation: starting from the root, for each add the current wheelie to all its antecedents, summing real, imaginary and rotation components separately, and plot this result in spectral space at the aggregated value _Σω_. The root wheelie, of course, has no antecedents; we simply plot the root. This sum can be negative: conside a two wheelie chain where the first rotates counterclockwise at one revolution and the second rotates clockwise at seven revolutions, the net for the second wheelie: six clockwise revolutions, taken to be negative. To this, add the Nyquist Rate. That is, we perform clock arithmetic in this spectral space.    
|      4.  |We take the inverse Fourier transform of the spectral space and plot the results on the complex plane. That is the arabesque. We are done.

===
|- ![wheeliespatial](images/wheeliespatial.svg)
|* Spatial plots over slices of time *
| ![wheeliespectral](images/wheeliespectral.svg)
|* Spectral plots over slices of angular velocity * 
===


This new slant for plotting arabesques opens up with what the circular motion of a wheelie represents. Comprised of a length _r_ at an initial orientation _θ_, and rotating at an angular velocity of _±ω_, a spinning wheelie finds representation as a _spectral space_ point. One axis of this spectral space embodies rotation, _±ω_. The other axis embodies the length of the wheelie _r_ at an orientaton _θ_ — a complex number _r(cos θ + isin θ)_. A composition of these spectral space "wheelie plots", analogous to the wheelie walk of matrix compositions done before, can — in some fashion — constitute an arabesque.


A few years ago, Grant Sanderson (3blue1brown) wished to impart the _feel_
 Consider [wheelies](https://www.youtube.com/watch?v=-qgreAUpPwM): fantastic constructions of gyrating arrows, erupting on YouTube and the like, that do etch-a-sketch things: drawing birds, flowers, even portraits of Jean-Baptiste Joseph Fourier. Follow your nose and find just line segments — _wheelies_ — each with one rooted and one free endpoint. If making arabesques is your order, then look no further than a chain of wheelies.

[](https://www.youtube.com/watch?v=s_L-fp8gDzY) entered the expository fray with [But what is the Fourier Transform? A visual introduction.](https://www.youtube.com/watch?v=spUNpyF58BY) favoring illustrative animations over notational expository. Just a few wheels occasion arabesques, our jumping off point.

# gmic spectralarabesque.gmic spectralarabesque 512,0.5,20,1,0.5,45,-3,0.5,60,-7
#   1  0.469846, 0.171010
# 248 -0.286788, 0.409576
# 255  0.211309, 0.453140
# Proof of concept: gmic -debug wheelie_aplot.gmic svgtowheelie.gmic wheelie 1024,1,0,1,0.5,0,4,0.125,0,3,0.5,0,2 -name. spectral mkwheelielist[spectral] 16 wlist=\${} keep[0] wheelie 1024,\$wlist o[0] foo_one.png o[1] foo_too.png 
