#@cli svg2wheelie : "file",_density,_wheeliecount
#@cli : Generate wheelie triplets from samples of an SVG path. Requires
#@cli : Python 3.x and python module svgpathtools by Andrew Port
#@cli : (mathandy) et al. https://github.com/mathandy/svgpathtools.
svg2wheelie:
# Sample a closed Structured Vector Graphics (SVG) path at regular
# intervals and from that, estimate the orientations, revolutions and
# radii of a chain of wheelies, a.k.a. "epicycles" required to trace
# that path. (1) path to an SVG file. Currently expects one defined
# path, others are ignored. (2) Resolution sets the number of samples at
# powers of two. Resolution → 8 → 2⁸ → 256 samples. Defaults to 10
# (1,204 samples) (3) Limit the number of wheelies to the given
# number. Defaults to 16.

   check "isfile('${1}') &&
          isint(${2=10}) &&
          ${2}>0         &&      
          isint(${3=16}) && 
          ${3}>2
         "
   fname=$1
   res=$2
   wcnt=$3
   normdiv=1
   svg2plots $fname,$res
   split. y
   fft[-2,-1]
   append[-2,-1] c
   name. spectral
   div[spectral] {w#$spectral}
   mkwheelielist[spectral] $wcnt
   wlist=${}
   rm.

#@cli mkwheelielist : wheelie_count
#@cli : Selected image is a 2n,1,1,2 frequency domain map
#@cli : ('spectral') for a Nyquist Sampling rate of n, a
#@cli : count of pixels. Image is from an forward discrete
#@cli : Fourier transform of path samples (fft) with the reals
#@cli : occupying channel 0 and imaginaries occupying
#@cli : channel 1. (1) wheelie_count: Limit the number of
#@cli : wheelies to the given number. Defaults to 16.
mkwheelielist :
   name. spectral
   check isint(${1=16})" && "${1}>2
   wcnt=$1
   
# Clear zero frequency, eliding any offset from
# the Argand plane origin. As a consequence, the 
# root wheelie originates at the origin.

   -set[spectral] 0,0,0,0,0
   -set[spectral] 0,0,0,0,1

   # Image for dynamic array (da) storage of frequency
   # domain ordinals

   -input 0
   -name. coefficients

   # Scan spectral image for non-zero ordinals, as many
   # can be zero-length and have no bearing on the
   # arabesque. Setting wfound to the count of
   # non-zero, meaningful coeffiecients; the
   # coefficient image acquires the meaningful
   # coefficients, in polar form. Scan alternately down
   # the counterclockwise (m%2==0) and clockwise
   # (m%2!=0) portions of the frequency axis, toward
   # the Nyquist Sampling Rate mid-point. 'o' obtains
   # the rotational rate in each loop; 'j' is the index
   # to the currently assayed ordinal — it alternates
   # between clockwise and counterclockwise indices;
   # 'm' is the loopcounter.

   wfound={">
            wc=get('wcnt',0,0);
            sz=0;
            repeat(2*wc,m,
                sw=w#$spectral;
                if(
                      m%2==0,
                      j=int(m/2)+1;
                      o=j,
                      j=sw-(int(m/2)+1);
                      o=-(int(m/2)+1)
                  );
                rad=norm2(I(#$spectral,j,0));
                if(rad>0,
                      ang=atan2(
                                 i(#$spectral,j,0,0,1),
                                 i(#$spectral,j,0,0,0)
                               );
                      ang=rad2deg(ang);
                      ang<0?ang=ang+360;
                      da_push(#$coefficients,[rad,ang,o])
                  );
                  );
            da_size(#$coefficients)
           "}
   -if $wfound

   # The coefficient image may be manipulated as an
   # image as well as a dynamic array; crop the
   # penultimate and last pixel, containing the array
   # length counter. The remainder of the array
   # contains a permutation of non-zero
   # coefficients. In this fill operation, we pair-wise
   # difference them to separate out wheelies. By
   # virtue of our "ends-to-the-middle" scan, we have
   # prepared a permutation from which the slowest
   # rotating wheelies are on the root end of the
   # chain, alternating clockwise and counterclockwise
   # rotating wheelies.

      -crop[coefficients] 0,0,0,{$wfound-1}
      -fill[coefficients] "<
                             y==0?I:
                             [
                              i(0,y,0,0),
                              i(0,y,0,1)-i(0,y-1,0,1),
                              i(0,y,0,2)-i(0,y-1,0,2)
                             ]
                          "

   # Turn negative angle orientations 360° to situate
   # them between zero and three-sixty degrees.

   -fill[coefficients] ">if(c==1,if(i<0,i+360,i),i)"
   -fi
   
   # Permute coefficient image in such a way as to
   # order the data stream in magnitude, orientation
   # and rotational rate triplets, as expected by
   # wheelie plotters. Returned as a status string.

   permute[coefficients] xczy

   wheelie={crop(#$coefficients)}
   -remove[coefficients]
   -status $wheelie

#@cli svg2plots : "file",_resolution
#@cli (1) Retrieve the first path in the SVG 1.1 $file
#@cli argument and render it (2) at the indicated
#@cli resolution, a power of 2: $_resolution = 8 → 2⁸ → 256.
#@cli Resolution defaults to 10; paths are plotted
#@cli with 1,204 points.
svg2plots:
   check "isfile('${1}') && isint(${2=10}) && ${2}>0"

   # Python helper writes plots to a text file.
   # We furnish a temporary file to receive its
   # output.

   -file_rand
   outfile=${}
   fname=$1
   res=$2

   # Assume a script subdirectory containing python helper
   # See svghelper.py for details.

   helpercommand="svghelper.py                \
                  --normalize                 \
                  --density "$res"            \
                  --output "$outfile" "$fname

   -exec $helpercommand
   -if !isfile('$outfile')
      error "Could not process "$outfile"!"
   -fi
   -input_csv $outfile,0
   -delete $outfile
   -permute. yxzc
