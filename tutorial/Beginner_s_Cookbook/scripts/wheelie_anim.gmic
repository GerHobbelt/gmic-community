#@cli wheelie_anim : frames_per_revolution,radius_0,phase_0,angular_velocity_0,…,radius_k,phase_k,angular_velocity_k,…
#@cli : Compose arabesque rotational animation using a three image selection:
#@cli : [-3] Transparent, optionally pre-drawn, image for the arabesque. [-2]:
#@cli : four channel fader multiplier and [-1]: background image. The number
#@cli : of segments follow from the like number of argument triplets formed by
#@cli : the arguments following "frames_per_revolution". A single triplet of
#@cli : three arguments specifies length, orientation and integral angular
#@cli : velocity of one "wheelie", or anchored segment, It is an error if the
#@cli : argument list, less the frames_per_revolution argument, is not
#@cli : divisible by three. Replaces selection with (1) an animation image
#@cli : sequence of a length equal to the frames_per_revolution argument, and
#@cli : (2) the arabesque transparency reflecting the last frame state,
#@cli : suitable for use as a pre-drawn image for successor arabesque
#@cli : animations.
#@cli : $ 1024,1024,1,4 nm. arabesque (0.99^0.94^0.92^0.99) nm. mult [0] nm. back fill_color[back] 127,127,127,255 wheelie_anim[arabesque,mult,back] 360,0.5,0,1,0.5,30,-5,0.5,315,-2 rm. o wheelanim.mp4,30,H264

wheelie_anim:
   # wheelie: a circle of a particular (1) radius, (2) phase angle
   # (orientation) and (3) discrete angular velocity - a relative
   # integral number of revolutions per some unspecified base interval,
   # perhaps however long one revolution takes. Wheelies chain
   # together, the center of one situated at 0° on the rim of its
   # predecessor. The first wheelie of the chain centers at the origin
   # and the last has, instead of another wheelie, an attached marking
   # pen. Thus, the entire chain draws an "arabesque" as the
   # individual wheelies rotate at their respective angular velocities from
   # their initial orientations. This script animates such.

   # This script renders arabesques "traditionally": Each wheelie has
   # radial, phase and angular velocity components.  For each
   # increment, and, for each wheelie, apply the angular velocity
   # increment, rotating the wheelie, then, with all wheelies rotated,
   # plot the endpoint.

   emsg="Select three images, to wit: [-3]: Transparent, optionally pre-drawn, image for the arabesque. [-2]: four channel fader multiplier and [-1]: three channel background image; 1:1 aspect ratio works best."
   -if size([$[]])!=3
      -error $emsg
   -fi
   -name... arabesque
   -name..  multiplier
   -name.   background
   -resize[multiplier] [arabesque],[arabesque],[arabesque],[arabesque],1
   -remove_opacity[background]
   -store[multiplier] multiplerimage
   -local[arabesque,background]
      # Fetch an arbitrarily long argument list to $a0, $a1, …, $an
      $=a

      # Expect argument one as initial frames per revolution, followed by
      # data triplets: radius, phase angle, angular velocity.

      -check {!(($#-1)%3)}

      # Initial argument: frame count per revolution
      -check "isint($a1) && $a1>0"
      frames_per_rev=$a1

      # scaling width is the smallest dimension
      sw={min(w,h)/2}
      -if $sw%2==0
         sw+=1
      -fi

      # Circles argument vector: For each wheelie, compose radius and
      # phase arguments into a homogeneous transform. In the animation
      # loop, we compose this with the "angular tick dependent" (atk)
      # rotational transform to plot the wheelie in an generic plotting
      # space.

      ccnt={round(($#-1)/3,1,-1)}
      -input $ccnt,1,1,12
      -name. args

      # Iterate over argument vector. For each triplet – representing a
      # wheelie circle – Fetch radius (rad), phase angle (ang) and
      # angular velocity (sf) parameters.

      -repeat $#-1,j
         -if   $j%3==0 # get radius
            rad=${a{2+$j}}
            -check isnum($rad)" && "$rad>=0" && "$rad<=1
            -set[args] $rad,{round($j/3,1,-1)},0,0,0
         -elif $j%3==1 # get angle, degrees
            ang=${a{2+$j}}
            -check isnum($ang)" && "$ang>=0" && "$ang<=360
            -set[args] $ang,{round($j/3,1,-1)},0,0,1
         -else         # get ω and set spectral coefficient
            sf=${a{2+$j}}
            -check isint($sf)" && "abs($sf)<=0.1*$sw
            -set[args] $sf,{round($j/3,1,-1)},0,0,2
         -fi
      -done

      # Iterate over argument image, each 12 channel pixel representing
      # one wheelie. The first three channels contain wheelie radius,
      # phase angle and radial velocity. Compose a homogeneous matrix
      # transforming the origin to the tip of the wheelie radius, a
      # radial translation and phase rotation. Populate the nine
      # remaining channels with this matrix.

      -fill[args] ">
                     CPX=I;
                     orot=rot([0,0,1],deg2rad(CPX[1])); # phase rotation
                     xlat=eye(3);
                     xlat[2]=CPX[0];                    # translation origin-to-rim
                     FIN=[CPX[0,3,1],mul(orot,xlat,3)]; # args+"RADX" i.e. 'rotation & xlation'
                     FIN                                # store above in 12-channel pixel
                  "

      -permute[args] cyzx
      -store[args] circles

      # Partial screenspace transform.
      ssxfrm={">
                 specw=get('sw',0,0);
                 id=eye(3);
                 id[0]=0;
                 id[1]=specw/1.5;
                 id[2]=specw;
                 id[3]=-specw/1.5;
                 id[4]=0;
                 id[5]=specw;
                 id"}

      # Homogeneous position vectors for plotting initial/final segments
      tracerim={vector3([0,0,1])}
      firstpt={vector3([0,0,1])}

      # Transparent image to plot wheelies themselves
      -input [arabesque],[arabesque],[arabesque],[arabesque]
      -name. wheelplot

      # Stash background for duplication in loop
      +store[background] back

      # Animate arabesque
      atk=0
      -repeat $frames_per_rev,k
         atk={2*pi*($k/($frames_per_rev-1))}
         -local[arabesque,background,wheelplot]
             -input $multiplerimage
             -mul[arabesque,multiplier]

             # Plot wheelie indicators: rotate wheelies by their respective
             # angular velocity increments, compose this rotation into the
             # pre-computed phase, radial-displacement transform from the
             # argument image, compose with screenspace transform and plot
             # via polygon()

             -eval[wheelplot]   ">
                                begin(
                                        ccnt=get('ccnt',0,0);
                                        omega=get('atk',0,0);
                                        fpr=get('frames_per_rev',0,0);
                                        ik=get('k',0,0);
                                        fpt=get('firstpt',3,0);
                                        trc=get('tracerim',3,0);
                                        pp=vector"{3*($ccnt+1)}"([0,0,1]);
                                        circs=get('circles',"{12*$ccnt}",0);
                                        repeat(
                                                 ccnt,k,
                                                 idx=ccnt-k-1;
                                                 rbradx=mul(rot([0,0,1],circs[12*idx+2]*omega),circs[12*idx+3,9,1],3);
                                                 repeat(
                                                         k+1,j,
                                                         foo=rbradx*pp[3*(k-j),3];
                                                         pp[3*(k-j)]=foo[0];
                                                         pp[3*(k-j)+1]=foo[1];
                                                         pp[3*(k-j)+2]=foo[2];
                                                       )
                                              );
                                       ssx=get('ssxfrm',9,0);
                                       repeat(
                                                ccnt,k,
                                                    p0=ssx*pp[3*(k),3];
                                                    p1=ssx*pp[3*(k+1),3];
                                                    polygon(#$wheelplot,-2,[p0[0,2],p1[0,2]],1,0xffffffff,[115,160,205,255]);
                                                    ellipse(#$wheelplot,p0[0,2],1,1,0,1,[230,90,45,255]);
                                              );
                                        plt=ssx*pp[0,3];
                                        ik>0?
                                           polygon(#$arabesque,-2,[plt[0,2],trc[0,2]],1,0xffffffff,[255,200,100,255]):
                                           store(plt,'firstpt',3,1,1,1);
                                        store(plt,'tracerim',3,1,1,1);
                                        ellipse(#$wheelplot,plt[0,2],2,2,0,1,[230,90,45,255]);
                                        ik==(fpr-1)?
                                           polygon(#$arabesque,-2,[fpt[0,2],plt[0,2]],1,0xffffffff,[255,200,100,255])
                                     )
                              "
             -blend[background] [arabesque],alpha
             -blend[background] [wheelplot],alpha
             -mul[wheelplot] 0
             -mv[background] 0
             -name[background] frame-$k
         -endlocal
         -input[-2] $back
      -done
      -rm[wheelplot,background]
   -endlocal # [arabesque,background]

#@cli durga : _radius_0,_phase_0,_angular_velocity_0,…,_radius_k,_phase_k,_angular_velocity_k,… : (no arg)
#@cli : Sequence a series of animations by successively adding wheelies, one
#@cli : at a time, starting with the initial wheelie that just generates a
#@cli : circular arabesque. Furnish any number of wheelie triplets in the
#@cli : argument list, or leave that list empty; durga will generate a list of
#@cli : five randomly composed wheelies. Selected image sets the animation
#@cli : size and background composition. Framerate is fixed at 24
#@cli : frames/second. Select the background image to set animation frame
#@cli : size. Arguments should be in groups of three: radius, phase, angular
#@cli : velocity.
#@cli : $ 512,512,1,3 -durga 1,0,1,0.7,0,-3,1,0,2,0.5,0,-3,1,0,2  -output durga_arabesque.mp4,24,H264
durga : -skip "${1=}"
   emsg="Select the background image to set animation frame size. Arguments should be in groups of three: radius, phase, angular velocity."
   frames={24*6}
   -local[]
      is_arg={isnum("$1")}
   -onfail
      is_arg=0
   -endlocal
   -if size([$[]])==0
      -input 300,300,1,3,lerp([200,200,230],[230,200,200],y/(h-1))
   -fi

   # Create, get construction images
   -name. background
   -remove_opacity[background]
   -input[-2] (0.99^0.94^0.92^0.998)
   -name.. multiplier
   -input[-3] [background],[background],[background],4
   -name... arabesque

   # Wheelie arguments?
   -if $is_arg>0
      -if $#%3==0
         $=a
         ccnt={$#/3}
         ra=''
         ph=''
         av=''
         -repeat $#,j
            -if $j%3==0 # get radius
                   rad=${a{1+$j}}
               -check isnum($rad)" && "$rad>=0" && "$rad<=1
               ra={[[$ra],[$rad]]}
            -elif $j%3==1 # get angle, degrees
               ang=${a{1+$j}}
               -check isnum($ang)" && "$ang>=0" && "$ang<=360
               ph={[[$ph],[$ang]]}
            -else         # get ω and set spectral coefficient
               sf=${a{1+$j}}
               -check isint($sf)
               av={[[$av],[$sf]]}
            -fi
         -done
         ra={[$ra][1,size([$ra])-1,1]}
         ph={[$ph][1,size([$ph])-1,1]}
         av={[$av][1,size([$av])-1,1]}
      -else
         -error $emsg
      -fi
   # No arguments. Make up our own. Fixed at 5 wheelies, no phase displacement.
   -else
      ccnt=5
      ra={u(vector$ccnt(1))}
      ph={vector$ccnt(0)}
      av={"
             rad=u(k=vector$ccnt(1.5))-0.75;
             sgn=2*round(rad,1,1)-1;
             mag=sort(abs(5*rad),1);
             rmag=round(mag/min(mag),1,1);
             rmag*sgn
         "}
   -fi

   args=""
   +store[multiplier,background] animback
   -repeat {$ccnt},i
      -local[arabesque,multiplier,background]
         acnt={size([$args])}
         wcnt={$acnt/3}
         newargsz={$acnt+3}
         args={"
                 RA=get('ra',$ccnt,0);
                 PH=get('ph',$ccnt,0);
                 AV=get('av',$ccnt,0);
                 RL=RA[0,$wcnt+1,1];
                 scale= 1.0/sum(RL);
                 RL=round(RL*scale,0.01,0);
                 NAR=vector$newargsz(0);
                 repeat($wcnt+1,k,NAR[3*k]=RL[k];NAR[3*k+1]=PH[k];NAR[3*k+2]=AV[k]);
                 NAR
              "}
         -wheelie_anim[arabesque,multiplier,background] $frames,$args
         -input $animback
      -endlocal
   -done
   -remove[arabesque,multiplier,background]
