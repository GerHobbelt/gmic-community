%% x "mkdir -p img" rm %%
|+ [Cheat Home](cheatsheet.html) | [Custom Cheat](custom_cheat.html) | [Display Cheat](display_cheat.html) | [Debug Cheat](debug_cheat.html) | [Array Cheat](array_cheat.html) |**Substitution Cheat**
|                    |                    |                    |                    |                    |                    
### Cheat #6: Substitutions
__TL;DR:__ G'MIC substitutes directives, bracketed with curley braces, `{}`, and pipeline variables, created on assignments `=` and accessed though dollar sign prefixes, `$` as a first step in analyzing a pipeline item. G'MIC attempts to expand all directives and pipeline variables that are parts of an item before proceeding with its identification: a command reference, argument list or variable assignment.

G'MIC [substitution rules](https://gmic.eu/reference/substitution_rules.html#top) parallel counterparts found in Bash shell programming. There are directives, bracketed by `{}`, and pipeline variables, created through assignments, `=` and queried through dereferencing operators, `$`. A host of predefined pipeline variables permit access to the interpreter's environment, the image list and the images on the list.    

#### Examples:

The first example illustrates the simplest, but probably most common form, of substitution: assigning a scalar value to a pipeline variable. From that juncture forward, the dereferencing operator, `$` induces G'MIC to substitute `$twelvesquared` for `144.` In common with Bash shell programming, G'MIC pre-assigns variables `$0, $1, $2,… ` argument list elements.

The second example illustrates a [Mathematical Expression](https://gmic.eu/reference/mathematical_expressions.html#top) directive generating a vector of even numbers; when G'MIC completes processing the directive, an assignment operator `=` sets the pipeline variable `evens` to a comma-separated list of values copied from the math vector `V`. With the directive completing, the mathematical environment disappears, `$evens` referencing its surviving outcome. 

The third example illustrates the image feature directive `^`, which generates a vector from all image pixels, copying pixels in row major order. This and the previous Mathematical Expression directive, along with the other image feature directives, all take an optional first parameter, an image index, to which the directive can refer when extracting features. When omitted, the image index defaults to `[-1]`, the last image on the list.

|-     |Create a substitution|Use a substitution
| 1.  |… `twelvesquared=144` …|… `echo $twelvesquared` … 
| 2.  |… `evens={V=vector256(0);fill(V,i,i*2);V}`  …|… `16,16,1,1,$evens` …
| 3.  |… `-input 8,8,1,3 -plasma. 3,4,2 pixels={^}` …|… `echo "Image pixels: "$pixels` …

===
*twelvesquared*
~~~
$ gmic twelvesquared=144 echo $twelvesquared
[gmic]-0./ Start G'MIC interpreter.
[gmic]-0./ Set local variable 'twelvesquared=144'.
[gmic]-0./ 144
[gmic]-0./ End G'MIC interpreter.
~~~
|- * 1. Assign to a variable, "twelvesquared", a single numeric value, the square of twelve. *

*evens*
~~~
$ gmic evens={V=vector256(0);fill(V,i,i*2);V} 16,16,1,1,$evens name. Ramp
[gmic]-0./ Start G'MIC interpreter.
[gmic]-0./ Set local variable 'evens=0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,4(...).
[gmic]-0./ Input image at position 0, with values '0,2,4,6,8,10,12,14,16,18,20,22,2(...)94,496,498,500,502,504,506,508,510' (1 image 16x16x1x1).
[gmic]-1./ Set name of image [0] to 'Ramp'.
[gmic]-1./ Display image [0] = 'Ramp'.
[0] = 'Ramp':
  size = (16,16,1,1) [1024 b of float32].
  data = (0,2,4,6,8,10,12,14,16,18,20,22,(...),488,490,492,494,496,498,500,502,504,506,508,510).
  min = 0, max = 510, mean = 255, std = 148.09, coords_min = (0,0,0,0), coords_max = (15,15,0,0).
~~~
|- %% evens={V=vector256(0);fill(V,i,i*2);V} 16,16,1,1,$evens =>. Ramp n[Ramp] 0,255 r2dx[Ramp] {w*16},1 %%
| *Ramp*
| * 2. Assign to a variable, "evens", a 256 element vector generated by a mathematical expression directive, fills with a ramp of ascending, even values. *

*pixels*
~~~
$ gmic 8,8,1,3 plasma. 3,4,2 pixels={^} echo "Image pixels: "$pixels
[gmic]-0./ Start G'MIC interpreter.
[gmic]-0./ Input black image at position 0 (1 image 8x8x1x3).
[gmic]-1./ Draw plasma fractal on image [0], with alpha 3, beta 4 and scale 2.
[gmic]-1./ Set local variable 'pixels=-7.84271765,-5.36902952,3.36026835,15.0955048,20.7314415,11.7737751(...).
Image pixels: -7.84271765,-5.36902952,3.36026835,15.0955048,20.7314415,11.7737751…
~~~
|- %% 8,8,1,3 -plasma. 3,4,2 n. 0,255 r2dx. {w*32},1 %%
| *Pixels*
| * 3. Assign to a variable, "pixels", the contents of the last image on the list, using the image feature directive: `{^}` *
===

#### Substitution Context
Substitution takes place when G'MIC has been given a raw string, purporting to be a pipeline, and has already blocked it out into a sequence of items. This is the initial _decomposition_ phase of a new pipeline. With a decomposition of items in hand, G'MIC then establishes a new scope and iterates down the item list. For each item, G'MIC attempts to determine if it is a command, an argument list or a substitution assignment.

Running a small pipeline with the G'MIC in debug mode illustrates these phases. See [Debug Cheat](debug_cheat.html) for more information.
|- 1.   |`item[3]` shows a Mathematical Expression directive constituting the right hand side of an assignment, this to initialize the pipeline variable `evens`. When G'MIC encounters the curley-brackets and determines that the directive contains a mathematical expression, it invokes the math expression parser. A comma-separated list of 256 numerals returns from this environment, which G'MIC assigns to `evens`.
| 2.   |Later in the iteration, at `item[5]`, G'MIC discovers an argument list; it pairs this with the ''-input'' command. G'MIC also discovers `$evens` and executes the dereferencing command, retriving the 256 element list of numeric values that `evens` references. This furnishes the `-input` command with 260 arguments, the first four dimensioning a 16×16, single-slice, single channel image with 256 pixel initializers following on. G'MIC populates the image with these in row-major order.   
| 3.   |When in debug mode, the G'MIC interpreter shows how every substitution expands to some final value: observe the `->` expansion notation. The first expansion occured with item[3]: G'MIC called the the mathematical expression parser and substituted the results for the directive, finally assigning it to the pipeline variable `evens` Two items further down, G'MIC encounters the dereferencing of `$evens`; performs a lookup with `evens` as a key, and obtains the 256 item list of numerics, which it takes to be pixel-by-pixel initializer arguments.     

~~~
$ gmic debug evens='{V=vector256(0);fill(V,i,i*2);V}' -input 16,16,1,1,$evens -name Ramp
[gmic]-0./ Start G'MIC interpreter (in debug mode).<gmic>-0./ Initial command line: 'cli_start , debug evens={V=vector256(0);fill(V,i,i*2);V} -input 16,16,1,1,$evens -name Ramp'.
<gmic>./ Decompose command line into 8 items: 
<gmic>./   item[0] = 'cli_start'
<gmic>./   item[1] = ','
<gmic>./   item[2] = 'debug'
<gmic>./   item[3] = 'evens={V=vector256(0);fill(V,i,i*2);V}'
<gmic>./   item[4] = '-input'
<gmic>./   item[5] = '16,16,1,1,$evens'
<gmic>./   item[6] = '-name'
<gmic>./   item[7] = 'Ramp'

<gmic>-0./ Enter scope './'.
<gmic>-0./ Item[0]: 'cli_start', selection [].
<gmic>-0./ Found custom command 'cli_start: ' (takes no arguments).
<gmic>-0./ Expand command line for command 'cli_start' to: ''.
<gmic>-0./cli_start/ Return from empty command 'cli_start/'.
<gmic>-0./ Item[2]: 'debug', selection [].
<gmic>-0./ Item[3]: 'evens={V=vector256(0);fill(V,i,i*2);V}' -> 'evens=0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,502,504,(...)
[gmic]-0./ Set local variable 'evens=0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,4(...).
<gmic>-0./ Item[4]: '-input' -> 'input', selection [].
<gmic>-0./ Command 'input': arguments = '16,16,1,1,$evens' -> '16,16,1,1,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,438,440,442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,472,474,476,478,480,482,484,486,488,490,492,494,496,498,500,502,50(...)
[gmic]-0./ Input image at position 0, with values '0,2,4,6,8,10,12,14,16,18,20,22,2(...)94,496,498,500,502,504,506,508,510' (1 image 16x16x1x1).
<gmic>-1./ Item[6]: '-name' -> 'name', selection [].
<gmic>-1./ Command 'name': arguments = 'Ramp'.
[gmic]-1./ Set name of image [] to 'Ramp'.
[gmic]-1./ Display image [0] = 'Ramp'.
[0] = 'Ramp':
  size = (16,16,1,1) [1024 b of float32].
  data = 0x5642fdc761a0 = (0,2,4,6,8,10,12,14,16,18,20,22,(...),488,490,492,494,496,498,500,502,504,506,508,510).
  min = 0, max = 510, mean = 255, std = 148.09, coords_min = (0,0,0,0), coords_max = (15,15,0,0).
<gmic>-1./ Exit scope './'.

[gmic]-1./ End G'MIC interpreter.

~~~

#### Substitutions
|- 1.  |G'MIC's Substitution Rules define a set of `{ <string> }` directives. The string directs G'MIC to follow one of a number of rules that can produce nothing ("Not-a-Number," or _nan_), one alphanumeric value or a series of such, the last separated by commas. G'MIC executes the directive within the curly braces and, upon completion, replaces the cury-braced expression with the results of the directive. Mathematical Expressions are an oft-used kind of directive, but their are others providing string conversions, pipeline-within-pipeline execution, access to image features and access to display features.
|      a.  |For example, a common directive is a feature substitution rule that pairs an optional image index with a [Mathematical Expression](https://gmic.eu/reference/mathematical_expressions.html#top). In the absence of an image index, the last image on the list, `[-1]`, is assumed. G'MIC executes the mathematical expression in the context of the given image; the last statement of the mathematical expression may produce _nan_, a scalar or a mathematical vector. G'MIC replaces such curly-brace bracketed constructs with the results of the directive, without the curly braces, transcribing mathematical vectors into lists of comma separated values.
|      b.  |While (a.) has placed an emphasis on the mathematical expression feature substitution rule, there are other kinds of directives and feature substitution rules that may appear within curly braces. For example, G'MIC replaces `{n}`, the image name feature substitution rule, with the name of the last image on the list, if it has one, or its file of origination, if there is one, or the special `[unamed]` indicator otherwise. G'MIC substitutes `{ <pipeline> }` with the return status of a pipeline of commands. Consult [Substitution Rules](https://gmic.eu/reference/substitution_rules.html#top) for the full set of directives.
| 2.  |G'MIC interprets `=`, as an _assignment operator_. This operator establishes a lefthand side _variable_ as representing a (typically extensive) right hand side value: a _nan_, scalar or a list of values. The right hand side may be an explicit value or value list, or a directive within curly braces that G'MIC follows. With the right hand side evaluated, `=` assigns the outcome to the left hand side. From this point in the pipeline forward, a dollar sign `$` prepended to the variable prompts G'MIC to substitute it for the assigned right hand value.
|      a.  |G'MIC recognizes assignments according to particular _visibility scopes_, more simply "scopes". Depending on the presence, and number of, prepended underscores to a variable name, G'MIC limits recognition of assignments to _local_, _global_ or '_cross-thread_' visibility scopes.
|            i.  |Without prepended underscores, the visibility of an assignment is limited to the "local scope", that of processing of the current pipeline. Should G'MIC discover that a pipeline item references a custom command, it _enters a new scope_ — that of the custom command — and effectively "forgets" the assignments made during what is now the "parent context" or "parent scope." These parent-based assignments remain masked until G'MIC completes the pipeline defined by custom command and returns from it to the parent context, where the hitherto masked assignments become visible again. By extension, when G'MIC completes the current pipeline and exits from it — perhaps to its parent context, perhaps to the operating system shell — all the local variable assignments are deleted.
|           ii.  |With one prepended underscore, the variable becomes visible in all scope contexts that appear in a run of a G'MIC interpreter in one CPU thread. A global variable defined in one custom command is visible to all other custom commands. To the uninitiated, this seems a boon. In `… _foo=4 … echo "The value of Foo is: "$_foo` can retrieve the value assigned to `$_foo` almost no matter where the reference occurs. We can cease worrying about scope! Alas! the practice replaces one set of bothers with another, even worse set. The uninitiated soon discover that initialization protocols need to be worked out; apart from programmer's memory, there is no enforcement or control over the order that commands may be invoked, and what happens when one such command is invoked before shared global variables have been assigned initial values. There are limited cases where shared state outweighs the bother of shared state; none rank high in the list of best practices.
|          iii.  |With two prepended underscores, the variable becomes visible in all scope contexts that appear in a run of the G'MIC interpreter across all CPU threads created by the interpretor. To the perils of globally visible variables, the programmer is given those of thread synchronization and locking. There are only very limited circumstances where such are worth the management trouble.
|      b.  |Locally scoped variables are the safest, least problematic and most common form of command line variables. That they disappear when they fall out of scope is a feature, not a bug. In a well-designed command, the locally scoped variables, few in number, serve the script-writer's immediate and transitory needs. He need not focus on anything else. On leaving a scope, G'MIC deletes the locals, a kind of garbage collection that keeps the interpreter lean.
| 3.  |When G'MIC enters a scope, either the initial command line or a custom command, it is tasked to interpret a new pipeline. This goes through two phases:
|      a.  |The interpreter first itemizes, or _decomposes_ the text, roughly splitting on whitespaces, obtaining an itemized list.
|      b.  |The interpreter then enters a new scope and processes the items one at a time. On each iteration, G'MIC attempts to classify the current item as one of (i) A variable assignment: G'MIC processes the right hand side. (ii) A command: G'MIC consults an internally maintained lookup table to attempt to match the item to a known command or a shortcut version of the command, or (iii) a comma-separated argument list. G'MIC consults the classification of the previous pipeline item. If it is a command, G'MIC associates the argument list with that command. If the previous item is not a command, G'MIC infers the presence of an implied ''-input'' command and associates the argument with that. In each case, G'MIC may encounter curly braces delimiting a directive or a variable prepended with a dollar sign; G'MIC expands these substitutions first before undertaking to classify the current pipeline item. If a mathematical expression embeds substitutable elements, G'MIC expands these first, then invokes the mathematical expression parser. That parser never "sees" substitutable elements _per se_, only the results of their expansions.  
