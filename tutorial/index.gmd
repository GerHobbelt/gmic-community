# Start Here

|- ![prompt](images/prompt.mp4)|Well. There it is. *The Prompt*.\n\nPregnant with possibilities, but — _What the futz do you do with it???_ \n\nSay you want to fix an old photograph. Get rid of scratches. Dust motes. The coffee (maybe tea) stain from a coffee cup set down on a cluttered breakfast table — what, decades ago?\n\nAnd, it's the only print you have. The negative went into a box, and the box went into an attic, and the house to which the attic belonged was sold a long time ago.\n\nAnd the old photograph — it's Aunt May.\n\nAunt May. That dear sweet woman who reliably never noticed your hand in the cookie jar, decades ago, before the house was sold. That old photograph — it is your last connection with her.

What you wouldn't give to sit down with Aunt May again, some sunny Sunday morning, and talk about — oh, maybe nothing at all. Talk about nothing at all while the kitchen fills with the warm smell of baking cookies. The kitchen of that quaint, old Victorian gingerbread, now long ago gone.

Well. You've got G'MIC at *The Prompt*.

And you've got a _visual goal:_ Fix Aunt May's print.

Now — here's the problem: you lack a vocabulary to connect your visual goals with G'MIC commands.

You have no idea what to do. So you throw a _Hail Mary!_ pass:
~~~
$ gmic auntmay_oldphoto.png

[gmic]./ Start G'MIC interpreter (v.3.3.1).
[gmic]./ Input file 'auntmay_oldphoto.png' at position 0 (1 image 512x512x1x3).
[gmic]./ Display image [0] = 'auntmay_oldphoto.png'.
[0] = 'auntmay_oldphoto.png':
  size = (512,512,1,3) [3072 Kio of float32].
  data = (118,126,112,109,105,109,108,111,107,119,121,121,120,112,113,114,117,114,118,122,120,128,131,131,131,136,135,141,143,145,148,150,149,150,150,149,150,150,148,146,142,141,138,141,144,148,150,150,151,151,151,151,152,151,152,153,152,154,155,156,158,159,160,161, ... ,129,125,123,123,119,117,118,122,125,126,123,121,123,124,129,131,129,129,130,132,132,131,129,128,129,128,128,131,130,127,124,121,119,119,114,119,116,114,118,118,118,122,122,120,124,123,121,124,126,123,129,127,122,124,123,123,128,127,124,124,124,127,125,114).
  min = 46, max = 188, mean = 153.218, std = 17.6682, coords_min = (511,456,0,0), coords_max = (130,216,0,2).
~~~
===
|- %% images/auntmay_oldphoto.png r. 67%,67%,100%,100%,5 %%
| *Imgcreator-AI — [zmo.ai](https://www.zmo.ai)*
===
Hey, presto! Stuff happens! A bunch of text. And Aunt May!

Now, an older wiser you, somewhat further into the game, might pay some attention to that text. But we haven't attained that version of you yet. You're young. Impetuous — and have Aunt May's picture!

Except — you can't seem to do much with it. Mouse over: get read outs. Left or middle mouse buttons: drag. Right: zooms.

===
|![mouse_sample](images/mouse_0.mp4)|![mouse_move](images/mouse_1.mp4)|![mouse_zoom](images/mouse_2.mp4)|
===

Other keys:  `C,E,H.` Re-positioners. `Z.` Zooms. `G`. Makes grids appear — all presentation stuff. What about _changing_ stuff?

Here's the first bit: G'MIC doesn't do Windows, Icons, and Mouse Pointers (WIMP). At least, not much. It mostly does Old School Shell. Like Uncle Ken Olsen hunched over the VT-100, back in the days of DEC. 

Not keen on shells? Oh. My. Then you have a bit of learning to do. But — let's say you can get through that.

===
|-![cmd](images/pipeline.png)
|*Some pipeline following the "gmic" command*
===

Here's the next bit: What you write after `gmic` is a _pipeline_. Pipelines are ordered command sequences which operate on _image lists_. Some people call image lists _stacks_.

===
|-![noplugindocs](images/noplugindocs.jpg)
|*No gmic-qt documentation here*
===

And a third bit: If — instead — you're looking for how sliders or buttons work in the `gmic-qt` plug-in, the G'MIC inside of paint programs — Sorry. That's Not Here. We're weighing up the G'MIC _command line interpreter_ instead. Used to _create_ `gmic-qt` plug-in filters. Does that pique your interest? Then _Start Here_.

You write pipelines with the interpreter. It operates on image lists. Put some pins in that. Pipelines and image lists live at the very core of G'MIC. The [Intro Cheat](https://gmic.eu/tutorial/cheatsheet.html) takes a deeper dive, but you've written a pipeline already. You got Aunt May on the stack. She got there because you entered the ''-input'' command.

Wait — What? Never typed ''-input'', you say??!

Ah. That's because G'MIC throws its own Hail Mary passes. Should it encounter an incomplete pipeline — such as the one you wrote — it sticks an implied ''-input'' command in front of what it guesses to be an image argument. Ditto with output. If G'MIC can't find anything that looks like an ''-output'' command, it punts, appending a ''-display'' command to the end of the pipeline.

Hail Mary passes don't always work. These did. You wrote a pipeline: `-input auntmay_oldphoto.png -display`, and stumbled onto your first success.

But. You don't want to — just — stumble onto successes. Success only when stars align — _Pffft!_ You want turn-key successes. Successes so common that — you don't even think about them anymore.

===
|-![annotatedcmd](images/pipeline_2.png)
|*Commands, selections and arguments shall a pipeline make*
===

Now. Lets pull the pins. _Commands_, _image selections_, _arguments_, _duplication tics_ and _substitution variables_ constitute key pipeline elements:
| 1.  |Pipelines start with commands that, at the first go, put images on the stack.|
| 2.  |The stack is like a kitchen counter. You put images there until you can work on them.|
| 3.  |G'MIC assigns images position numbers — _indices_ — as they enter the stack.|
| 4.  |[Image Selections](https://gmic.eu/tutorial/command_decorations.html#image_selection), like _<some command>_ `[-1,-2,-3]` or _<some other command>_ `[4]`, designate images upon which commands operate. Negative indices count from the end of the stack, otherwise from the beginning of the stack.|
|    a.  |Selection-modified commands only operate on the selected.|
|    b.  |Commands without selections operate on _every_ image.|
|    c.  |Commands with empty selections don't operate on any image. _What's the point in that?_ There are cases where administrative side effects matter more than image operations. The notation insulates all images from such side effects.|
| 5.  |_Arguments_ adjust command behavior, items separated by commas, no spaces, altogether a block following its command. What kind of arguments? `gmic -help` _<some command>_ tells you.|
| 6.  |_Duplication or Replacement prefixes_: (`+`) induces duplication. Commands operate on selection duplicates, preserving originals. (`–`) induces replacement. Omit `+/–` for plain replacement.|
| 7.  |_Variable definitions: `var=` <value>_ , or dereferencing: _`$var`_, stash values. Define variables once; dereference as needed.|

There are exceptions. Selection notation can select things other than images in certain contexts — but that's getting ahead of the game. `gmic help` _<some command>_ catalogs such curiosities. Mainly, G'MIC commands do image processing. In [official distributions](https://gmic.eu/download.html), there are a little over nine hundred of them. More than a thousand counting community contributions.

At present you know about two: ''-input'' and ''-display''. It's a start.

Here are two more: ''-output'' and ''-normalize.'' 
| 1.  | ''-output'' saves images. Even if [that might not work](https://gmic.eu/tutorial/images_as_data_sets.html).
| 2.  | ''-normalize'' pegs image intensities to new minima and maxima.

That's enough for a [riff](Riffs_and_Finger_Exercises.html). Let's fix up Aunt May — at least a little bit — by re-pegging the illumination range. That is, _normalizing it_. Type this pipeline at a shell prompt:
~~~
$ gmic -input auntmay_oldphoto.png -normalize[0] 0,255 -output[0] auntmay_normed.png

[gmic]./ Start G'MIC interpreter (v.3.3.1).
[gmic]./ Input file 'auntmay_oldphoto.png' at position 0 (1 image 512x512x1x3).
[gmic]./ Normalize image [0] in range [0,255], with constant-case ratio 0.
[gmic]./ Output image [0] as png file 'auntmay_normed.png' (1 image 512x512x1x3).
[gmic]./ End G'MIC interpreter.
~~~
===
|- %% images/auntmay_oldphoto.png r. 67%,67%,100%,100%,5 n. 0,255 %%
| *Aunt May, normalized from zero to two hundred, fifty-five.*
===

Now the old girl has a little more punch. And color! Though still a mess. Yet — progress. A little victory.

Take a look at that text now — the G'MIC shell log: this consists of lines beginning with `[gmic]`, or sometimes `<gmic>`. Seems pretty straightforward: Input. Process (normalize). Output. Typical lines of action. Of course, choosing lines of action may be a bit sketchy for you at the moment. You still know (almost) next to nothing. But the steps forward are plain.

You need to increase your G'MIC vocabulary. 

And, as you increase your G'MIC vocabulary, the ways to reach visual goals becomes clearer. So here's the plan:

| 1.  |First, you need to make peace with your shell's [command line interpreter](https://gmic.eu/tutorial/riffs_and_finger_exercises.html). That way you can run G'MIC commands without the shell's "help".
| 2.  |Next, cease being an adult (at least for awhile). Rediscover childhood. Climb into sandboxes and do [riffs](https://gmic.eu/tutorial/riffs_and_finger_exercises.html#riffs).
| 3.  |Then, from time to time, translate the more interesting riffs into [finger exercises](https://gmic.eu/tutorial/riffs_and_finger_exercises.html#finger_exercises). These [elementary custom commands](https://gmic.eu/tutorial/custom_cheat.html#cheat_2_use_custom_commands_to_bypass_the_shell) work like "walled gardens" for structured experimentation. At the end of the day, you may very well have a new G'MIC command of your very own design.
| 4.  |Go back to step 2 and repeat. Forever.

## An Empyreal Journey
Of course, it's more than vocabulary. It's also grammar, of having G'MIC's whole structure at your beck and call. Sucessions of riffs and finger exercises carry you forward until, one day, an enthralling sense of alchemy overtakes you. You'll grasp the whole from its parts, and never again will you size up an image without having a collateral assay of G'MIC commands rush into your head — it becomes just a part of everyday perception.

In the meantime, you are a _nascent digital artist_. Seek inspiration from the world around you. Look at textures, surfaces, [The G'MIC Gallery](https://gmic.eu/gallery/), clothing fabric, [Funny Oneliners](https://gmic.eu/reference/funny_oneliners.html#top), fields of grass. Tree bark. [Concrete Textures](https://forums.getpaint.net/topic/113576-reptorians-gmic-code-workshop/?do=findComment&comment=553909).

Can you write pipelines that render (maybe somewhat faux) versions of these? Yes you can. At first, keep it simple. [Can you make a ramp?](https://gmic.eu/oldtutorial/ramps_input-and-fill.shtml) Seems probable. How about a [diffusion tensor field](https://gmic.eu/tutorial/do_your_own_diffusion_tensor_fields.html)? Uh. That last one may be a bit of a reach. But keep calm and carry on. With each step toward the more complicated cases, futher riffs and finger exercises suggest themselves. Scrounge around the tutorials. Post questions at [Discuss Pixls: G'MIC](https://discuss.pixls.us/c/software/gmic/10) or gamble a day away on writing [one-liners](https://discuss.pixls.us/t/one-liner-challenge/8785). Always set challenges for yourself. Here are a few to get started:

===
|-![ampstamp](images/ampstamp.png)|![xor](images/testpattern.png)
| _How to [stamp ampersands all over the place](images/cnvlv.webm)_ \nOr any other shape. Turn the trick with a small binary image (an ampersand!) and a large, mostly black image, but with scattered pulses — non-zero pixels. The convolution of a pulse and a shape reproduces the shape — on the first pass. What happens with more passes?| _XORing the Addressing_ \nThe exclusive OR (XOR) operator reports False on identical inputs and True on differing inputs. What if we set the value of every pixel in a 128×128 image with the XOR of its coordinates? Can we [animate it?](https://gmic.eu/reference/funny_oneliners.html#xor_animation)?
|![cabstract](images/cabstract.webm)|![cellsandroads](images/cellsroads.png)
| _How to animate as if in a dream?_ \nAnything that G'MIC can apply to a single image can apply to a sequence. Here: slightly differing ''-warps'' of an image, applied in not quite identical ways, to each channel, the lot changing over time. See [the TV on the Fritz](https://gmic.eu/oldtutorial/spectral-art_tiletex.shtml) for the overlying technique.| _How to make a network of roads?_ \n[Bandpass](https://gmic.eu/oldtutorial/road-systems.shtml) salt-and-pepper [noise](https://gmic.eu/reference/noise.html#top) for a smooth-varying pattern that tiles vertically and horizontally. Off-center [thresholding](https://gmic.eu/reference/threshold.html#top) — something other than 50-50 — so that either white or black regions connect and the other forms islands. Morphologically [thin](https://gmic.eu/reference/thinning.html#top) on the island color so that islands expand to their limits. Blur-and-threshold to finish up. Roadways among the hills, perhaps, or biological cells.
===

## Tutorial Land
If all else fails, read the manuals.

|-''Riffs and Finger Exercises''|New to G'MIC? These are your next steps: Build your vocabulary with riffs and finger exercises.
|''Introduction''|A historical introduction. Read it when you need a break from finger exercises.
|''Basics''|Everything written here, but a deeper dive.
|''Images''|What an image looks like to G'MIC.
|''Selections''|Limit commands to work only on certain images.
|''Math''|It started out as an image calculator. It became a programming language.
|''Beginner's Cookbook''|Fake hair. Crazy blurs. Tiles. Arabesques. Thing is, you have to be fairly advanced before you reach the Beginner's level. Welcome to G'MIC, by the way.
|''Command Guide''|Tutorials written around not nearly enough commands.
|''Bouncing Balls Tutorial''|Deploy a G'MIC animated loop that exemplifies evolving or changing imagery. Comes with a behind-the-scenes look at how the script came to be: [Live G'MIC script coding](https://www.youtube.com/watch?v=UEWacWaDK8w&t=527s)
|''Cheatsheet''|Quick recipes to get things done. Or maybe undone.
|''Contribute''|None of this documentation wrote itself.

Updated: 07-May-2023 17:10 UTC Commit: 79f1223f76abc9d217cab05bf38ca89560b76ee6
