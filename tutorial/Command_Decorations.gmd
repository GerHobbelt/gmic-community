# Command Decorations
===
|%% images/select.png r2dy 300 %%
|*You. Yes. I mean you.*
===
By default, commands operate on all images in the image list, aka the _stack_. Often that is not what we want.

The stack can, and often will, contain many items. As we ''-input'' or otherwise conjure images, the interpreter places them in sequence, assigning indices to them starting from zero as it goes along.

| 1.  |Non-negative indices designate images with respect to the beginning of the stack. That is, 0, 1, 3 designate the first, second and fourth image.
| 2.  |Negative indices designate images with respect to the end of the stack, i. e., –1, –2, –3 designate the last, penultimate and third from the last image. In a stack of four images, both –1 and 3 designate the same image, the last one in the stack. –4 and 0 designate the first image.

## Image Selection

G'MIC allows us to decorate commands on their right hand sides with selections that restrict the scope of a command to a subset of items in the image list. Square brackets immediately to the right of the command, with no separating white space, may contain collections of image selecting indices. Thus, the pipeline:
~~~
noise[0] 0.5,2 blur[2] 10 diffusiontensors[–1] 0,1,0.7,2.3
~~~
applies noise only to just the first image on the stack, then blurs just the third and generates diffusion tensors from the last.

This illustration notwithstanding, selection notation is extensive. Selection syntax has expressions for selecting single or multiple images, ranges of images, every other, every third, or, generally, every n-th image, relative to the beginning or end of the stack, relative to the size of the overall stack, relative to named collections, and all images except the ones designated by a selection. It is easy (and probably inevitable) to select images which are not on the stack, an error.

Here are the ways to restrict to selected images the action of some fictive command called `-foo`:

|+ __Type__ | __Template__ | __Description__
| **Everything** | `-foo` | Operates on every image on the stack.
| **Left Single** | `-foo[n]` | Operates on image 'n+1', counting from the beginning of the stack. `[0]` is a common idiom demarking the first image on the stack. Example: `-foo[3]` operates on the fourth image on the stack.
| **Right Single** | `-foo[–n]` | Operates on image '–n', counting from the end of the stack. `[–1]` is a common idiom demarking the last image on the stack. Example: `-foo[–2]` operates on the penultimate image in the stack.
| **Enumerated** | `-foo[a,–b,...z]` | Comma separated indices. Operates on specific images. Indices may have negative signs; these are counted from the end of the stack. Example: `-foo[0,2,–1]` operates on the first, third and last image on the stack.
| **Range** | `-foo[a-b]` | Hyphenated indices. Operates on images in the range from `a` to `b` inclusive. Example: `-foo[3-5]` operates on the fourth, fifth and sixth images. `-foo[–3-–1]` operates on the third from the last, next to the last and last images.
| **Relative Range** | `-foo[a%-b%]` | Hyphenated percentages. Operates on image ranges specified through relative positions, with `100%` designating the last position on the stack, however large it may be. Example: `-foo[50%-100%]` operates on images on the upper half of the stack.
| **Modulo n** | `-foo[<Range>:n]` | Given a range of images, operates on every n-th image in the range. `-foo[:n]` is an error. Example: `-foo[0-–1:3]` operates on every third image on the stack. `-foo[50%-100%:2]` operates on every even-indexed image on the upper half of the stack.
| **Except** | `-foo[^<selection>]` | Caret preceding a selection. Operates on all images except those in the selection. Example: `-foo[^0]` operates on all images except the first one. `-foo[^0-–1:2]` operates on every odd-indexed image on the stack.
| **Names** | `-foo[<label>]` | Operates on images designated by name `<label>`, an alphanumeric string which begins with a letter. Raises an error if `<label>` has not been defined. Use `name[<selection>] <label>` to establish an equivalence between `<label>` and the images identified by `<selection>`. Observe that the `<selection>` itself has no lasting significance; it serves only in the moment to designate which images belong to the set `<label>`. See the following example.
| **Enumerated Names** | `-foo[<label-1>,...]` | Operate on images designates by a series of labels which must already be defined. The overall selection is the union of the individual labeled collections.

===
%% 1,1,1,3 [0]x3 name[0--1:2] Evens input[0] 1,1,1,3 name[0] IAmFirst fill_color[Evens] 255,0,127 fill_color[IAmFirst] 0,127,255 _parse_cli_images %%

*Example: Evens are odd.*
===
~~~
gmic -input 1,1,1,3 [0]x3 -name[0-–1:2] Evens -input[0] 1,1,1,3 -name[0] IAmFirst -fill_color[Evens] 255,0,127 -fill_color[IAmFirst] 0,127,255
~~~

This pipeline paints only odd-numbered stack items with a kind of magenta, despite what the label `Evens` implies; that label spoke to Truth only in a moment and fell out of step when `-input[0] 1,1,1,3` executed.

It is possible to mix types in selections, thus `-foo[1,3,5-–1]`, mixing an enumeration and range, selects the second, fourth, and sixth through the last image.

It is also possible that images may be designated more than once, as in `-foo[0-–1:2,2,4,6]`, which selects all the images with even indices on the stack, then explicity selects the images corresponding to indices 2, 4 and 6.  G'MIC regards the collection of indices in selections as sets of distinct elements, so images are not selected twice, nor is there any relevance to the order of indices. `-foo[0,1,2]`, `-foo[2,1,0]`, `-foo[2-0]`, `-foo[0,1,0,2,1,2]` all select the first three images on the stack.

Here are some common examples:

| 1. | `-blur 20` | Blur all images on the stack with a standard deviation of 20.
| 2. | `-blur[0] 10` | Blur the first image on  the stack with a standard deviation of 10.
| 3. | `-blur[–1] 5` | Blur the last image on the stack with a standard deviation of 5.
| 4. | `-blur[0,2,5] 7` | Blur the first, third, and sixth image on the stack with a standard deviation of 7.
| 5. | `-blur[^3] 6` | Blur all images on the stack except the fourth one with a standard deviation of 6.

## Isolated Selections: Implied Copy Command

Selections in isolation, apparently not modifying any command, imply '-copy' (which, by this explicit name, doesn't actually exist). The images designated by the selector are duplicated and the interpreter places the copies at the end of the stack in the same relative order as their antecedents. Thus `[0,3,5]` by itself copies the first, fourth and sixth images; the copy of the first image becomes `–3`, the copy of the fourth becomes `–2` and the copy of the sixth becomes `–1`.

Selections in isolation also support a multiplier postfix, the example already seen but hitherto left unexplained. `gmic -input 1,1,1,3 [0]x3` conjures a one pixel image out of the aether and three copies are made of it, leaving four 1×1×3 pixel images on the stack.    

## Lefthand Decorations: Replace or Append

Commands may be decorated on the lefthand side. Hyphens optionally distinguish commands from other items. Omit them for brevity; include them for clarity. It so happens that the command line interpreter silently strips lefthand hyphens as an early step in command interpretation. Hyphens serve only the Goddess of Readability, but in the cause of diminishing command line confusion they serve her well. Lefthand `+` decorations, however, have "copy first" semantics and matter for transformative commands: those that take selected images as inputs, transform image content and then produce an output.

| 1. |Transformative commands without hyphens or with single hyphens will replace the images they select.
| 2. |Transformative commands decorated with `+` on the lefthand side first copy the images they select. The new images go on the end of the stack. The command then operates on those copies.
| 3. |Non-transformative commands, such as `name`, throw an error with lefthand `+` decorations.

Non-transformative commands are those which implement aspects of G'MIC program flow or management of the environment; they do not operate on the contents of images. We have seen one example already. ''-name'' labels an image collection but does not otherwise transform those so labeled. Writing `+name…` throws an exception.

## Command Line Anatomy

Consider how this command line builds an image list:

~~~
$ gmic 256,256,1,3 noise[–1] 0.05,2 +bandpass[–1] 0.0005,0.001 +threshold[–1] 30% +negate[–1] thinning[–1] -normalize[^0] 0,255 output mystack.cimg
~~~

| 1. | `256,256,1,3` conjures up a 256x256x1x3 pixel image with three channels, initially solid black, establishing a stack with one image. The ''-input'' command is implied.
| 2. | The `noise[–1]` command, no hyphen, two parameters, replaces this black image with a sparse, random scattering of red green and blue pixels ("Salt and Pepper Noise"), so the stack remains with one image.
| 3. | The `+bandpass[–1]` command, with a `+` left hand decorator, duplicates the image at the end of the stack and operates on that, leaving a new last image with the low-frequency components of the previous image. There are now two images on the stack.
| 4. | Similarly, `+threshold[–1]` copies the last image (`+`), then applies a bilevel reduction to each channel of what is now the last image. This leaves three images on the stack.
| 5. | `+negate[–1]` Again a copy-modify of the last image (`+`) inverting color-and-values. The stack now has four images. 
| 6. | `thinning[–1]` morphologically thins the last image, leaving behind the 'morphological spines' of the contiguous, non-black regions of the former version. Observe that the former version is gone, replaced by the thinned version now occupying the end of the stack. Four images remain on the stack.
| 7. | `-normalize[^0]`, with an optional hyphen, replaces all images on the list, except the first one, with corresponding versions where the intensity range of each channel is remapped to the range 0 – 255. The image list still has four images. Had we decorated this command with '+', the stack would have had seven images, the second, third and fourth images followed by their normalized versions in positions five, six and seven.
| 8. | We save the entire stack via `output` in the file `mystack.cimg`, where files of type `.cimg` are of the [native G'MIC format](https://gmic.eu/tutorial/images_as_data_sets.html#nothing). Just prior to this output, however, the four images on the stack look like this:

===
%% 256,256,1,3 noise[-1] 0.05,2 +bandpass[-1] 0.0005,0.001 +threshold[-1] 30% +negate[-1] thinning[-1] normalize[^0] 0,255 output img/mystack.cimg _parse_cli_images %%
===

For practical purposes, `mystack.cimg` is the stack on ice. We may restore it minutes/days/months/years later and perform further operations on it:

%% img/mystack.cimg blend[-2,-1] luminance keep[-1] r2dx. 256,5 output img/crossedblobs.png rm %% 
===
![crossedblobs](img/crossedblobs.png)
*Crossed Blobs*
===

~~~
gmic -input mystack.cimg -blend[-2,-1] luminance -keep[-1] -output crossedblobs.png
~~~

## Shorthand Selection Notation

It is very common to operate on the last, penultimate, and third-from-last images on the stack. Righthand command decorations such as `[–1]`, `[–2]` and `[–3]` are so prevalent that they have an alternate shorthand form: one, two and three 'pips':

- `-foo[–1]` is equivalent to `-foo.`, operates on the last image on the list.
- `-foo[–2]` is equivalent to `-foo..`, operates on the penultimate image on the list.
- `-foo[–3]` is equivalent to `-foo...`, operates on the third-from-last image on the list.

G'MIC supports this shorthand notation only as a command decoration, not in any other place where a selection might be used, as an implied copy or as an argument to another command. Nor do pips work in selection expressions. The fictive command `-foo[0,...]` will not operate on the first and third-from-last image.

## Common Idiomata

It is not uncommon to see these repeating idiomata:

---
- `...+foo[–1] <parameter list> +bar[–1] <parameter list>...`: Constructs a progression of the effects of a series of commands; the images accumulates effects from left to right....
---
- `+foo[0] <parameter list> +bar[0] <parameter list>...`: Illustrates the effect of different commands on one image.
---
- `+foo[<range>] <parameter list>`: Illustrates the effect of one command on a range of images.
---
- `+foo <parameter list>`: Illustrates the effect of one command on all images.
---

| __Updated:__ |  18 September 2022 15:29 UTC Commit: 55696ab09f3d
